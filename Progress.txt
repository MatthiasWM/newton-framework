
Created by Matt on Jan 10 2025
==============================


Initial Work
------------

So far we have one version of the Framework with all assembler code replaced
with C++. The compiler, interpreter, and decompiler are test for basic
functionality and work on ARM64. Objective-C code was replaced with C++ so
the Framework can compile on MSWindows and Linux. The framework is built
using a C++ file.

Getting the MessagePad project to run is more involved because the scheduler
was rewritten in ARM32 and Intel32/64, but not ARM64. To stay independent of
future CPUs that may be used, we need to rewrite al machine code in (modern)
C++.


Xcoe 15.2 on Intel
------------------

So as of today (Jan 10 2025), the MessagePad project compiles on 64bit Intel,
Xcode 15.2, and runs under macOS Venture 13.17.1 . We do get audio output,
but no screen output. The app locks up in `LoadHighROMFramesPackages()`, which
is pretty far down the boot process.


Screen Output 1
---------------

So far, there are no Newton QuickDraw routins implemented. The startup note
is drawn using Cocoa/CoreGraphics calls.

CMainDisplayDriver::screenSetup() is called from CNewtWorld::mainConstructor()
via InitScreen(). fPixMap.baseAddr points to the screen bitmap and is set to a
striped pattern. SetupScreenPixelMap() sets up gScreenPixelMap for QD access
and gAlertScreenInfo. Pixel data is stored in gScreenPixelMap.baseAddr.

InitScreenTask() sets up a bunch of semaphores and starts the task
ScreenUpdateTask() which is commented out here. The task, managed by two
semaphores, would have looped every 30ms and called UpdateHardwareScreen()
which copies dirty pixels from the unrotated screen to the hardware buffer
(see BlitToScreens(), see CMainDisplayDriver::blit()).

Eventually StartDrawing() in CNewtWorld::mainConstructor() calls Semaphore
gScreen.f24 which would then unlock the ScreenUpdateTask().

blit() eventually calls CGContextDrawImage(quartz, ...), but is that enough to
get actual pixels onto the screen?

WeAreDirty() should tell Cocoa to finally update what's on the macOS screen.

We can trigger blit with the current code by clicking on the screen which
calls CInker::drawInk() and then CLiveInker::stopLiveInk(). This copies changes
into our Cocoa layer, then calls WeAreDirty(), which then copies the layer data
to the macOS screen.


Loading and Installing Newton.rex
---------------------------------

Checking CPackageEventHandler::beginLoadPackage()
CPackageEventHandler::loadNextPart
CPackageEventHandler::installPart
We will hang in sendRPC.CPkPartInstallEvent for part 0 of "Cardfile" (kInstallPartEventId)
This should be handled in CPartEventHandler::eventHandlerProc(), but
CPartEventHandler never receives the kInstallPartEventId.
Part ID is 'auto', size is 144308.
Event is 'newt' 'pckm' 'prti', compressor is 0xa9

OS/Newton.rex is added to the MessagePad bundle and it is read into memory
by RExScanner().

LoadHighROMPackages():
	There are 10 packages in the 717006 ROM:
	 1 Cardfile app    -> 'auto', ROMData/Package-1.newtonpkg etc., are they 32bit MSB first?
	 2	Connection app  -> 'form'
	 3	FaxViewer app
	 4	Formulas app
	 5	Help book
	 6	ListView
	 7	TScreenMemory:TReservedContiguousMemory protocol
	 8	TMainDisplayDriver:TScreenDriver protocol
	 9	Setup app
	10	WorldData soup

As it seems right now, the 'pkgm' event handler is recursively calling pkgm
to install the part it just loaded, but it's not ready to receive new events yet?

Also look at CPackageEventHandler::searchRegistry, CAppWorld::eventLoop...

Note: when installing drivers, this will return kOSErrPartTypeNotRegistered and
      not try to install "Cardfile". The next package returns kOSErrBadPackage,
      so there seems to be an error reading the package from memory (probably
      32 vs. 64 bit?!).

Newton.rex is only 145kB bytes, which corresponds to package 1. All
packages together are 844kB. OS/REx.config has all package but 1 commented
out, so this may be intentional. The REx starts at 0x10000000 ?! "Cardfile"
seems to be a custom extension that we don;t really need, so I disable
loading the REx for now.

Later:
- How do we link to Cardfile.pkg? There should be 8 packages or so in the REx0,
  but we fail after the first package. Why?
- If we can load more packages, will they also install, or will we hang earlier?


NewtonScript User Exception
---------------------------

Starting the OS without the REx will lead to an
"Unhandled exception evt.ex.fr.intrp;type.ref.frame -- warm reboot!"
Error code = -48809 (kNSErrUndefinedMethod) in DoSend, implementor is NIL,
DoMessage, SoupSetInfo

CNewtWorld::preMain(): pkgSoup:SetInfo([initialized, extrasState]);

Disabeling this call for now.


Event Loop
----------

So now we actually reach CAppWorld::eventLoop().


Drawing Stuff
-------------

Clicking on the screen will
launch NS code trying to load NotePad that eventually crashes somewhere
using CoreGraphics with an invalid context drawing an image or drawing text.

Graphics/DrawImage.cc/DrawBitmap()
../DrawPicture()
../FCopyBits() (t=434, l=240, b=434, r=240)

Disassembling DrawBitmap() and trying to understand how to go from ARM32 to C++.
It calls CopyBits() which we shoudl translate next. It's marked in the code
as "The dreaded CopyBits", so I assume thsi will be hard... .

This calls CallBits() then StdBits(), or StretchBits().

StdBits() calls PutPixMap__FP8PixelMap() or PutGrayTable__FP8PixelMap()
or PutPicWord__Fl() or PutPicData__FPcl(), PutPicByte__Fc(),
PutPicRgn__FPP6Region(), or StretchBits__FP8PixelMapT1P4RectT3lPP6RegionN26().

PutPicData(char *, long) calls StdPutPic(), which call BlockMove(). That
should probably be it?!

StretchBits__FP8PixelMapT1P4RectT3lPP6RegionN26 seems to be the standard route
we take here. That function is *really* long...

Hardware Screen Memory is at physical address 0x043c00000 ??
OS Screen Memeory is at 0x0ca6b000 ??

( Unscaled1to4__FPlN21l BlitModeCopy__FPlN21lN24 )
Command at 0x002aeddc in BlitModeCopy writes image data?

Next:
- Replace all CoreGraphics call with the original code that writes into the
  Newton screen buffer (basically find all occurences of `quartz` and instead
  translate the original Newton QD code).
- Make sure that the routine to copy disply changes to the frame buffer is launched.
- Make sure that the timer is running and the display task can be triggered
- Make sure that the display task does copy pixels to the Cocoa screen and if those
  pixels become visible.

Note: CPackageEventHandler::installPart outArgs are 32 bit, but should be 64!
Note: when we get there: InitFonts() is commented out.
