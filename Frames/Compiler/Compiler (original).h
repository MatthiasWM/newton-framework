/*	File:		Compiler.h	Contains:	NewtonScript compiler classes.	Written by:	Newton Research Group.*/#if !defined(__COMPILER_H)#define __COMPILER_H 1#if !defined(__INTERPRETER_H)#include "Interpreter.h"#endif#if !defined(__OPCODES_H)#include "Opcodes.h"#endif#if !defined(__INPUTSTREAMS_H)#include "InputStreams.h"#endiftypedef char Str255[256];typedef int MsgEnvComponent;class	CFunctionState;class	CLoopState;/*------------------------------------------------------------------------------	C C o m p i l e r------------------------------------------------------------------------------*/class	CCompiler{public:					CCompiler(CInputStream * inStream, BOOL inDoFirstCmdOnly = NO);					~CCompiler();	Ref			compile(void);	int			parser(void);	BOOL			parserStackOverflow(void);	int			getToken(void);	int			yylex(void);	UniChar *	getCharsUntil(UniChar inCh, BOOL isString, size_t * outSize);	int			getNumber(UniChar inCh);	void			newFunctionState(RefArg inArgs, CFunctionState * inFS, int * ioDepthPtr);	Ref			endFunction(void);	void			simplify(RefArg inGraph);	void			walkForDeclarations(RefArg inGraph);	int			declarationWalker(RefArg, int, RefArg, RefArg, RefArg, RefArg, RefArg);	void			walkForClosures(RefArg inGraph);	int			closureWalker(RefArg, int, RefArg, RefArg, RefArg, RefArg, RefArg);	int			walkForCode(RefArg inGraph, BOOL);	int			walkAssignment(RefArg, RefArg, BOOL);	Ref			walkForPath(RefArg inGraph, int * ioNumOfPathElements);	int			walkForStringer(RefArg inGraph);	BOOL			isConstantExpr(RefArg inGraph);	Ref			evaluateConstantExpr(RefArg inGraph);	ArrayIndex	freqFuncIndex(RefArg inName, ArrayIndex inNumArgs);	void			emitFuncall(RefArg inName, ArrayIndex inNumArgs);	void			emitReturn(void);	void			emitBranch(ArrayIndex inPC);	void			emitPop(void);	void			emitPush(RefArg inValue);	void			emitVarGet(RefArg inName);	void			emitVarSet(RefArg inName);	void			emitVarIncr(RefArg inName);	void			emit(Opcode a, int b);	ArrayIndex	emitPlaceholder(void);	ArrayIndex	curPC(void);	void			backpatch(ArrayIndex inOffset, Opcode a, int b);	void			warning(const char * inMsg);	void			syntaxError(const char * inMsg);	void			error(NewtonErr inErr);	void			errorWithValue(NewtonErr inErr, RefArg inValue);	CFunctionState *	func;				// +00//	ArrayIndex	lineNumber;				// +04	now maintained by the input stream	CInputStream *		stream;			// +08	int			stackSize;				//	+0C	yystacksize, yacc stack size	RefStruct	yaccStack;				// +10	Ref *			vStack;					// +14	parser value stack	short *		sStack;					// +18	parser state stack	BOOL			do1CmdOnly;				// +1C//	int32_t		x20;						// +20	never referenced	int *			funcDepthPtr;			// +24	BOOL			isStackedToken;		// +28	int			stackedToken;			// +2C	RefStruct	stackedTokenValue;	// +30};/*------------------------------------------------------------------------------	C F u n c t i o n S t a t e------------------------------------------------------------------------------*/class	CFunctionState{public:				CFunctionState(CCompiler * inCompiler, RefArg inArgs, CFunctionState * inFunc, int * ioDepthPtr);				~CFunctionState();	Ref		makeCodeBlock(void);	void		addConstant(RefArg, RefArg);	void		addLocals(RefArg);	BOOL		atTopLevel(void);	CFunctionState *	context(void);	void		beginLoop(void);	void		addLoopExit(void);	void		endLoop(void);	void		computeArgFrame(void);	void		computeInitialVarLocs(void);	Ref		argFrame(void);	Ref		varLocs(void);	void		copyClosedArgs(void);	void		declarationsFinished(void);	Ref		getConstantValue(RefArg, BOOL *);	BOOL		isConstant(RefArg);	BOOL		isLocalConstant(RefArg);	BOOL		isLocalVariable(RefArg);	ArrayIndex	variableIndex(RefArg inTag);	ArrayIndex	literalOffset(RefArg);	void		noteMsgEnvReference(MsgEnvComponent);	BOOL		noteVarReference(RefArg);	ArrayIndex	emit(Opcode a, int b);	ArrayIndex	emitOne(unsigned char bytecode);	ArrayIndex	emitThree(unsigned char bytecode, int value);	ArrayIndex	emitPlaceholder(void);	ArrayIndex	curPC(void);	void			backpatch(ArrayIndex inPC, Opcode a, int b);protected:	CCompiler *		fCompiler;			// +00	RefStruct		fArgs;				// +04	RefStruct		fLocals;				// +08	RefStruct		fConstants;			// +0C	RefStruct		fInstructions;		// +10	RefStruct		fLiterals;			// +14	RefStruct		fArgFrame;			// +18	RefStruct		x1C;	RefStruct		fVarLocs;			// +20	ArrayIndex		fNumOfVarLocs;		// +24	ArrayIndex		fPC;					// +28	ArrayIndex		fNumOfLiterals;	// +2C	ArrayIndex		fNumOfArgs;			// +30	ArrayIndex		fNumOfLocals;		// +34	CLoopState *	fLoop;				// +38	long				fFuncDepth;			// +3C	int32_t			x40;	BOOL				x44;	BOOL				x48;	BOOL				x4C;	BOOL				fKeepVarNames;		// +50	CFunctionState *	fEncFunc;		// +54	CFunctionState *	x58;				// enclosing state};/*------------------------------------------------------------------------------	C F u n c t i o n S t a t e   I n l i n e s------------------------------------------------------------------------------*/inline	ArrayIndex		CFunctionState::curPC(void){ return fPC; }inline	CFunctionState *	CFunctionState::context(void){ return fEncFunc; }inline		Ref		CFunctionState::argFrame(void){ return fArgFrame; }inline		Ref		CFunctionState::varLocs(void){ return fVarLocs; }/*------------------------------------------------------------------------------	C L o o p S t a t e------------------------------------------------------------------------------*/class CLoopState{public:						CLoopState(CFunctionState * inFunc, CLoopState * inLoop);						~CLoopState();	void				addExit(ArrayIndex pc);	CLoopState *	endLoop(ArrayIndex pc);private:	CFunctionState *	fEncFunc;	CLoopState *		fEncLoop;	RefStruct			fExits;};/*------------------------------------------------------------------------------	C C o m p i l e r   I n l i n e s------------------------------------------------------------------------------*/inline	ArrayIndex	CCompiler::curPC(void){ return func->curPC(); }inline	ArrayIndex	CCompiler::emitPlaceholder(void){ return func->emitPlaceholder(); }inline	void			CCompiler::emit(Opcode a, int b){ func->emit(a,b); }inline	void			CCompiler::backpatch(ArrayIndex inPC, Opcode a, int b){ func->backpatch(inPC, a, b); }#endif	/* __COMPILER_H */