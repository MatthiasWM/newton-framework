/*
	File:		PackageAccessor.cc

	Contains:	Functions to access parts of a package.

	Written by:	The Newton Tools group.
*/

#include "NewtonKit.h"
#include "PackageAccessor.h"
#include "Reporting.h"
#include "RExArray.h"
#include "Frames/Objects.h"


/* -----------------------------------------------------------------------------
	Objects in memory (generated by NTK) are always big-endian.
----------------------------------------------------------------------------- */
#undef  ARRAY32LENGTH
#define ARRAY32LENGTH(_o) (ArrayIndex)((CANONICAL_SIZE(_o->size) - SIZEOF_ARRAYOBJECT32(0)) / sizeof(Ref32))


/* -----------------------------------------------------------------------------
	D a t a
----------------------------------------------------------------------------- */

PendingImport *	g12FA = NULL;
CChunk *				g12C2 = NULL;
extern RExArray *	g12BE;	// gExportTable? array of Ref32
//extern CChunk *	g12BA;	// gExportTablePadding?
extern RExArray *	g12B6;


/* -----------------------------------------------------------------------------
	F u n c t i o n   P r o t o t y p e s
----------------------------------------------------------------------------- */

int symcmp(const char * inSym1, const char * inSym2);

void RenumberImports(CFramesPartAccessor & inPart, Ref32 * inArg2, PartRef inArg3, PendingImport ** inArg4, bool inArg5);
void ProcessImports(CFramesPartAccessor & inPart, PartRef inRef);	// 7 pages
void ProcessExports(PartRef inRef, long inOffset);
void RedirectExports(CFramesPartAccessor & inPart, PartRef inRef);


/* -----------------------------------------------------------------------------
	C R e l o c a t e S c a n n e r
	Used by CFramesPartAccessor::relocate() to relocate pointer refs from
	part-relative offsets to absolute addresses.
----------------------------------------------------------------------------- */
class CRelocateScanner : public RefScanner
{
public:
			CRelocateScanner(long inOffset);

	void	scanRef(Ref32 * ioRefPtr);
private:
	long	fBaseAddr;
};

inline CRelocateScanner::CRelocateScanner(long inOffset) { fBaseAddr = inOffset; }


void
CRelocateScanner::scanRef(Ref32 * ioRefPtr)
{
	Ref32 ref = CANONICAL_LONG(*ioRefPtr);
	if (ISREALPTR(ref)) {
		ref += fBaseAddr;
		*ioRefPtr = CANONICAL_LONG(ref);
	}
}


/* -----------------------------------------------------------------------------
	C R e n u m b e r I m p o r t s S c a n n e r
	Used by RenumberImports to, erm, renumber imports.
----------------------------------------------------------------------------- */
int g12F6;	// don’t really know
int g0CD8;	// don’t really know

// see also MagicPointers.cc
#define kMPTableShift	12
#define kMPTableMask		0x3FFFF000
#define kMPIndexMask		0x00000FFF

class CRenumberImportsScanner : public RefScanner
{
public:
			CRenumberImportsScanner(Ref32 * inArg2, PendingImport ** inArg4, bool inArg5);

	void	scanRef(Ref32 * ioRefPtr);
private:
	int		f00;
	Ref32		f04;	// not really a Ref (no tag bits) but will make one
	Ref32 *	f08;
	PendingImport **	f0C;
	bool		f10;
};

inline CRenumberImportsScanner::CRenumberImportsScanner(Ref32 * inArg2, PendingImport ** inArg4, bool inArg5)
{
	f00 = g12F6;
	f04 = (g0CD8 * 2 + 2) << kMPTableShift;
	f08 = inArg2;
	f0C = inArg4;
	f10 = inArg5;
}


void
CRenumberImportsScanner::scanRef(Ref32 * ioRefPtr)
{
	Ref32 ref = CANONICAL_LONG(*ioRefPtr);
	if (ISMAGICPTR(ref)) {
		ULong rValue = ref >> kRefTagBits;		// d7
		ArrayIndex table = rValue >> kMPTableShift;	// d6
		if (table >= 2) {
			// not built-in
			ArrayIndex index = rValue & kMPIndexMask;	//d7
			Ref32 d5 = f08[table-2];
			if (f10) {
				if (d5 == -1) {
					PendingImport * spm04 = f0C[table-2];
					ref = MAKEMAGICPTR(index + spm04->f00 + (1 << kMPTableShift) + f04);
					*ioRefPtr = CANONICAL_LONG(ref);
				}
			} else {
				if (d5 == -1) {
					PendingImport * spm04 = f0C[table-2];
					if (spm04->f00 < index) {
						spm04->f00 = index + 1;
					}
				} else {
					ref = MAKEMAGICPTR(index + d5 + f04);
					*ioRefPtr = CANONICAL_LONG(ref);
				}
			}
		}
	}
}


#pragma mark -
/*----------------------------------------------------------------------
	Compare two symbol names. Case-insensitive.
	Args:		s1			a symbol name
				s2			another symbol name
	Return:	int		0		if symbol names are equal
							>0		if sym1 is greater than sym2
							<0		if sym1 is less than sym2
----------------------------------------------------------------------*/

int
symcmp(const char * s1, const char * s2)
{
	char c1, c2;
	for ( ; ; )
	{
		c1 = *s1++;
		c2 = *s2++;
		if (c1 == '\0')
			return (c2 == '\0') ? 0 : -1;
		if (c2 == '\0')
			break;
		if ((c1 = toupper(c1)) != (c2 = toupper(c2)))
			return (c1 > c2) ? 1 : -1;
	}
	return 1;
}


#pragma mark -
/* -----------------------------------------------------------------------------
	P r o c e s s P a r t
	If a part has UnitReferences we need to process imported/exported units.
----------------------------------------------------------------------------- */

void
ProcessPart(int inSelector, CFramesPartAccessor & inPart, long inPkgOffset, long inOffset)
{
//	C588(0x20);
	bool exists;
	PartRef tableRef;
	PartRef partRoot;
	partRoot.fAccessor = &inPart;
	partRoot.fRef = inPart.getArraySlot(MAKEPTR(inOffset), 0);

	switch (inSelector) {
	case 0:	// process exports
		tableRef.fAccessor = partRoot.fAccessor;
		tableRef.fRef = partRoot.fAccessor->getFrameSlot(partRoot.fRef, "_ExportTable", &exists);
		if (NOTNIL(tableRef.fRef)) {
			ProcessExports(tableRef, inPkgOffset);
		}
		break;

	case 1:	// process imports
		tableRef.fAccessor = partRoot.fAccessor;
		tableRef.fRef = partRoot.fAccessor->getFrameSlot(partRoot.fRef, "_ImportTable", &exists);
		if (NOTNIL(tableRef.fRef)) {
			ProcessImports(inPart, tableRef);
		}
		break;

	case 2:	// redirect exports
		tableRef.fAccessor = partRoot.fAccessor;
		tableRef.fRef = partRoot.fAccessor->getFrameSlot(partRoot.fRef, "_ExportTable", &exists);
		if (NOTNIL(tableRef.fRef)) {
			RedirectExports(inPart, tableRef);
		}
		break;
	}
}


/* -----------------------------------------------------------------------------
	Process exported UnitReferences.
	Args:		inTable		the _ExportTable array of unit declaration frames
				inPkgOffset	base offset
	Return:	--
----------------------------------------------------------------------------- */

void
ProcessExports(PartRef inTable, long inPkgOffset)
{
	if (g12BE == NULL) {
		g12BE = new RExArray(sizeof(Ref32));
	}

	for (ArrayIndex unitNo = 0, numOfExports = inTable.fAccessor->arrayLength(inTable.fRef); unitNo < numOfExports; ++unitNo) {
		PartRef unitDecl;
		unitDecl.fAccessor = inTable.fAccessor;
		unitDecl.fRef = inTable.fAccessor->getArraySlot(inTable.fRef, unitNo);

		// we want to add an ExportUnit to the g12B6 array
		ExportUnit unit;

		PartRef nameRef;
		nameRef.fAccessor = inTable.fAccessor;
		nameRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "name");
		const char * name = nameRef.fAccessor->symbolName(nameRef.fRef);
		unit.fName = (char *)malloc(strlen(name) + 1);
		strcpy(unit.fName, name);

		PartRef versionRef;
		versionRef.fAccessor = unitDecl.fAccessor;
		versionRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "major");	//-1384
		unit.fMajorVersion = RVALUE(versionRef.fRef);

		versionRef.fAccessor = unitDecl.fAccessor;
		versionRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "minor");	//-137E
		unit.fMinorVersion = RVALUE(versionRef.fRef);

		PartRef objRef;
		objRef.fAccessor = unitDecl.fAccessor;
		objRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "objects");	//-1378
		unit.fObjects = objRef;

		// we want to add the members of the unit declaration to the g12BE array
		ArrayIndex numOfObjects = objRef.fAccessor->arrayLength(objRef.fRef);
		unit.fCount = g12BE->count();
		g12BE->fChunk.append(NULL, numOfObjects * sizeof(Ref32));
		Ref32 * exportedObject = (Ref32 *)g12BE->at(unit.fCount);
		for (ArrayIndex i = 0; i < numOfObjects; ++i) {
			PartRef obj;
			obj.fAccessor = unit.fObjects.fAccessor;
			obj.fRef = unit.fObjects.fAccessor->getArraySlot(unit.fObjects.fRef, i);
			exportedObject[i] = obj.fRef + inPkgOffset;
		}

		// add the ExportUnit
		g12B6->fChunk.append(&unit, sizeof(unit));
	}
}


/* -----------------------------------------------------------------------------
	Renumber imported UnitReferences.
	Args:		inPart		access to the package part
				inArg2
				inArg3
				inArg4
				inArg5
	Return:	--
----------------------------------------------------------------------------- */

void
RenumberImports(CFramesPartAccessor & inPart, Ref32 * inArg2, PartRef inArg3, PendingImport ** inArg4, bool inArg5)
{
	if (inArg4 == NULL) {
		inArg4 = new PendingImport*;	// linked list?
		*inArg4 = g12FA;
	}
	CRenumberImportsScanner scanner(inArg2, inArg4, inArg5);
	inPart.scanRefs(scanner, inArg3.fRef);
}


/* -----------------------------------------------------------------------------
	Process imported UnitReferences.
	Args:		inPart		access to the package part
				inTable		the _ImportTable array of unit declaration frames
	Return:	--
----------------------------------------------------------------------------- */

void
ProcessImports(CFramesPartAccessor & inPart, PartRef inTable)
{
	ArrayIndex numOfImports = inTable.fAccessor->arrayLength(inTable.fRef);	// spm10
	Ref32 * spm0C = new Ref32[numOfImports];
	PendingImport ** spm08 = new PendingImport*[numOfImports];
	bool isImportPending = false;	//spm04
	for (ArrayIndex unitNo = 0; unitNo < numOfImports; ++unitNo) {	//d5
		PartRef unitDecl;	//spm70
		unitDecl.fAccessor = inTable.fAccessor;
		unitDecl.fRef = inTable.fAccessor->getArraySlot(inTable.fRef, unitNo);

		PartRef nameRef;	//spm64
		nameRef.fAccessor = inTable.fAccessor;
		nameRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "name");
		const char * name = nameRef.fAccessor->symbolName(nameRef.fRef);

		PartRef versionRef;	//spm5C
		versionRef.fAccessor = unitDecl.fAccessor;
		versionRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "major");	//-136A
		int majorVersion = (int)RVALUE(versionRef.fRef);	//d4

		versionRef.fAccessor = unitDecl.fAccessor;
		versionRef.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "minor");	//-1364
		int minorVersion = (int)RVALUE(versionRef.fRef);	//spm54

		// iterate over exports and try to fulfill this import
		ExportUnit * exportUnit = NULL;	//spm48
		int bestMinorVersion = -1;	//d6
		for (ArrayIndex i = 0, numOfExports = g12B6->count(); i < numOfExports; ++i) {	//d7 spm44
//+023A
//			spm78 = g12B6;
			ExportUnit * exported = (ExportUnit *)g12B6->at(i);	//spm7C
			if (symcmp(exported->fName, name) == 0
			&&  exported->fMajorVersion == majorVersion
			&&  exported->fMinorVersion > bestMinorVersion) {
				// found a candidate
				bestMinorVersion = exported->fMinorVersion;
				exportUnit = exported;
			}
		}
		if (bestMinorVersion >= minorVersion) {
			// import is fulfilled
			spm0C[unitNo] = exportUnit->fCount;
		} else {
			// import is still pending
			PendingImport * spm8E = new PendingImport;
			spm8E->f00 = 0;
			if (g12C2 == NULL) {
				g12C2 = new CChunk;
				g12C2->append(NULL, 4);
			}

			ImportUnit spm8A;
			spm8A.majorVersion = majorVersion;
			spm8A.minorVersion = minorVersion;

			spm8E->f08 = g12C2->dataSize();
			g12C2->append(&spm8A, sizeof(spm8A));
			g12C2->append(&name, strlen(name)+1);
			g12C2->roundUp(4);

			spm0C[unitNo] = -1;
			spm08[unitNo] = spm8E;
			isImportPending = true;
		}
	}

//+0398
	RenumberImports(inPart, spm0C, inTable, spm08, false);

	size_t offset = 0;	//d6
	if (isImportPending) {
		for (ArrayIndex i = 0; i < numOfImports; ++i) {
			if (spm0C[i] == -1) {
				PendingImport * a4 = spm08[i];
				ImportUnit * a3 = (ImportUnit *)(g12C2->data() + a4->f08);
				a3->f08 = offset;
				a3->f0C = a4->f00;
				a4->f00 = offset;
				offset += a3->f0C;
			}
		}
		*(int *)g12C2->data() = offset;	// now the size
		RenumberImports(inPart, spm0C, inTable, spm08, true);
		AddBlock(kFrameImportTableTag, g12C2);
	}

//+0476
	// delete working arrays
	delete[] spm0C;
	for (ArrayIndex i = 0; i < numOfImports; ++i) {
		delete spm08[i];
	}
	delete[] spm08;
}


/* -----------------------------------------------------------------------------
	Redirect exported UnitReferences.
	See “Q&A Newton 2.x”

	A part’s _ExportTable slot contains an array of UnitReference frames, eg:
	 _ExportTable: [{name: '|Inet Protos:NIE|, 
                 major: 1, 
                 minor: 0, 
                 objects: [{DoEvent: <nativefunction, 2 args, #0287BC4D>, ...},...] }
					  //possibly more exported frames
					  ]

	DeclareUnit(unitName, majorVersion, minorVersion, memberIndexes)
		unitName - symbol - name of the unit
		majorVersion - integer - major version number of the unit
		minorVersion - integer - minor version number of the unit
		memberIndexes - frame - unit member name/index pairs (slot/value) return value - unspecified

	Args:		inPart		accessor for part data
				inTable		the _ExportTable array of unit declaration frames
	Return:	--
----------------------------------------------------------------------------- */

void
RedirectExports(CFramesPartAccessor & inPart, PartRef inTable)
{
	ArrayIndex count = g12B6->count();
	if (count != 0) {
		bool isRedirectionReqd = false;
		Ref32 table = (g0CD8 * 2 + 2) << kMPTableShift;	// not really a Ref32 but will make one
		for (ArrayIndex unitIndex = 0, unitCount = inTable.fAccessor->arrayLength(inTable.fRef); unitIndex < unitCount; ++unitIndex) {
			PartRef unitDecl;	//spm30
			unitDecl.fAccessor = inTable.fAccessor;
			unitDecl.fRef = inTable.fAccessor->getArraySlot(inTable.fRef, unitIndex);

			PartRef unitMembers;	//spm38
			unitMembers.fAccessor = unitDecl.fAccessor;
			unitMembers.fRef = unitDecl.fAccessor->getFrameSlot(unitDecl.fRef, "objects");

			// iterate over existing exports
			for (ArrayIndex i = 0; i < count; ++i) {
				ExportUnit * exported = (ExportUnit *)g12B6->at(i);	//spm40
				if (exported->fObjects == unitMembers) {
					if (!isRedirectionReqd) {
						inPart.beginRedirectionSetup();
						isRedirectionReqd = true;
					}
					for (ArrayIndex memberIndex = 0, memberCount = unitMembers.fAccessor->arrayLength(unitMembers.fRef); memberIndex < memberCount; ++memberIndex) {
						Ref32 destRef = MAKEMAGICPTR(exported->fCount + table + memberIndex);

						PartRef member;
						member.fAccessor = unitMembers.fAccessor;
						member.fRef = unitMembers.fAccessor->getArraySlot(unitMembers.fRef, memberIndex);
						inPart.setRedirection(member.fRef, destRef);
					}
				}
			}
		}
		if (isRedirectionReqd) {
			inPart.doRedirection();
		}
	}
}


#pragma mark -
/* -----------------------------------------------------------------------------
	C P a c k a g e A c c e s s o r
	Access to the package directory and part directory entries.
----------------------------------------------------------------------------- */

CPackageAccessor::CPackageAccessor(CChunk & inData, long inOffset)
	: fChunk(inData), fOffset(inOffset), fPkgDir(NULL)
{ }

CPackageAccessor::~CPackageAccessor()
{
	if (fPkgDir) {
		free(fPkgDir);
	}
}


PackageDirectory *
CPackageAccessor::directory(void)
{
#if defined(hasByteSwapping)
	if (fPkgDir == NULL) {
		PackageDirectory * pkgDir = (PackageDirectory *)(fChunk.data() + fOffset);

		int pkgDirSize = BYTE_SWAP_LONG(pkgDir->directorySize);
		fPkgDir = (PackageDirectory *)malloc(pkgDirSize);

		memcpy(fPkgDir->signature, pkgDir->signature, sizeof(fPkgDir->signature));
		fPkgDir->id = BYTE_SWAP_LONG(pkgDir->id);
		fPkgDir->flags = BYTE_SWAP_LONG(pkgDir->flags);
		fPkgDir->version = BYTE_SWAP_LONG(pkgDir->version);
		fPkgDir->copyright.offset = BYTE_SWAP_SHORT(pkgDir->copyright.offset);
		fPkgDir->copyright.length = BYTE_SWAP_SHORT(pkgDir->copyright.length);
		fPkgDir->name.offset = BYTE_SWAP_SHORT(pkgDir->name.offset);
		fPkgDir->name.length = BYTE_SWAP_SHORT(pkgDir->name.length);
		fPkgDir->size = BYTE_SWAP_LONG(pkgDir->size);
		fPkgDir->creationDate = BYTE_SWAP_LONG(pkgDir->creationDate);
		fPkgDir->modifyDate = BYTE_SWAP_LONG(pkgDir->modifyDate);
		fPkgDir->directorySize = pkgDirSize;
		fPkgDir->numParts = BYTE_SWAP_LONG(pkgDir->numParts);

		PartEntry * dirEntry = fPkgDir->parts, * pe = pkgDir->parts;
		for (int i = 0; i < fPkgDir->numParts; ++i, ++pe)
		{
			dirEntry->offset = BYTE_SWAP_LONG(pe->offset);
			dirEntry->size = BYTE_SWAP_LONG(pe->size);
			dirEntry->size2 = pe->size;
			dirEntry->type = BYTE_SWAP_LONG(pe->type);
			dirEntry->flags = BYTE_SWAP_LONG(pe->flags);
			dirEntry->info.offset = BYTE_SWAP_SHORT(pe->info.offset);
			dirEntry->info.length = BYTE_SWAP_SHORT(pe->info.length);
			dirEntry->compressor.offset = BYTE_SWAP_SHORT(pe->compressor.offset);
			dirEntry->compressor.length = BYTE_SWAP_SHORT(pe->compressor.length);
		}
	}
	return fPkgDir;
#else
	return (PackageDirectory *)(fChunk.data() + fOffset);
#endif
}

bool
CPackageAccessor::isPackage()
{
	PackageDirectory * pkgDir = directory();
	return strncmp(pkgDir->signature, "package0", 8) == 0
		 || strncmp(pkgDir->signature, "package1", 8) == 0;
}

size_t
CPackageAccessor::size()
{
	return directory()->size;
}

ArrayIndex
CPackageAccessor::numParts()
{
	return directory()->numParts;
}

PartEntry *
CPackageAccessor::part(ArrayIndex index)
{
	return directory()->parts + index;
}

Ptr
CPackageAccessor::unsafePartDataPtr(ArrayIndex index)
{
	return fChunk.data() + fOffset + partOffset(index);
}

long
CPackageAccessor::partOffset(ArrayIndex index)
{
	return directory()->directorySize + part(index)->offset;
}

size_t
CPackageAccessor::partSize(ArrayIndex index)
{
	return part(index)->size;
}

ULong
CPackageAccessor::partFlags(ArrayIndex index)
{
	return part(index)->flags;
}


#pragma mark -
/* -----------------------------------------------------------------------------
	C F r a m e s P a r t A c c e s s o r
	Access to 32-bit refs in a NewtonScript frame part.
	NOTE: Refs for the Newton platform are always big-endian!
	=> Refs passed as args are always platform-endian but objects laid out in
	memory are always big-endian.
----------------------------------------------------------------------------- */

CFramesPartAccessor::CFramesPartAccessor(Ptr inPartData, size_t inPartSize, long inRootOffset)
{
	fRootObj = (ArrayObject32 *)inPartData;
	fRootSize = inPartSize;
	fPartOffset = inRootOffset;
	fIsRedirectionSetup = false;
	// first part first object has alignment info
	int32_t gcStuff = CANONICAL_LONG(fRootObj->gc.stuff);
	fAlignment = (gcStuff & k4ByteAlignmentFlag) != 0 ? 4 : 8;
}


ObjHeader32 *
CFramesPartAccessor::objectPtr(Ref32 inRef)	// ref is package-relative?
{
	if (!ISPTR(inRef)) {
		FatalError("Internal error: #%X not a pointer", inRef);
	}
	return (ObjHeader32 *)PTR((Ptr)fRootObj + inRef - fPartOffset);
}


SymbolObject32 *
CFramesPartAccessor::symHeader(Ref32 inRef)
{
	SymbolObject32 * obj = (SymbolObject32 *)objectPtr(inRef);
	if ((obj->flags & kObjSlotted) != 0 || CANONICAL_LONG(obj->objClass) != kSymbolClass) {
		FatalError("Internal error: #%X not a symbol", inRef);
	}
	return obj;
}


const char *
CFramesPartAccessor::symbolName(Ref32 inRef)
{
	return symHeader(inRef)->name;
}


bool
CFramesPartAccessor::symTest(Ref32 inRef, const char * inName)
{
	return symcmp(symHeader(inRef)->name, inName) == 0;
}


ArrayIndex
CFramesPartAccessor::arrayLength(Ref32 inRef)
{
	ArrayObject32 * obj = (ArrayObject32 *)objectPtr(inRef);
	return (CANONICAL_SIZE(obj->size) - sizeof(ArrayObject32)) / sizeof(Ref32);
}


ArrayIndex
CFramesPartAccessor::findOffset1(Ref32 inRef, const char * inSlot, bool * outExists)
{
	FrameMapObject32 * map = (FrameMapObject32 *)objectPtr(inRef);
	ArrayIndex i = 0;
	Ref32 supermap = CANONICAL_LONG(map->supermap);
	if (NOTNIL(supermap)) {
		i = findOffset1(supermap, inSlot, outExists);
		if (*outExists) {
			return i;
		}
	}
	Ref32 * tag = map->slot;
	for (ArrayIndex count = (CANONICAL_SIZE(map->size) - sizeof(FrameMapObject32)) / sizeof(Ref32); i < count; ++i) {
		if (symTest(CANONICAL_LONG(*tag), inSlot)) {
			*outExists = true;
			return i;
		}
	}
	*outExists = false;
	return kIndexNotFound;
}


ArrayIndex
CFramesPartAccessor::findOffset(FrameObject32 * inObj, const char * inSlot)
{
	bool exists;
	ArrayIndex index = findOffset1(CANONICAL_LONG(inObj->map), inSlot, &exists);
	if (!exists) {
		return kIndexNotFound;
	}
	return index;
}


Ref32
CFramesPartAccessor::getFrameSlot(Ref32 inRef, const char * inSlot, bool * outExists)
{
	FrameObject32 * obj = (FrameObject32 *)objectPtr(inRef);
	if (!ISFRAME(obj)) {
		FatalError("Internal error: #%X not a frame", inRef);
	}
	ArrayIndex index = findOffset(obj, inSlot);
	if (index == kIndexNotFound) {
		*outExists = false;
		return NILREF;
	}
	*outExists = true;
	return CANONICAL_LONG(obj->slot[index]);
}

Ref32
CFramesPartAccessor::getArraySlot(Ref32 inRef, ArrayIndex index)
{
	ArrayObject32 * obj = (ArrayObject32 *)objectPtr(inRef);
	if (!ISARRAY(obj)) {
		FatalError("Internal error: #%X not an array", inRef);
	}
	if (/*index < 0 ||*/ index >= arrayLength(inRef)) {
		FatalError("Internal error: index %d out of bounds", index);
	}
	return CANONICAL_LONG(obj->slot[index]);
}


void
CFramesPartAccessor::relocate(long inOffset)
{
	CRelocateScanner scanner(inOffset);
	scanRefs(scanner, NILREF);
}


void
CFramesPartAccessor::scanRefs(RefScanner & inScanner, Ref32 inRef)
{
	Ref32 * refPtr;
	ObjHeader32 * targetObj = NOTNIL(inRef) ? objectPtr(inRef) : NULL;
	ArrayObject32 * obj = fRootObj;
	ArrayObject32 * objLimit = (ArrayObject32 *)((Ptr)fRootObj + fRootSize);
	for ( ; obj < objLimit; obj = (ArrayObject32 *)((Ptr)obj + ALIGN(CANONICAL_SIZE(obj->size), fAlignment))) {
		if ((ObjHeader32 *)obj != targetObj) {
			// scan the object class
			inScanner.scanRef(&obj->objClass);
			if (ISSLOTTED(obj)) {
				// scan the frame/array elements
				ArrayIndex count = ARRAY32LENGTH(obj);
				if ((Ptr)&obj->slot[count] > (Ptr)objLimit) {
					FatalError("package file corrupted");	// object too big
				}
				refPtr = &obj->slot[0];
				for (ArrayIndex i = 0; i < count; ++i, ++refPtr) {
					inScanner.scanRef(refPtr);
				}
			}
		}
		if (ALIGN(obj->size, fAlignment) == 0) {
			FatalError("package file corrupted");	// can’t have zero-size objects
		}
	}
}


void
CFramesPartAccessor::beginRedirectionSetup(void)
{
	if (fIsRedirectionSetup) {
		FatalError("Internal error: beginRedirectionSetup twice");
	}
	fIsRedirectionSetup = true;
}


void
CFramesPartAccessor::setRedirection(Ref32 inFromRef, Ref32 inToRef)
{
	if (!fIsRedirectionSetup) {
		FatalError("Internal error: beginRedirectionSetup not called");
	}
	ObjHeader32 * obj = objectPtr(inFromRef);
	if (obj == (ObjHeader32 *)fRootObj) {
		FatalError("Internal error: redirecting part data array");
	}
	if (obj->gc.stuff == 0xFFFFFFFF) {
		FatalError("Internal error: redirecting a safe object");
	}
	obj->gc.destRef = inToRef;
}


void
CFramesPartAccessor::doRedirection(void)
{
	if (!fIsRedirectionSetup) {
		FatalError("Internal error: beginRedirectionSetup not called");
	}
	fIsRedirectionSetup = false;

	Ref32 * refPtr;
	ObjHeader32 * targetObj;
	ArrayObject32 * obj = fRootObj;
	ArrayObject32 * objLimit = (ArrayObject32 *)((Ptr)fRootObj + fRootSize);
	for ( ; obj < objLimit; obj = (ArrayObject32 *)((Ptr)obj + ALIGN(obj->size, fAlignment))) {
		if (obj->gc.stuff != 0xFFFFFFFF) {
			// not a special object
			// redirect the class
			refPtr = &obj->objClass;
			if (ISPTR(*refPtr)) {
				targetObj = objectPtr(*refPtr);
				if (targetObj->gc.destRef != 0 && targetObj->gc.destRef != 0xFFFFFFFF) {
					*refPtr = targetObj->gc.destRef;
				}
			}
			if (ISARRAY(obj)) {
				// redirect all frame/array elements
				ArrayIndex count = ARRAY32LENGTH(obj);
				if ((Ptr)&obj->slot[count] > (Ptr)objLimit) {
					FatalError("package file corrupted");	// object too big
				}
				refPtr = &obj->slot[0];
				for (ArrayIndex i = 0; i < count; ++i, ++refPtr) {
					if (ISPTR(*refPtr)) {
						targetObj = objectPtr(*refPtr);
						if (targetObj->gc.destRef != 0 && targetObj->gc.destRef != 0xFFFFFFFF) {
							*refPtr = targetObj->gc.destRef;
						}
					}
				}
			}
		}
		if (ALIGN(obj->size, fAlignment) == 0) {
			FatalError("package file corrupted");	// can’t have zero-size objects
		}
	}

	// clean up -- zero out gc.destRef for all objects after the root array
	obj = (ArrayObject32 *)((Ptr)fRootObj + ALIGN(obj->size, fAlignment));
	while (obj < objLimit) {
		if (obj->gc.destRef != 0) {
			obj->gc.destRef = 0;
		}
		obj = (ArrayObject32 *)((Ptr)obj + ALIGN(obj->size, fAlignment));
	}
}



#pragma mark -
/* -----------------------------------------------------------------------------
	P a r t R e f
	The Ref here is already platform-endian.
----------------------------------------------------------------------------- */

bool
PartRef::operator==(PartRef & _p)
{
	if (ISPTR(fRef) && ISPTR(_p.fRef)) {
		return fAccessor->objectPtr(fRef) == _p.fAccessor->objectPtr(_p.fRef);
	}
	return fRef == _p.fRef;
}

