/*----------------------------------------------------------------------	Magic pointers 800 - 872----------------------------------------------------------------------*/mp8xx := [/*----------------------------------------------------------------------	@800*/	{		bits: MakeBinaryFromHex("000000000008008200820127009301513FFFC0FFFF0000007FFFE1FFFF800000E000738001C00000C000330000C00000C0003303C0C00000DDBBB30660C00000DDBBB300E0C00000C000330360C00000DDDBB30660C00000DDDBB36666C00000C0003363F6C00000C7FE336006C00000C7FE336FF6C00000C000330000C00000E000738001C000007FFFE1FFFF8000003FFFC0FFFF000000", 'bits),		bounds: SetBounds(0, 0, 42, 17),		width: 2,		height: 1,		outerFrame: 0,		cellFrame: 0	},/*----------------------------------------------------------------------	@801*/	{		bits: MakeBinaryFromHex("00000000000C010B010B0077011C00B93FFFFFFFFFFFFFFF000000007FFFFFFFFFFFFFFF80000000E000000000000001C0000000C000000000000000C0000000C000000000000000C0000000C7E0006000000000C0000000C180006018600000C0000000C18D6C673EF9CD38C0000000C18F6C6D98636F60C0000000C18C6C6F9863EC78C0000000C18C386C18630C18C0000000C18C18678E39EC70C0000000C000300000000000C0000000C000600000000000C0000000E000000000000001C00000007FFFFFFFFFFFFFFF800000003FFFFFFFFFFFFFFF00000000", 'bits),		bounds: SetBounds(0, 0, 66, 17)	},/*----------------------------------------------------------------------	@802			full caret popup*/	{		bits: MakeBinaryFromHex("0000000000080042004200F900E50124AAAAAAAAAAA000005555555555400000800000000020000040000400004000008000000000200000400084000040000080018000002000004003840000400000800380180C20000040C384180C40000081C38079CC200000438384DB6C40000087FF80DBEC2000004FFF84DB0C40000087FF0079EC200000438004000040000081C000000020000040C00400004000008000000000200000400004000040000080000000002000005555555555400000AAAAAAAAAAA0000040000400004000008000000000200000400004000040000080000000002000004000040000400000800000000020000040000400004000008000000000200000400004000040000080000000002000004000040000400000803000018020000040780403C040000080780003C020000040300401C04000008000000180200000400004030040000080000000002000005555555555400000800000000020000040000401C040000080380007F0200000407C040FF8400000807C000E38200000407C040C38400000807C000038200000407C04007040000080380000E020000040380401E040000080380001C020000040380401C04000008010000080200000400004000040000080380001C0200000407C0403E040000080380001C0200000400004000040000080000000002000005555555555400000800000000020000040000400004000008000000000200000400004000040000080000000002000004018040180400000803C0003C0200000403C0403C04000008018000180200000400004000040000080000000002000004018040180400000803C0003C0200000403C0403C040000080180001C020000040000401804000008000000300200000400004000040000080000000002000005555555555400000800000000020000040000400004000008018001830200000403C043C78400000803C003C7820000040180418304000008018001830200000401804183040000080000000002000004000040000400000800000000020000040000400004000008000000000200000400004000040000080000000002000004000040000400000800000000020000040000400004000008000000000200000555555555540000080000000002000004000040000400000801000008020000040300400C04000008060000060200000406004006040000080E000007020000040E004007040000080E000007020000040E004007040000080E000007020000040E004007040000080E00000702000004060040060400000806000006020000040300400C04000008010000080200000400004000040000080000000002000005555555555400000800000000020000040000400004000008000000000200000400E040000400000800E000000200000401E040000400000801C000000200000403C0400004000008038001FF02000004078041FF04000008070001FF020000040F004000040000080E000000020000041E004000040000081C000000020000041C00400004000008000000000200000400004000040000080000000002000005555555555400000800000000020000040000400004000008000000000200000400004000040000080000000002000004000040000400000800000066020000040780407E040000080FC0003C020000040FC040FF040000080FC000FF020000040FC0403C040000080780007E02000004000040660400000800000000020000040000400004000008000000000200000400004000040000080000000002000005555555555400000AAAAAAAAAAA00000", 'bits),		bounds: SetBounds(0, 0, 43, 163),		width: 2,		height: 8,		words: [	"\n", "\u0008",					".",  ",",					"!",  "?",					":",  ";",					"'",  "\"",					"(",  ")",					"/",  "-",					"\u2022", "*" ]	},/*----------------------------------------------------------------------	@803			minimal caret popup*/	{		bits: MakeBinaryFromHex("00000000000800C300C3023800D40263AAAAAAAAAAA00000555555555540000080000000002000004000000000400000800000000020000040000000004000008000000000200000400000000040000080000000002000004000000000400000800000000020000040000000004000008000000000200000400000000040000080000000002000005555555555400000AAAAAAAAAAA00000", 'bits),		bounds: SetBounds(0, 0, 43, 17),		width: 1,		height: 1,		words: [ " " ]	},/*----------------------------------------------------------------------	@804  protoDragNGo*/	{	_proto: protoDragger,		viewChildren: [ viewChildren:  {	_proto: protoClosebox } ],		debug: 182001	},/*----------------------------------------------------------------------	@805			IA action proto.*/	{		IsNoise: func(inWord)			begin			local wordLen := StrLen(inWord);			if wordLen >= 2 and wordLen <= 4 then				FindStringInArray(@270, inWord)	// stopWordList			end,		FilterNoise: func(arg1, arg2)			begin			foreach local1, local2 in arg1 do				if FindStringInArray(arg2, local2) then					arg1 := FilterStrings(local2, arg1);			if Length(arg1) > 0 then				arg1			end,		FilterAction: func(arg1, arg2, arg3, arg4)			begin			foreach local1, local2 in arg1 do				if IsA(local2, arg4) then					arg3 := FilterStrings(arg2[local1], arg3);			if Length(arg3) > 0 then				arg3			end,		RemoveFromString: func(ioStr, inWord, arg3)			begin			local wordLen := StrLen(inWord);			local wordOffset := StrPos(ioStr, inWord, 0);			if wordOffset > 0 then				begin				local prevWord := :PrevStr(ioStr, wordOffset);				if prevWord and :IsNoise(prevWord) then					begin					local prevWordLen := StrLen(prevWord) + 1;					wordOffset := wordOffset - prevWordLen;					wordLen := wordLen + prevWordLen					end				end;			// remove character following too -- we can assume it’s whitespace			if wordOffset + wordLen < StrLen(ioStr) then				wordLen := wordLen + 1;			// munge it out			StrMunger(ioStr, wordOffset, wordLen, nil, 0, 0);			ioStr			end,		PrevStr: func(inStr, inOffset)			begin			inOffset := inOffset - 2;			local str;			local local2 := PrevSubStr(inStr, inOffset);			if local2 < inOffset then				str := Substr(inStr, local2, inOffset + 1 - local2);			str			end,		GetTime: func(arg1, ioParsedInfo)			begin			if arg1 then				ioParsedInfo.givenTime := :GetUserTime(arg1, ioParsedInfo)			else if ioParsedInfo.usualTime then				ioParsedInfo.givenTime := ioParsedInfo.usualTime;			if ioParsedInfo.givenTime then				:GetActionTime(ioParsedInfo)			else				ioParsedInfo.currentTime			end,		GetUserTime: func(arg1, arg2)			begin			local local2, local3;			local count := Length(arg1);			local local5 := Array(count, nil);			for local1 := 0 to count - 1 do				begin				local3 := arg1[local1][0];				local local8 := GetSlot(local3, 'value);				local5[local1] := local8;				if HasSlot(local3, 'time) then					begin					arg2.hasTime := true;					if not StrEqual(StringFilter(local8, "am", 'passAll), "am")					and not StrEqual(StringFilter(local8, "pm", 'passAll), "pm") then						begin						local2 := Date(StringToTime(local8));						local2 := local2.hour						end					end;				if HasSlot(local3, 'date) then					arg2.hasDate := true				end;			if arg2.hasTime = nil			and arg2.usualTime <> nil then				AddArraySlot(local5, arg2.usualValue);			local local9 := GlueStrings(local5);			if arg2.hasDate then				begin				local local10 := StringToDateFrame(local9);				arg2.dayOfWeek := local10.dayOfWeek and not local10.Date and not local10.month				end;			local3 := StringToDate(local9);			if local2 <> nil then				(if local2 >= 1 and local2 < 7 then				(local3 := local3 + 720));			local3			end,		GetActionTime: func(arg1)			begin			local local1 := arg1.givenTime;			local local2 := arg1.usualTime;			if arg1.givenTime then				begin				local local3 := :DelayTime(arg1);				if local3 > 0 or local3 < 0 then					begin					if local3 > 0 then						local1 := local1 + local3					else if arg1.hasDate then						begin						local dateFrame := Date(local1);						dateFrame.year := dateFrame.year + 1;						local1 := TotalMinutes(dateFrame)						end					else						local1 := arg1.givenTime + 1440					end				end			else				local1 := arg1.currentTime;			local1			end,		DelayTime: func(arg1)			begin			local local1 := arg1.givenTime;			local local2 := arg1.currentTime;			if local1 >= local2 then				return 0;			if arg1.hasTime = nil			and arg1.usualTime <> nil then				begin				if local1 + 30 > local2 then					return 30;				if local1 + 60 > local2 then					return 60				end;			if arg1.dayOfWeek then				return 10080;			return -1			end,		SetDisplayName: func(ioNameRef, arg2, arg3)			begin			local local2;			local local1 := ClassOf(arg2);			if local1 = 'custom then				begin				ioNameRef.name := {last: Clone(arg3.(arg2.path))};				local2 := true				end			else if local1 = 'affiliate then				begin				local2 := true;				local theName := arg3.names[arg2.path];				if ObjEntryClass(ioNameRef) = 'company then					ioNameRef.company := Clone(GetRoot():bcFullName(theName))				else if ObjEntryClass(ioNameRef) = 'person then					ioNameRef.name := theName				end;			local2			end,		FillPhoneSlip: func(arg1, arg2)			begin			local local1, local2, local3, local4, local5, local6, local8, local9, local10, local11, local14, local15;			if arg1.candidates <> nil then				begin				local2 := HasSlot(arg1, 'dialdirect);				local3 := true;				local4 := 0;				foreach local5, local6 in arg1.candidates do					begin					local8 := ResolveEntryAlias(local6.alias);					local9 := IsSubclass(ObjEntryClass(local8), 'group);					if not local9 then						(local10 := :GetSelectedPhones(arg1, local8));					if local9 or local10 or local2 then						begin						local1 := GetDataDefs(arg2):MakeNameRef(local8, arg2);						if :SetDisplayName(local1, local6, local8) then							(local1._alias := nil);						if not local9 then							dsSetCandidatePhone(arg1, local1, local10);						if local3 <> nil then							begin							arg1.toRef := [local1];							local3 := nil							end						else							begin							if not arg1.alternatives then								(arg1.alternatives := []);							ArrayInsert(arg1.alternatives, local1, local4);							local4 := local4 + 1							end;						local11 := 0;						if local10 then							(local11 := Length(local10));						if local11 > 1 then							for local5 := 1 to local11 - 1 do							begin							local14 := local10[local5];							local15 := Clone(local1);							local15.name := Clone(local15.name);							local15.phone := local14;							if not arg1.alternatives then								(arg1.alternatives := []);							ArrayInsert(arg1.alternatives, local15, local4);							local4 := local4 + 1							end						end					end				end			else (if arg1.rawtext <> nil or arg1.dialdirect <> nil then				begin				local1 := GetDataDefs(arg2):MakeNameRef({name: {last: arg1.rawtext}}, arg2);				dsSetCandidatePhone(arg1, local1, nil);				arg1.toRef := [local1]			end)			end,		RemoveAllGroups: func(arg1)			begin			local local1 := 0;			foreach local2, local3 in arg1 do				if ObjEntryClass(local3.alias) <> 'group then				begin				if local1 <> local2 then					arg1[local1] := arg1[local2];				local1 := local1 + 1				end;			SetLength(arg1, local1)			end,		RemoveGroupsExcept: func(arg1, arg2)			begin			local local1 := 0;			foreach local4, local5 in arg1 do				begin				local local3 := ResolveEntryAlias(local5.alias);				local local2 := ObjEntryClass(local3);				if not IsSubclass(local2, 'group) or IsInstance(local3.members, arg2) then					begin					if local1 <> local4 then						arg1[local1] := arg1[local4];					local1 := local1 + 1					end				end;			SetLength(arg1, local1)			end,		GetTransportTags: func(inTag)			begin			local txport := GetGroupTransport(taskType);			if txport then				begin				// convert symbol to frame				txport := GetRoot().(txport);				if txport and txport.(inTag) then					txport.(inTag)	// this is the return value				end			end,		GetPreferredSymb: func()			begin			local timeFrame := Date(Time());			local dayOfWeek := timeFrame.dayOfWeek;			local timeOfDay := timeFrame.hour * 60 + timeFrame.minute;			if dayOfWeek > 0 and dayOfWeek < 6					//  Mon..Fri			and timeOfDay >= 540 and timeOfDay <= 1080 then	// 0900..1800				'iaWorkTags			else				'iaHomeTags			end,		GetSelectedPhones: func(arg1, arg2)			begin			local local1, local2, local3, local4, local6;			if HasSlot(arg1, 'phoneTag) then				begin				local2 := GetRoot().cardfile:bcPhoneNumber(arg2, '[ string ]);				if local2 then					begin					local1 := Array(Length(local2), nil);					local3 := 0;					foreach local4 in arg1.phoneTag do						foreach local6 in local2 do						if local6 then						(if local4 = 'phone then						(if ClassOf(local6) = 'phone or ClassOf(local6) = '|string.phone| then						begin						local1[local3] := local6;						local3 := local3 + 1					end)					else (if IsInstance(local6, local4) then						begin						local1[local3] := local6;						local3 := local3 + 1					end));					if local3 > 0 then						SetLength(local1, local3)					else						(local1 := nil)					end				end;			local1			end,		IAGetTargetInfo: func(inApp, arg2, inTxportStr)			begin			local theView := inApp:GetActiveView();			if not theView then				begin				GetRoot():Notify(kNotifyAlert, "Assist", ParamStr("There is nothing to ^0.", [Lower(Clone(inTxportStr))]));				return				end;			local routingInfo := theView:GetTargetInfo('Routing);			local appSym := GetVariable(inApp, 'appSymbol);			if not appSym then				begin				GetRoot():Notify(kNotifyAlert, "Assist", ParamStr("^0 not supported for frontmost window.", [inTxportStr]));				return				end;			if routingInfo.target = nil then				begin				GetRoot():Notify(kNotifyAlert, "Assist", ParamStr("There is nothing to ^0.", [Lower(Clone(inTxportStr))]));				return				end;			local routingFormats := GetAppFormats(appSym);			if routingFormats = nil then				routingFormats := GetRouteFormats(routingInfo.target);			local txports := GetFormatTransports(routingFormats, routingInfo.target);			local local6;			foreach txport in txports do				begin				if GetVariable(txport, 'appSymbol) = arg2 then					begin					local6 := true;					break					end				end;			if not local6 then				begin				GetRoot():Notify(kNotifyAlert, "Assist", ParamStr("^0 not supported for frontmost window.", [inTxportStr]));				return				end;			routingInfo			end	},/*----------------------------------------------------------------------	@806			Extras icon.*/	GetLayout("extrasIcon"),/*----------------------------------------------------------------------	@807*/	{		_proto: @806,		checked: nil,		viewDrawScript: func()			begin			if not shape then				begin				local local1 := target:where();				local local2 := target:size();				local local3 := if labelsFilter = '_all										then ParamStr("^0 ^?1(^1)||", [local1, if target.fentry.labels then																								begin																								local local4 := userConfiguration.userFolders.(target.fentry.labels);																								if local4 then StringFilter(local4, "_", 'rejectBeginning)																								end																							else																								"Unfiled"])										else local1;				local local5 := 2 * hSpacing div 3;				local local3 := StyledStrTruncate(local3, hSpacing - local5, 9216);				shape := [				  if target.fentry.class = 'frozenEntry then						{ font: 10240 }					else if target.notActive then						{ font: 2107392 }					else						{ font: 1058816 },					MakeText(target.fentry.text, 20, 0, hSpacing div 2, 11),					{ font: 9216, justification: 'right },					MakeText(local2, hSpacing div 2, 0, local5 - 8, 11),					{ font: 9216, justification: 'left },					MakeText(if local3 then local3 else "", local5, 0, hSpacing, 11),					OffsetShape(MakeShape(if checked then						{  mask: kCheckBoxMask,							bits: MakeBinaryFromHex("000000000004003400340013004100200008000000300000DB60000000C0000099A00000BBA000000F0000008F2000008620000004000000DB6000000000000000000000", 'bits),							bounds: SetBounds(0, 0, 13, 13)						}						else						{							mask: kCheckBoxMask,							bits: MakeBinaryFromHex("000000000004001900190013002600200000000000000000DB60000000000000802000008020000000000000802000008020000000000000DB6000000000000000000000", 'bits),							bounds: SetBounds(0, 0, 13, 13)						}), 5, 0)				];				SetClass(shape[1].data, 'string);				if IsSoupEntry(target.fentry) then					EntryUndoChanges(target.fentry)				end;			if shape then				:DrawShape(shape, nil)			end,		viewHiliteScript: func(hiliteOn)			begin			if not checked then				:DrawShape(MakeRect(20, 0, hSpacing, vSpacing), kInvertStyleFrame);			true			end,		viewClickScript: func(unit)			begin			InkOff(unit);			local box := :GlobalBox();			local x := GetPoint(finalX, unit) - box.left;			local y := GetPoint(finalY, unit) - box.top;			if shape and HitShape(shape, x, y) then				begin				:?HandleChildClick();				if x < 20 then					begin					Clicker();					:Checkit(not checked)					end				else					begin					:Checkit(nil);					RefreshViews();					if :TrackHilite(unit) then						begin						:Hilite(nil);						:Launch()						end					end;				true				end			end,		Checkit: func(checkOn)			begin			if checked <> checkOn then				begin				checked := checkOn;				shape := nil;				SetValue(self, 'viewFlags, bxor(GetViewFlags(self), vSelected));				:Dirty()				end			end	},/*----------------------------------------------------------------------	@808			Bless Notes.*/	func()	begin	userConfiguration.blessedApp := 'paperroll;	EntryChange(userConfiguration)	end,/*----------------------------------------------------------------------	@809*/	{	_proto: protoFloatNGo,		viewBounds: nil,		viewJustify: vjParentCenterH + vjParentCenterV,		stepChildren: nil,		viewSetupDoneScript: func()			begin			local kidsBox;			local box := :LocalBox();			foreach kid in :ChildViewFrames() do				if kid._proto = prefPanelProto then					kidsBox := kid:LocalBox();			if kidsBox and box.bottom < kidsBox.bottom then				SetValue(self, 'viewBounds, RelBounds(0, 0, box.right, kidsBox.bottom))			end	},/*----------------------------------------------------------------------	@810*/	{	_proto: protoFloater,		viewBounds: nil,		viewJustify: vjParentCenterH + vjParentCenterV,		stepChildren: nil,		viewSetupDoneScript: func()			begin			local kidsBox;			local box := :LocalBox();			foreach kid in :ChildViewFrames() do				if kid._proto = prefPanelProto then					kidsBox := kid:LocalBox();			if kidsBox and box.bottom < kidsBox.bottom then				SetValue(self, 'viewBounds, RelBounds(0, 0, box.right, kidsBox.bottom))			end	},/*----------------------------------------------------------------------	@811			IACancelAlert -- cancel Assist callback.*/	func()	begin	local rootView := GetRoot();	rootView.assistant:Close();	rootView:Notify(kNotifyAlert, "Assist", "The Assistant request was cancelled")	end,/*----------------------------------------------------------------------	@812  newtStationeryPopupButton*/	{	_proto: protoPopupButton,		viewBounds: SetBounds(7, 0, 45, 13),		viewJustify: vjCenterH + vjCenterV + vjSiblingRightH + vjSiblingTopV,		keyButton: nil,		sorter: '|str<|,		types: nil,		symbols: nil,		form: nil,		shortCircuit: true,		statArray: nil,		viewSetupFormScript: func()			begin			inherited:viewSetupFormScript();			if shortCircuit and Length(:SetUpStatArray()) = 1 then				begin				viewBounds.right := viewBounds.right - StrFontWidth("  ", viewFont);				text := SubStr(text, 2, nil);				viewDrawScript := nil				end			end,		viewSetupDoneScript: func()			begin			inherited:?viewSetupDoneScript();			if keyButton then				newtAppBase.(keyButton) := self			end,		viewQuitScript: func()			begin			if keyButton then				RemoveSlot(newtAppBase, keyButton);			inherited:?viewQuitScript()			end,		buttonClickScript: func()			begin			:BuildPopup();			if shortCircuit and Length(popup) = 1 then				:pickActionScript(0)			else				inherited:buttonClickScript()			end,		pickActionScript: func(itemSelected)			begin			local stny := statArray[itemSelected];			inherited:pickActionScript(itemSelected);			:statScript(stny);			popup := nil;			statArray := nil			end,		pickCancelledScript: func()			begin			inherited:pickCancelledScript();			popup := nil;			statArray := nil			end,		statScript: func(stny)			begin			nil			end,		SetUpStatArray: func()			begin			GetDefs(form, symbols, types)			end,		BuildPopup: func()			begin			popup := [];			statArray := :SetUpStatArray();			if sorter then				Sort(statArray, sorter, 'name);			local hasIcon := nil;			foreach stny in statArray do				begin				local name := if stny.name then stny.name													else stny.title;				local item := if stny.icon then begin hasIcon := true; {item: name, icon: stny.icon} end													else {item: name};				AddArraySlot(popup, item)				end;			if hasIcon then				popup[0].indent := 24			end	},/*----------------------------------------------------------------------	@813	newtNewStationeryButton*/	{	_proto: newtStationeryPopupButton,		form: 'dataDef,		keyButton: '_newKeyButton,		text: "  New",		SetUpStatArray: func()			GetDefs(form, [superSymbol], nil),		statScript: func(stny)			:AddEntryFromStationery(stny.symbol),	},/*----------------------------------------------------------------------	@814	newtShowStationeryButton*/	{	_proto: newtStationeryPopupButton,		form: 'viewDef,		keyButton: '_showKeyButton,		text: "  Show",		types: [ 'viewer, 'editor ],		BuildPopup: func()			begin			popup := [];			statArray := :SetUpStatArray();			if sorter then				Sort(statArray, sorter, 'name);			local hasIcon := nil;			foreach stny in statArray do				begin				local name := if stny.name then stny.name													else stny.title;				local item := if stny.icon then begin hasIcon := true; {item: name, icon: stny.icon} end													else {item: name};				if stny.symbol = layout.viewDef then					item.mark := $\uFC0B;				AddArraySlot(popup, item)				end;			if hasIcon then				popup[0].indent := 24			end,		SetUpStatArray: func()			begin			if targetView.targetDataDef then				GetDefs(form, [targetView.targetDataDef.symbol], types)			else				[]			end,		statScript: func(stny)			begin			if newtAppBase.currentLayout = 'overview then				newtAppBase:ShowLayout(nil);			preferredViewDef := stny.symbol;			layout.viewDef := stny.symbol;			layout:Retarget(true)			end	},/*----------------------------------------------------------------------	@815	newtRollShowStationeryButton*/	{	_proto: newtShowStationeryButton,		SetUpStatArray: func()			begin			local allStny := foreach stny in layout.entries collect				if stny then stny.class;			local defs := GetDefs(form, allStny, types);			local dups := [];			foreach def in defs do				if not SetContains(dups, def.symbol) then					SetAdd(dups, def.symbol, true)				else					SetRemove(defs, def);			defs			end,		statScript: func(stny)			begin			if newtAppBase.currentLayout = 'overview then				newtAppBase:ShowLayout(nil);			preferredViewDef := stny.symbol;			layout.viewDef := stny.symbol;			layout:Retarget(true)			end	},/*----------------------------------------------------------------------	@816	newtEntryShowStationeryButton*/	{	_proto: newtShowStationeryButton,		shortCircuit: nil,		BuildPopup: func()			begin			popup := [];			statArray := :SetUpStatArray();			if sorter then				Sort(statArray, sorter, 'name);			local hasIcon := nil;			foreach stny in statArray do				begin				local name := if stny.name then stny.name													else stny.title;				local item := if stny.icon then begin hasIcon := true; {item: name, icon: stny.icon} end													else {item: name};				if targetView and stny.symbol = targetView.viewDef then					item.mark := $\uFC0B;				AddArraySlot(popup, item)				end;			if hasIcon then				popup[0].indent := 24			end,		SetUpStatArray: func()			begin			if targetDataDef then				GetDefs(form, [targetDataDef.symbol], types)			else				[]			end,		statScript: func(stny)			begin			targetView.viewDef := stny.symbol;			targetView:RedoChildren()			end	},/*----------------------------------------------------------------------	@817			Status bar with send button.*/	{},/*----------------------------------------------------------------------	@818			Transport title.*/	{},/*----------------------------------------------------------------------	@819			I/O list.*/	{},/*----------------------------------------------------------------------	@820			I/O Box sorting prefs popup.*/	{},/*----------------------------------------------------------------------	@821			I/O Box routing button.*/	{},/*----------------------------------------------------------------------	@822			I/O Box send/receive button.*/	{},/*----------------------------------------------------------------------	@823			I/O Box overview.*/	{},/*----------------------------------------------------------------------	@824*/	{},/*----------------------------------------------------------------------	@825*/	[		"Australia",		"Belgium",		"Canada",		"Denmark",		"Finland",		"France",		"Germany",		"Hong Kong",		"Ireland",		"Israel",		"Italy",		"Japan",		"Netherlands",		"New Zealand",		"Norway",		"Singapore",		"South Africa",		"Sweden",		"Switzerland",		"United Kingdom",		"USA"	],/*----------------------------------------------------------------------	@826  protoTXView*/	{},/*----------------------------------------------------------------------	@827  protoTXViewFinder*/	{},/*----------------------------------------------------------------------	@828			Poker.*/	{},/*----------------------------------------------------------------------	@829			Playing card.*/	{},/*----------------------------------------------------------------------	@830			Poker.*/	{},/*----------------------------------------------------------------------	@831			Solo.*/	{},/*----------------------------------------------------------------------	@832			Extras drawer.*/	GetLayout("extrasDrawer"),/*----------------------------------------------------------------------	@833			Auto Dock.*/	{	_proto: protoFloater,		viewBounds: SetBounds(0, 0, 192, 75),		viewJustify: vjParentCenterH + vjParentCenterV,		ReOrientToScreen: ROM_DefRotateFunc,		viewChildren: [ viewChildren: 			{	_proto: protoSenderPopup,				viewBounds: SetBounds(8, 20, 208, 46),			},			{	_proto: protoTitle,				title: "Auto Dock",				titleicon: @834			},			{	_proto: protoLargeClosebox			},			{	_proto: protoTextButton,				viewBounds: SetBounds(-66, 0, -7, 0),				viewJustify: vjCenterH + vjCenterV + vjSiblingLeftH + vjSiblingFullV,				text: "Auto Dock",				buttonClickScript: func()					begin					base:Close();					CallFrameBasedRegistryFns(autoDockRegistry, [dockMessage])					end,				viewQuitScript: func()					begin					UnDefGlobalVar('autoDockSlip)					end,			},			{	_proto: protoInfoButton,				viewJustify: vjCenterH + vjCenterV + vjSiblingTopV,				DoInfoPrefs: func()					begin					OpenPrefsTo("Auto Dock")					end			}		]	},/*----------------------------------------------------------------------	@834			Auto Dock icon.*/	{		bits: MakeBinaryFromHex("000000000004010701070091011200A4107F000018FF80000CC18000DEDD8000DEDD80000CC1800019FFC00013FFE0000300600003FFE00001FFC000", 'bits),		bounds: SetBounds(0, 0, 19, 11)	},/*----------------------------------------------------------------------	@835*/	{		viewClass: clView	},/*----------------------------------------------------------------------	@836*/	{		viewClass: 0x4D,		_proto: @835	},/*----------------------------------------------------------------------	@837*/	{		viewClass: 0x51,		_proto: @835	},/*----------------------------------------------------------------------	@838*/	{		viewClass: 0x52,		_proto: @835	},/*----------------------------------------------------------------------	@839			Alert.*/	{		viewClass: clPictureView,		_proto: @835	},/*----------------------------------------------------------------------	@840*/	{		viewClass: 0x4F,		_proto: @835	},/*----------------------------------------------------------------------	@841*/	{		viewClass: 0x5C,		_proto: @835	},/*----------------------------------------------------------------------	@842*/	{		viewClass: 0x50,		_proto: @835	},/*----------------------------------------------------------------------	@843*/	{		viewClass: 0x58,		_proto: @835	},/*----------------------------------------------------------------------	@844*/	{		viewClass: 0x69,		_proto: @835	},/*----------------------------------------------------------------------	@845*/	{		viewClass: 0x5B,		_proto: @835	},/*----------------------------------------------------------------------	@846  ROM_GetSerialNumber*/	{},/*----------------------------------------------------------------------	@847*/	{	_proto: @835,		textFlags: 0xC400,		viewKeyDownScript: func(char, flags)			begin			if (char = kReturnKey or char = kEnterKey)			and BAnd(flags, 0x02000000) = 0 then				begin				SendKeyMessage(self, '_DoDefaultButton);				true				end			end,		_DoDefaultButton: func(inView)			begin			local btn := GetVariable(inView, '_defaultButton);			if btn then				PressButton(btn)			end	},/*----------------------------------------------------------------------	@848*/	{	_proto: protoStatusButton,		viewSetupFormScript: func()			begin			base._defaultButton := self;			inherited:?viewSetupFormScript()			end	},/*----------------------------------------------------------------------	@849	protoSoundFrame*/	{},/*----------------------------------------------------------------------	@850*/	{},/*----------------------------------------------------------------------	@851*/	{},/*----------------------------------------------------------------------	@852*/	{},/*----------------------------------------------------------------------	@853	protoRecorderView*/	{},/*----------------------------------------------------------------------	@854*/	"FrenchDepartments",/*----------------------------------------------------------------------	@855			Font face popup.*/	[		{ item: "Plain",		face: 0 },		{ item: "Bold",		face: 1 },		{ item: "Italic",		face: 2 },		{ item: "Underline", face: 4 },		{ item: "Outline",	face: 8 }	],/*----------------------------------------------------------------------	@856*/	"JapanesePrefectures",/*----------------------------------------------------------------------	@857			Button Bar fixed icon (up|down|overview) proto.*/	{  viewClass: clView,		viewFormat: vfNone,		viewFlags: vVisible + vClickable,		viewJustify: vjParentCenterH + vjParentCenterV,		viewSetupFormScript: func()			begin			local barPosition := displayParams.buttonBarPosition;			local overviewPosition := displayParams.bellyButtonPosition;			local arrowPosition := displayParams.buttonBarControlsPosition;			if overviewPosition = 'outside then				overviewPosition := (if barPosition = 'right or arrowPosition = 'right then 'right else 'left)			else if overviewPosition = 'inside then				overviewPosition := (if barPosition = 'left or arrowPosition = 'left then 'right else 'left);			if overviewPosition = 'right then				begin				local bounds := self._proto.viewBounds;				self.viewBounds := RelBounds(-bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top)				end			end,		viewDrawScript: func()			begin			local isSelected := BAnd(GetViewFlags(self), vSelected) <> 0;			:CopyBits(iconPro.(if isSelected then 'hilited else 'unhilited), 0, 0, 8)			end,		viewHiliteScript: func(doit)			begin			if doit then				begin				if self.justHilited then					RemoveSlot(self, 'justHilited)				else					begin					self.justHilited := true;					:Dirty();					end				end			else				:Dirty();			true			end,		viewClickScript: func(unit)			begin			InkOff(unit);			Clicker();			local box := :GlobalBox();			local initialX := box.left;			local initialY := box.top;			:Hilite(true);			RefreshViews();			local image := iconPro.hilited;			local isPressed := true;			repeat				if isPressed then					:?buttonPressedScript();				local curCoord := GetPoint(finalXY, unit);				local curX := curCoord.x;				local curY := curCoord.y;				local prevX;				local prevY;				if curX <> prevX or curY <> prevY then					begin					local isPressedNow := PtInPicture(curX - initialX, curY - initialY, image) <> nil;					if isPressed <> isPressedNow then						begin						:Hilite(isPressedNow);						RefreshViews();						isPressed := isPressedNow;						image := iconPro.(if isPressedNow then 'hilited else 'unhilited);						end;					prevX := curX;					prevY := curY;				end;			until StrokeDone(unit);			if isPressed then				begin				:Hilite(nil);				:?buttonClickScript()				end;			true		end	},/*----------------------------------------------------------------------	@858			Button Bar icon.*/	{  _proto: @806,		target: nil,		text: nil,		GetIconShapeText: func()			begin			local btnTitle := target.fentry.text;			local linebreak := StrPos(btnTitle, "\n", 0);			if linebreak then				btnTitle := Substr(btnTitle, 0, linebreak);			local btnFont := iconStyle.font;			local btnWidth := min(hSpacing, StrFontWidth(btnTitle, btnFont) + 2);			local btnX := (hSpacing - btnWidth) div 2;			local btnY := iconSpacingV - 11;			MakeText(btnTitle, btnX, btnY, btnX + btnWidth, btnY + FontAscent(btnFont) - 1)			end,		GetIconShapeTextHilited: func()			begin			local btnTitle := :GetIconShapeText();			local btnBox := OffsetRect(ShapeBounds(btnTitle), 0, 1);			[btnTitle, kInvertStyleFrame, MakeShape(btnBox)]			end	},/*----------------------------------------------------------------------	@859			About Newton - Assistant Easter Egg.*/	func()	begin	assistSlip := GetRoot().assistant;	if assistSlip.assistLine.entryLine then		begin		SetValue(assistSlip.assistLine.entryLine, 'text, ParamStr("What about ^0?", ["Newton"]));		RefreshViews();		local IsPrime := func(num)			begin			if num = 1 then				true		// 1 is prime			else if num mod 2 = 0 then				num = 2	// 2 is prime, but any other even number is not			else				begin				for i := 3 to floor(sqrt(num)) by 2 do					if num mod i = 0 then						return;				true				end			end;		// pretty sure start, count, prime, ShowNextPersonFn should be closure locals, and count would be better named index, but this is how the original does it		constant kNumOfPersons := 186;		start := Random(0, kNumOfPersons - 1);		count := 0;		prime := Random(187, 23167);		if prime mod 2 = 0 then			// prime must be odd			prime := prime + 1;		while not call IsPrime with (prime) do			prime := prime + 2;		ShowNextPersonFn := func()			begin			if assistSlip.assistLine.entryLine and count < kNumOfPersons then				begin				SetValue(assistSlip.assistLine.entryLine, 'text, ParamStr("What about ^0?", [[					"#25",					"Adrian", "Alfred", "Amy", "Andreas", "Arash", "Avi",					"Barney", "Bentley", "Beth", "Bill", "Bob", "Breman", "Bruce", "Bubenheim",					"Cami", "Capener", "Chadburn", "Chiavetta", "Chip", "Christina", "Christine", "Christopher", "Conrad", "Corbett", "Crane", "Culbert-san",					"DK", "DanC", "Danielle", "DaveP", "Diane", "Dick", "Dooney", "Dottie", "Duret",					"Ed", "Erfert", "Ernie",					"Fedor", "Flash",					"GMills", "Gabriel", "Garth", "GaryH", "Gen", "Gene", "George", "Gerry", "Gicqu\u00E8", "Giulia", "Glen", "Greg",					"HSJennings3", "Henry", "Huynh",					"ISpammie", "Ilia", "Ingrid", "Ivan",					"J.Tate", "JCanepa", "JOROZE", "JTang", "James", "Jane", "JasonT", "Jeff", "JeffB", "Jen", "Jodie", "JohnA", "Jonathan", "Julie",					"Kelly", "Kondrk",					"Leeski", "Les", "Lieh-Wuu", "Linda", "Lon", "Lucien", "Lundgren", "Lysa",					"Marge", "Margo", "Marie", "Marino", "Matt", "Maurice", "McEntee", "Michelle", "Mike", "MikeSam", "Mimi", "Minnie", "MonkeyMan", "Mori-san", "Mr Mike",					"Nave", "Norberg", "Noroyan",					"Patti", "Patty", "Paul", "Perry", "Pete", "Phantom", "Ping", "Polina",					"Q",					"RSirota", "RWFII", "Raff", "Raphael", "Rea", "Rendon", "Ric", "Rich", "Richard", "Rob", "Robin", "Rubeen", "Ryan",					"Sandy", "Sasha", "Scheuer", "Schoeny", "Schroder", "Scott", "Storey", "Stuart", "Sue", "SusanP.", "Sylvia", "Szeto",					"T.B.Roberts", "Ted", "Tom", "Ton-Yun", "Tony", "Tracy", "Tricia", "Tripp",					"Uncle-Jay",					"Vernon", "Vivian", "Vroman",					"Wayne", "Wendy",					"Yannick", "Yatsuzuka-san", "Yoyodyne", "Yun",					"Zhou",					"beaver",					"cate3", "charlie", "christie", "cmE", "curiousg", "cy",					"dg", "dld", "dotson",					"engber",					"hjcr", "hlee", "h\u00E9\ul\u00E8\une",					"jXopher", "jerk", "jghiii", "jood",					"kenyon", "korey", "krusty",					"larryy",					"mon.cherie",					"rarick", "rkl3", "roger",					"scott",					"temkin", "timbus",					"william", "wyld"				][(start + count * prime) mod kNumOfPersons]]));				count := count + 1;				AddDelayedCall(ShowNextPersonFn, nil, 1000)				end			else				assistSlip:Close()			end;		AddDelayedCall(ShowNextPersonFn, nil, 3000)		end	end,/*----------------------------------------------------------------------	@860			Volume slider.*/	{	_proto: protoSlider,		userConfigSlot: 'soundVolumeDb,		_sound: nil,		hwSavy: true,		hwMode: nil,		hwUpdateFreq: 333,		viewSetupFormScript: func()			begin		/*			local volumeInfo := Gestalt(kGestalt_VolumeInfo);			self.maxValue := volumeInfo[5] + 1;			self.dBincr := volumeInfo[4] / (maxValue - 1);			if hwSavy and volumeInfo[2] then				begin				self.viewFlags := viewFlags - vClickable + vReadOnly;				self.viewValue := :DbToViewValue(GetSystemVolume());				:SetupIdle(hwUpdateFreq)				end			else				self.viewValue := :DbToViewValue(GetUserConfig(userConfigSlot))		*/			self.viewValue := 50			end,		viewSetupDoneScript: func()			begin			if not hwMode then				begin				self.userConfigChangeSym := Intern("VolumeSlider." & viewCObject);				RegUserConfigChange(userConfigChangeSym, func(changeSym) :HandleConfigChange(changeSym))				end			end,		viewIdleScript: func()			begin			local sysVolume := :DbToViewValue(GetSystemVolume());			if sysVolume <> self.viewValue then				SetValue(self, 'viewValue, sysVolume);			return hwUpdateFreq			end,		viewQuitScript: func()			begin			if not hwMode then				UnRegUserConfigChange(userConfigChangeSym)			end,		DbToViewValue: func(dBvolume)			begin			max(0, maxValue - rinttol(dBvolume / dBincr))			end,		ViewValueToDb: func(vwValue)			begin			if vwValue = 0 then				-32768.0			else				(maxValue - vwValue) * dBincr			end,		HandleConfigChange: func(changeSym)			begin			if changeSym = 'outputDevice then				begin				local volumeInfo := Gestalt(kGestalt_VolumeInfo);				SetValue(self, 'maxValue, volumeInfo[5] + 1);				self.dBincr := volumeInfo[4] / (maxValue - 1)				end			else if changeSym = userConfigSlot then				begin				local vwValue := :DbToViewValue(GetUserConfig(userConfigSlot));				if viewValue <> vwValue then					SetValue(self, 'viewValue, vwValue)				end			end,		TrackSlider: func()			begin			if not hwMode then				begin				local dBvolume := :ViewValueToDb(viewValue);				if userConfigSlot = 'soundVolumeDb then					begin					SetSystemVolume(dBvolume);					PlaySoundIrregardless(ROM_ratchetSound)					end				else					PlaySoundIrregardlessAtVolume(ROM_ratchetSound, dBvolume)				end			end,		ChangedSlider: func()			begin			local dBvolume := :ViewValueToDb(viewValue);			SetUserConfig(userConfigSlot, dBvolume);			:VolumeChangeAction(dBvolume)			end,		VolumeChangeAction: func(dBvolume)			begin			if userConfigSlot = 'soundVolumeDb then				:SysBeep()			else if userConfigSlot = 'alarmVolumeDb then				PlaySoundIrregardlessAtVolume(GetRegisteredSound(GetUserConfig('alarmSound)), dBvolume)			end,	},/*----------------------------------------------------------------------	@861			Looks very much like protoTXView again.*/	{},/*----------------------------------------------------------------------	@862			Empty array.*/	[ ],/*----------------------------------------------------------------------	@863			Empty array.*/	[ ],/*----------------------------------------------------------------------	@864			Empty array.*/	[ ],/*----------------------------------------------------------------------	@865			Empty array.*/	[ ],/*----------------------------------------------------------------------	@866			Empty array.*/	[ ],/*----------------------------------------------------------------------	@867			Empty array.*/	[ ],/*----------------------------------------------------------------------	@868			Styles palette - pen size popup.*/	{	_proto:		{	_proto: protoPopupButton,			viewBounds: nil,			viewJustify: vjCenterH + vjCenterV + vjParentCenterV + vjSiblingRightH,			text: nil,			pop: nil,			slot: nil,			pickActionScript: func(itemSelected)				begin				base.(slot) := popup[itemSelected].(slot);				:FontChanged(true);				inherited:pickActionScript(itemSelected)				end,			buttonClickScript: func()				begin				local kyView := GetKeyView();				if kyView and kyView.textFlags and BAnd(kyView.textFlags, 24) <> 0 then					begin					:Notify(kNotifyAlert, "Styles", "The style cannot be changed here.");					:Hilite(nil);					return					end;				popup := Clone(pop);				local curSize := :Setup();				if curSize then					foreach index, item in popup do						if item.(slot) = curSize then							begin							popup[index] := Clone(item);							popup[index].mark := $\uFC0B;							break							end;				inherited:buttonClickScript()				end		},		viewBounds: SetBounds(25, 0, 54, 13),		text: "  Pen",		pop:		[			{  icon: ROM_finePenTipBitmap,	indent: 10,	item: "1 pt",  value: 1 },			{  icon: ROM_smallPenTipBitmap,					item: "2",		value: 2 },			{  icon: ROM_mediumPenTipBitmap,					item: "3",		value: 3 },			{	icon: ROM_largePenTipBitmap,					item: "4",		value: 4 }		],		slot: 'value,		pickActionScript: func(itemSelected)			begin			:PenSizeChanged(popup[itemSelected].value);			:Hilite(nil)			end,		Setup: func()			begin			:GetSelectionPenSize()			end	},/*----------------------------------------------------------------------	@869*/	{	_proto: protoCoverPageFormatDeprecated,		viewJustify: 0x100F0,		symbol: 'prPlainFormat,		title: "Plain",		TextScript: 'plainText,		data: nil,		kids: nil,		reflowStart: 0,		viewSetupFormScript: func()			begin			inherited:viewSetupFormScript();			if fields.coverPage then				viewBounds := SetBounds(60, 20, -60, 0)			else				viewBounds := SetBounds(60, 40, -60, -40);			self.data := target.data;			self.reflowStart := 0			end,		viewSetupChildrenScript: func()			begin			if not kids and data then				kids := ReFlow(data, {  reflowFont: 12289,												viewLineSpacing: 28,												unistyle: nil,												graphicsGutter: 16,												textGutter: -16											}, fields.targetBox, :LocalBox());			if kids then				self.stepChildren := ArrayMunger([], 0, 0, kids, reflowStart, nil);			inherited:?viewSetupChildrenScript()			end,		printNextPageScript: func()			begin			if self.stepChildren then				reflowStart := reflowStart + Length(self.stepChildren);			if kids and reflowStart < Length(kids) then				:RedoChildren()			end	},/*----------------------------------------------------------------------	@870			Letter routing format.*/	{},/*----------------------------------------------------------------------	@871			Memo routing format.*/	{},/*----------------------------------------------------------------------	@872	newtCheckAllButton*/	{  _proto: protoTextButton,		viewBounds: SetBounds(-36, 0, -1, 14),		text: "\uFC0B\uAll",		keyButton: nil,		buttonClickScript: func()			begin			if newtAppBase.currentLayout = 'overview then				begin				if layout.checkAllPrimed then					layout:UnCheckAll()				else					layout:checkAll();				layout.checkAllPrimed := not layout.checkAllPrimed				end			end	}];