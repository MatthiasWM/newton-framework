{	GetOwnerApp: func(soupName)		begin		if IsInstance(soupName, 'string) then			begin			local index := LSearch([										ROM_calendarSoupName,										ROM_calendarNotesName,										ROM_metaSoupName,										ROM_inboxSoupName,										"Library",										ROM_cardfileSoupName,										ROM_paperRollSoupName,										ROM_outboxSoupName,										ROM_repeatMeetingName,										ROM_repeatNotesName,										ROM_systemSoupName,										ROM_todoSoupName ], soupName, 0, '|str=|, nil);			if index then				local appSym := [	'calendar,										'calendar,										'systemDirectory,										'iobox,										'systemLibrary,										'cardfile,										'paperroll,										'iobox,										'calendar,										'calendar,										'system,										'calendar ][index];			else				begin				local soup := GetStores()[0]:GetSoup(soupName);				if soup then					begin					local soupInfo := soup:GetInfo('soupDef);					if soupInfo then						appSym := soupInfo.ownerApp					else						begin						soupInfo := soup:GetInfo('applications);						if soupInfo and IsArray(soupInfo) and Length(soupInfo) > 0 then							appSym := soupInfo[0]						end					end				end			end;		appSym		end,// Time Zones	GetLocationSoup: func(soupName)		begin		local store := GetPackageStore("WorldData");		if store then			begin			local local2 := [(store:GetSoup(soupName))];			local local3 := store:GetSoup(soupName);			local local4 := GetStores()[0]:GetSoup(soupName);			if local4 then				local2 := [local4, local3]			else				local2 := [local3];			{	_parent: @232._parent,				class: 'unionSoup,				soupList: local2,				cursors: NewWeakArray(8),				theName: soupName,				StdQuery: @232._parent.Query,				Query: func(inSpec) {_proto: @258, realCurs: :StdQuery(inSpec), romOnly: Length(soupList) = 1},				locationCursor: @258 }			end		end,	GetLocationSoupNames: func()		begin		local store := GetPackageStore("WorldData");		if store then			store:GetSoupNames()		end,	LocationEntryAdd: func(arg1, arg2)		begin		local local1, local2;		local2 := GetStores()[0]:GetSoup(arg1);		if not local2 then			begin			local internalStore := GetStores()[0];			local soupDef := {				cities:				{					name: ROM_citySoupName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: ROM_citySoupName,					indexes: [						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'country, type: 'symbol },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'slot, path: 'areacode, type: 'string },						{ structure: 'multiSlot,							path: [ 'name, 'country, 'region ],							type: [ 'string, 'symbol, 'string ] },						{ structure: 'multiSlot,							path: [ 'country, 'name, 'region ],							type: [ 'symbol, 'string, 'string ] },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				countries:				{					name: ROM_countrySoupName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: ROM_countrySoupName,					indexes: [						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'symbol, type: 'symbol },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				daylightsavings:				{					name: ROM_dstSoupName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "Daylight Savings Times",					indexes: [						{ structure: 'slot, path: 'symbol, type: 'symbol },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				USStates:				{					name: ROM_USStateSoupName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "US States",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				CanadianProvinces:				{					name: ROM_canadianProvinceName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "Canadian Provinces",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				AustralianStates:				{					name: ROM_AustralianStateName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "Australian States",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				UKCounties:				{					name: ROM_UKCountyName,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "UK Counties",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				FrenchDepartments:				{					name: @854,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "French Departments",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				JapanesePrefectures:				{					name: @856,					userName: "Time Zones",					ownerApp: 'worldClock,					ownerAppName: "Time Zones",					userDescr: "Japanese Prefectures",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				}			}.(Intern(arg1));			local2 := CreateSoupFromSoupDef(soupDef, internalStore, nil);			local1 := true;		end;		arg2.kind := 'Add;		arg2.romID := nil;		local2:Add(arg2);		local1	end,	LocationEntryChange:	func(arg1)	begin	constant kRef4DADA1 := "Time Zones";			local local1, local2, local3, local4;		if not EntrySoup(arg1):GetStore():IsReadOnly() then		begin			EntryChange(arg1);			return arg1;		end;		local1 := EntrySoup(arg1):GetName();		soup := GetStores()[0]:GetSoup(local1);		if not soup then		begin			local2 := GetStores()[0];			local3 := {				cities:				{					name: @251,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: @251,					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'country, type: 'symbol },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'slot, path: 'areacode, type: 'string },						{ structure: 'multiSlot,							path:							[								'name,								'country,								'region							],							type:							[								'string,								'symbol,								'string							]						},						{ structure: 'multiSlot,							path:							[								'country,								'name,								'region							],							type:							[								'symbol,								'string,								'string							]						},						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				countries:				{					name: @295,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: @295,					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'symbol, type: 'symbol },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				daylightsavings:				{					name: @658,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "Daylight Savings Times",					indexes:					[						{ structure: 'slot, path: 'symbol, type: 'symbol },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				USStates:				{					name: @452,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "US States",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				CanadianProvinces:				{					name: @453,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "Canadian Provinces",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				AustralianStates:				{					name: @513,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "Australian States",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				UKCounties:				{					name: @524,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "UK Counties",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				FrenchDepartments:				{					name: @854,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "French Departments",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				},				JapanesePrefectures:				{					name: @856,					userName: kRef4DADA1,					ownerApp: 'worldClock,					ownerAppName: kRef4DADA1,					userDescr: "Japanese Prefectures",					indexes:					[						{ structure: 'slot, path: 'name, type: 'string },						{ structure: 'slot, path: 'abbrev, type: 'string },						{ structure: 'slot, path: 'latitude, type: 'int },						{ structure: 'slot, path: 'longitude, type: 'int },						{ structure: 'multiSlot,							path: [ 'longitude, 'latitude ],							type: [ 'int, 'int ] },						{ structure: 'slot, path: 'kind, type: 'symbol }					]				}			}.(Intern(local1));			soup := CreateSoupFromSoupDef(local3, local2, nil);		end;		local4 := EntryCopy(arg1, soup);		local4.kind := 'Replace;		local4.romID := arg1._uniqueId;		EntryChange(local4);		EntryUndoChanges(arg1);		local4	end,	LocationEntryRemoveFromSoup:	func(arg1)	begin	constant kRef4DADA1 := "Time Zones";			local local1, local2, local3, local4, local5;		if EntrySoup(arg1):GetStore():IsReadOnly() then		begin			local1 := EntrySoup(arg1):GetName();			local2 := GetStores()[0]:GetSoup(local1);			if not local2 then			begin				local3 := GetStores()[0];				local4 := {					cities:					{						name: @251,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: @251,						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'country, type: 'symbol },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'slot, path: 'areacode, type: 'string },							{ structure: 'multiSlot,								path: [ 'name, 'country, 'region ],								type: [ 'string, 'symbol, 'string ] },							{ structure: 'multiSlot,								path: [ 'country, 'name, 'region ],								type: [ 'symbol, 'string, 'string ] },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					countries:					{						name: @295,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: @295,						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'symbol, type: 'symbol },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					daylightsavings:					{						name: @658,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "Daylight Savings Times",						indexes:						[							{ structure: 'slot, path: 'symbol, type: 'symbol },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					USStates:					{						name: @452,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "US States",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					CanadianProvinces:					{						name: @453,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "Canadian Provinces",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					AustralianStates:					{						name: @513,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "Australian States",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					UKCounties:					{						name: @524,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "UK Counties",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					FrenchDepartments:					{						name: @854,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "French Departments",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					},					JapanesePrefectures:					{						name: @856,						userName: kRef4DADA1,						ownerApp: 'worldClock,						ownerAppName: kRef4DADA1,						userDescr: "Japanese Prefectures",						indexes:						[							{ structure: 'slot, path: 'name, type: 'string },							{ structure: 'slot, path: 'abbrev, type: 'string },							{ structure: 'slot, path: 'latitude, type: 'int },							{ structure: 'slot, path: 'longitude, type: 'int },							{ structure: 'multiSlot,								path: [ 'longitude, 'latitude ],								type: [ 'int, 'int ] },							{ structure: 'slot, path: 'kind, type: 'symbol }						]					}				}.(Intern(local1));				local2 := CreateSoupFromSoupDef(local4, local3, nil);				result := true;			end;			local5 := EntryCopy(arg1, local2);			RemoveAllButIndexes(local5);			local5.kind := 'delete;			local5.romID := arg1._uniqueId;			EntryChange(local5);			return local5;		end;		if arg1.kind = 'Replace then		begin			RemoveAllButIndexes(arg1);			arg1.kind := 'delete;			EntryChange(arg1);		end;		else			EntryRemoveFromSoup(arg1);		arg1	end,	CircleDistance: plainC.FCircleDistance /* funcPtr: 611538, numArgs: 5 */,	ClosestLocations: func(arg1, arg2, arg3, arg4, arg5, arg6)		begin		constant kRef435AC1 := '{ type: index, indexPath: [ longitude, latitude ] };		constant kRef3FFFFFFC := -1;		local local1, local2, local3, local5, local6, local7, local8;		/* closed */ local slot, d, longitude, latitude, list, entry, extra, radius, count;		count := arg2;		radius := arg3;		extra := arg6;		local5 := rinttol(radius / 70 / 180 * 268435456);		list := [];		local6 := [];		slot := extra.slot;		latitude := BAnd(CoordinateToLatitude(arg5, extra.height), kRef3FFFFFFC);		longitude := BAnd(CoordinateToLongitude(arg4, extra.width), kRef3FFFFFFC);		AddArraySlot(local6, {s: {x: longitude - local5, y: 0}, e: {x: longitude + local5, y: kRef3FFFFFFC}});		if local6[0].s.x < 0 then		begin			AddArraySlot(local6, DeepClone(local6[0]));			local6[0].s.x := 0;			local6[1].s.x := BAnd(local6[1].s.x, kRef3FFFFFFC);			local6[1].e.x := kRef3FFFFFFC;		end;		else (if local6[0].e.x < 0 then		begin			AddArraySlot(local6, DeepClone(local6[0]));			local6[0].e.x := kRef3FFFFFFC;			local6[1].s.x := 0;			local6[1].e.x := BAnd(local6[1].e.x, kRef3FFFFFFC);		end);		d := arg1.soupList[0]:Query(kRef435AC1);		local2 := Clone(kRef435AC1);		local2.IndexValidTest := func(arg1)			begin				local local1, local2, local3, local4;				local1 := CircleDistance(longitude, latitude, arg1[0], arg1[1], 'miles);				if local1 < radius then				begin					local2 := {x: arg1[0], y: arg1[1], d: local1};					if extra.slot then					begin						entry := d:GotoKey(arg1);						if entry.(slot) <> extra.filter then							return;					end;					if not BInsert(list, local2, '|<|, 'd, true) then					begin						local3 := BInsert(list, local2, '|<|, 'd, 'returnElt);						local4 := LSearch(list, local3.d, 0, '|=|, 'd);						while local3.d = local1 do						begin							if local3.x = arg1[0] and local3.y = arg1[1] then							begin								entry := d:GotoKey(arg1);								if entry and entry.kind <> 'Add then								begin									if entry.kind = 'delete then										ArrayRemoveCount(list, local4, 1);									return;								end;							end;							local4 := local4 + 1;							if local4 < Length(list) then								(local3 := list[local4]);							else								(local3.d := 0);						end;						BInsert(list, local2, '|<|, 'd, nil);					end;					if Length(list) > count then					begin						SetLength(list, count);						radius := list[count - 1].d;					end;				end;				return			end;		foreach local1 in local6 do		begin			local2.beginKey := [local1.s.x, local1.s.y];			local2.endKey := [local1.e.x, local1.e.y];			local7 := arg1:Query(local2);		end;		local7 := arg1:Query(kRef435AC1);		for local3 := 0 to Length(list) - 1 do		begin			local8 := list[local3];			entry := local7:GotoKey([local8.x, local8.y]);			list[local3] := {distance: local8.d, place: entry, item: entry.name};		end;		if Length(list) > 1 then			Sort(list, '|str<|, 'item);		list	end,	LatitudeToString: func(latitude)		begin		local local1 := latitude div 24855;		if local1 > 10800 then			local1 := local1 - 21600;		abs(local1 div 60) & $\A0 & abs(local1 mod 60) && (if local1 < 0 then $S else $N)		end,	LongitudeToString: func(longitude)		begin		local local1 := longitude div 24855;		if local1 > 10800 then			local1 := local1 - 21600;		abs(local1 div 60) & $\A0 & abs(local1 mod 60) && (if local1 < 0 then $W else $E)		end,	GetCityEntry: func(cityName)		begin		local citySoup := GetLocationSoup(ROM_citySoupName);		if not citySoup then			return;		local cursor := citySoup:Query({type: 'index, indexPath: 'name, beginKey: cityName, endKey: cityName});		cursor:Map(nil)		end,	GetCountryEntry: func(countryName)		begin		if IsInstance(countryName, '|string.country|) then			begin			local1 := SPrintObject(ClassOf(countryName));			countryName := Intern(Substr(local1, 15, StrLen(local1) - 15));			end;		local countrySoup := GetLocationSoup(ROM_countrySoupName);		if not countrySoup then			return;		local qSpec := {type: 'index, indexPath: 'symbol, beginKey: countryName, endKey: countryName};		if IsInstance(countryName, 'string) then			qSpec.indexPath := 'name;		local cursor := countrySoup:Query(qSpec);		cursor:map(nil)		end,	GetCityFromAlias: func(arg1)		begin		if IsEntryAlias(arg1) then			ResolveEntryAlias(arg1)		else if IsArray(arg1) then			begin			local local1, local2, local3, local4;			local1 := GetCityEntry(arg1[0]);			local2 := Length(local1);			if local2 > 1 then				foreach local4 in local1 do					if local4.longitude = arg1[1] and local4.latitude = arg1[2] then						begin						local3 := local4;						break local3						end;			if not local3 and local2 > 0 then				local3 := local1[0];			local3			end		end,	GetLocAccessNums: func(arg1, arg2)	begin		constant kRef480691 := "0123456789";		local local1, local2, local3, local4, local6, local7, local11, local13, local14;		local1 := [];		if arg1 then		begin			if IsEntryAlias(arg1) then				(arg1 := ResolveEntryAlias(arg1));			if IsInstance(arg1, 'worksite) then			begin				local2 := arg1;				local3 := ResolveEntryAlias(local2.cityAlias);			end;			else			begin				local2 := nil;				local3 := arg1;			end;		end;		else		begin			local2 := GetUserConfig('currentEmporium);			if IsEntryAlias(local2) then				(local2 := ResolveEntryAlias(local2));			if local2 then				(local3 := ResolveEntryAlias(local2.cityAlias));			else			begin				local3 := GetUserConfig('location);				if IsEntryAlias(local3) then					(local3 := ResolveEntryAlias(local3));			end;		end;		if not IsArray(arg2) then			(arg2 := [arg2]);		if if local2 then			local2.mailAccess then			foreach local4 in local2.mailAccess do			if SetContains(arg2, local4.mailNetwork) then			AddArraySlot(local1, Clone(local4));		local6 := foreach local7 in local1 collect			StringFilter(strtophone(local7.mailPhone), kRef480691, 'passAll);		foreach local11 in arg2 do		begin			local13 := DialinNetworkRegistry.(local11):?GetAccessNumbers(local2, local3);			if IsArray(local13) then				foreach local7 in local13 do			begin				local14 := StringFilter(strtophone(local7.mailPhone), kRef480691, 'passAll);				if not LSearch(local6, local14, 0, '|str=|, nil) then				begin					AddArraySlot(local1, local7);					AddArraySlot(local6, local14);				end;			end;		end;		local1	end,//	Formulas and Prefs	RegFormulas: func(appSym, template)		begin		formulasRegistry.(EnsureInternal(appSym)) := template;		local formulasApp := GetRoot().Formulas;		if formulasApp and formulasApp.viewCObject then			formulasApp:RedoChildren();		nil		end,	UnRegFormulas: func(appSym)		begin		RemoveSlot(formulasRegistry, appSym);		local formulasApp := GetRoot().Formulas;		if formulasApp and formulasApp.viewCObject then			formulasApp:RedoChildren();		nil		end,	RegPrefs: func(appSym, template)		begin		prefsRegistry.(EnsureInternal(appSym)) := template;		if GetRoot().preferenceRoll.viewCObject then			GetRoot().preferenceRoll:RedoChildren();		nil		end,	UnRegPrefs: func(appSym)		begin		RemoveSlot(prefsRegistry, appSym);		if GetRoot().preferenceRoll.viewCObject then			GetRoot().preferenceRoll:RedoChildren();		nil		end,	GetPrefs: func()		begin		constant kBuiltInPrefs :=		'[			passwordForm,			timePreferencesForm,			localePreferencesForm,			soundPreferencesForm,			recordingPreferencesForm,			alarmSoundPreferencesForm,			sleepPreferencesForm,			penPreferencesForm,			guestAccessPreferencesForm,			HWRecPreferencesForm,			recognitionPreferencesForm,			handwritingStylePreferencesForm,			textEditPreferencesForm,			letterShapesPreferencesForm,			fineTuningPreferencesForm,			zapPreferencesForm,			commPreferencesForm,			output.faxPreferencesForm,			autoDockPrefsPanel		];		local builtinPrefs := [];		local prefs := [];		foreach prefSym in kBuiltInPrefs do			begin			local pref := prefsRegistry.(prefSym);			if pref and not pref:?DoNotDisplay() then				AddArraySlot(builtinPrefs, pref);			end;		foreach prefSym, pref deeply in prefsRegistry do			if not SetContains(kBuiltInPrefs, prefSym) and pref = prefsRegistry.(prefSym) and not pref:?DoNotDisplay() then				AddArraySlot(prefs, pref);		ArrayMunger(prefs, Length(prefs), nil, preferences, 0, nil);		Sort(prefs, '|str<|, 'overview);		ArrayMunger(builtinPrefs, Length(builtinPrefs), nil, prefs, 0, nil)		end,	OpenPrefsTo: func(topic)		begin		if ClassOf(topic) = 'frame then			begin			local prefSlip := BuildContext(if topic.nogo then @810 else @809);			prefSlip.viewBounds := SetBounds(0, 0, 224, topic.height);			prefSlip.stepChildren := prefSlip.viewChildren;			prefSlip.viewChildren := [topic];			prefSlip.prefPanelProto := topic;			if topic.height < GetAppParams().appAreaWidth then				prefSlip.ReOrientToScreen := GetRoot().Close;			prefSlip:Open();			return prefSlip			end		else			foreach pref in GetPrefs() do				if StrEqual(pref.overview, topic) then					return OpenPrefsTo(pref)		end,//	Auxiliary Buttons	RegAuxButton: func(buttonSym, template)		begin		local auxBtn;		local index := LSearch(auxButtonRegistry, buttonSym, 0, '|=|, 'appSymbol);		if index then			ArrayRemoveCount(auxButtonRegistry, index, 1);		if template.destApp then			begin			auxBtn := {appSymbol: EnsureInternal(buttonSym), butt: template, destApp: EnsureInternal(template.destApp)};			index := LSearch(auxButtonRegistry, nil, 0, '|=|, 'destApp);			if not index then				index := 0;			ArrayInsert(auxButtonRegistry, auxBtn, index);			local app := GetRoot().(template.destApp);			if app then				app:?AddAuxButton(auxBtn);			end		else			begin			auxBtn := {appSymbol: EnsureInternal(buttonSym), butt: template};			AddArraySlot(auxButtonRegistry, auxBtn);			local blessed1 := GetUserConfig('blessedApp);			if blessed1 and blessed1 := GetRoot().(blessed1) then				blessed1:?AddAuxButton(auxBtn)			end;		auxBtn		end,	GetAuxButtons: func(appSym)		begin		local auxBtns := [];		if appSym then			foreach btn in auxButtonRegistry do				if btn.destApp = appSym then					AddArraySlot(auxBtns, btn);		if appSym = GetUserConfig('blessedapp) then			foreach btn in auxButtonRegistry do				if not btn.destApp then					AddArraySlot(auxBtns, btn);		auxBtns		end,	UnRegAuxButton: func(buttonSym)		begin		local index := LSearch(auxButtonRegistry, buttonSym, 0, '|=|, 'appSymbol);		if index then			begin			local app := auxButtonRegistry[index].destApp;			RemoveSlot(auxButtonRegistry, index);			if app then				begin				app := GetRoot().(app);				if app then					app:?RemoveAuxButton(buttonSym)				end			else				begin				local blessed1 := GetUserConfig('blessedApp);				if blessed1 and blessed1 := GetRoot().(blessed1) then					blessed1:?RemoveAuxButton(buttonSym)				end;			buttonSym			end		end,//	System Data	GetSysEntryData: func(entry, path) entry.(path),	GetUserConfig: func(inTag) userConfiguration.(inTag),	RegUserConfigChange: func(id, fn)		begin		userConfigChangeRegistry.(EnsureInternal(id)) := fn;		nil		end,	UnRegUserConfigChange: func(id)		begin		RemoveSlot(userConfigChangeRegistry, id);		nil		end,	SetSysEntryData: func(entry, path, value) entry.(path) := value,	SetUserConfig: func(inTag, inValue)		begin		local protoValue := userConfiguration._proto.(inTag);		if inValue = protoValue		or (IsBinary(inValue) and IsBinary(protoValue) and BinEqual(inValue, protoValue)) then			RemoveSlot(userConfiguration, inTag)		else			userConfiguration.(EnsureInternal(inTag)) := EnsureInternal(inValue);		local configFrame := {};		configFrame.(inTag) := userConfiguration.(inTag);		try			SystemConfigChange(inTag)		onexception |evt.ex| do			begin			end;		foreach tag, configFunc deeply in userConfigChangeRegistry do			if userConfigChangeRegistry.(tag) = configFunc then				try					if GetFunctionArgCount(configFunc) = 2 then						call configFunc with (inTag, configFrame);					else						call configFunc with (inTag)				onexception |evt.ex| do					begin					end;		FlushUserConfig();		inValue		end,	SetUserConfigEnMasse: func(inTag, inValue)		begin		foreach tag, value in inValue do			begin			local protoValue := userConfiguration._proto.(tag);			if value = protoValue			or (IsBinary(value) and IsBinary(protoValue) and BinEqual(value, protoValue)) then				RemoveSlot(userConfiguration, tag)			else				userConfiguration.(EnsureInternal(tag)) := EnsureInternal(value);			end;		try			SystemConfigChange(inTag)		onexception |evt.ex| do			begin			end;		foreach tag, configFunc deeply in userConfigChangeRegistry do			if userConfigChangeRegistry.(tag) = configFunc then				try					if GetFunctionArgCount(configFunc) = 2 then						call configFunc with (inTag, inValue);					else						call configFunc with (inTag)				onexception |evt.ex| do					begin					end;		FlushUserConfig();		inValue		end,	FlushUserConfig: func()		begin	//	AddProcrastinatedCall('_FlushUserConfig, functions.EntryChangeXmit, [userConfiguration, '_newt], 0)		end,	SystemConfigChange: func(inTag)		begin		PerformIfDefined({			lcdContrast: func()				begin				SetLCDContrast(GetUserConfig('lcdContrast))				end,			alarmVolume: func()				begin				local volume := GetUserConfig('alarmVolume);				if volume <> DecibelsToVolume(GetUserConfig('alarmVolumeDb)) then					SetUserConfig('alarmVolumeDb, VolumeToDecibels(volume))				end,			alarmVolumeDb: func()				begin				local volume := DecibelsToVolume(GetUserConfig('alarmVolumeDb));				if volume <> GetUserConfig('alarmVolume) then					SetUserConfig('alarmVolume, volume)				end,			soundVolume: func()				begin				local actualVolume := GetVolume();				local volume := GetUserConfig('soundVolume);				if volume <> actualVolume then					SetVolume(volume);				if volume <> DecibelsToVolume(GetUserConfig('soundVolumeDb)) then					SetUserConfig('soundVolumeDb, VolumeToDecibels(volume))				end,			soundVolumeDb: func()				begin				local sysVolume := GetSystemVolume();				local dBvolume := GetUserConfig('soundVolumeDb);				if dBvolume <> sysVolume then					SetSystemVolume(dBvolume);				local volume := DecibelsToVolume(dBvolume);				if volume <> GetUserConfig('soundVolume) then					SetUserConfig('soundVolume, volume)				end,			inputGain: func()				begin				local gain := GetUserConfig('inputGain);				if IsInteger(gain) then					begin					if gain < 0 then						gain := 0					else if gain > 255 then						gain := 255					end				else					gain := 128;				gain := SetInputGain(gain);				if gain <> userConfiguration.inputGain then					begin					userConfiguration.inputGain := gain;					FlushUserConfig()					end				end,			outputDevice: func()				begin				local device := GetUserConfig('outputDevice);				device := SetOutputDevice(device);				if device <> userConfiguration.outputDevice then					begin					userConfiguration.outputDevice := device;					FlushUserConfig()					end				end		}, inTag, nil)		end,//	Meta Data	RegMetaData: func(arg1, arg2)		begin		local local1 := GetDirectoryEntry(arg1);		if local1 then			begin			local1.metadataPath := arg2;			EntryChange(local1)			end		else			begin			local1 := {app: arg1, metadataPath: arg2};			GetStores()[0]:GetSoup(ROM_metaSoupName):Add(local1)			end;		local1		end,	UnregMetaData: func(arg1)		begin		local local1 := GetDirectoryEntry(arg1);		if local1 then			EntryRemoveFromSoup(local1)		end,	RegMetaDataExtension: func(arg1, arg2, arg3)		begin		if arg1 = nil then			return;		local local1 := GetDirectoryEntry(arg1);		if local1 then			begin			if not HasSlot(local1, 'extensionPaths) then				local1.extensionPaths := {};			local1.extensionPaths.(arg2) := arg3;			EntryChange(local1)			end		else			begin			local1 := {app: arg1, extensionPaths: {}};			local1.extensionPaths.(arg2) := arg3;			GetStores()[0]:GetSoup(ROM_metaSoupName):Add(local1)			end;		local1		end,	UnregMetaDataExtension: func(arg1, arg2)		begin		local local1 := GetDirectoryEntry(arg1);		if local1 and local1.extensionPaths then			begin			RemoveSlot(local1.extensionPaths, arg2);			EntryChange(local1)			end;		local1		end,	ResolveMetadataPath: func(arg1, arg2)		begin		if arg2 then			begin			local local1 := GetRoot().(arg2);			if not local1 then				begin				local local2 := GetDataDefs(arg1);				if local2 then					local1 := local2.(arg2)				end			end;		local1		end,	GetDirectoryEntry: func(arg1)		begin		if arg1 = nil then			return;		local cursor := GetStores()[0]:GetSoup(ROM_metaSoupName):Query({type: 'index, indexPath: 'app, beginKey: arg1, endKey: arg1});		cursor:Entry()		end,	ExpandDirectoryEntry: func(arg1)		begin		local local1, local2, local3, local4, local6;		local1 := DeepClone(arg1);		if local1 then			begin			if HasSlot(local1, 'metadataPath) then				(local1.metaDataFrame := ResolveMetadataPath(local1.app, local1.metadataPath));			if HasSlot(local1, 'extensionPaths) then				begin				local2 := {};				foreach local3, local4 in local1.extensionPaths do					begin					local6 := ResolveMetadataPath(local3, local4);					if local6.GetExtensionFrame then						local6 := local6:GetExtensionFrame();					if local6 then						local2.(local3) := local6;					end;				local1.extensionFrames := local2;				end			end;		local1		end,	RemAllButBuiltinFromDir: func()		begin		local cursor := GetStores()[0]:GetSoup(ROM_metaSoupName):Query(nil);		local soupEntry := cursor:Entry();		while soupEntry <> nil do			begin			if not soupEntry.builtInMetaData then				EntryRemoveFromSoup(cursor:Entry());			soupEntry := cursor:Next()			end		end,//	Emporia (Worksites)	AddEmporium: func(arg1)		begin		call func(arg1, arg2, arg3)			begin			local local1, local2, local3, local4;			local1 := nil;			local2 := nil;			local4 := {};			local3 := GetUserConfig(arg1);			if not local3 then				local3 := []			else				foreach local1 in local3 do					if IsSameEntry(local1, arg3) then						begin						local2 := local1;						break						end;			if not local2 then				begin				local1 := MakeEntryAlias(arg3);				AddArraySlot(local3, local1);				local4.(arg1) := local3;				if arg2 = 'currentPersona and not GetUserConfig('currentPersona) then					begin					SetUserConfig('currentPersona, local3[0]);					UseCurrentPersona();					end;				SetUserConfigEnMasse(arg1, local4);				end;			local1			end with ('emporia, 'currentEmporium, arg1)		end,	UseCurrentEmporium: func()		begin		local local1, local2, local3, local4, local5, local6, local7, local8;		local5 := ResolveEntryAlias(GetUserConfig('currentEmporium));		local6 := {};		if local5 then			(local3 := local5.cityAlias and GetCityFromAlias(local5.cityAlias));		else		begin			local5 := GetUserConfig('location);			local4 := true;		end;		local6.currentAreaCode := Stringer([local5.areacode]);		if local5.countrySymbol then			(local6.currentCountry := local5.countrySymbol);		if not local4 or StrFilled(local5.dialingPrefix) then			(local6.dialingPrefix := Clone(local5.dialingPrefix));		if local5.printer then			(local6.currentPrinter := Clone(local5.printer));		local1 := GetRoot().cardfile:bcEmailNetwork(local5, 'sprint);		if local1 then			begin			local2 := ConvertIntToPhone(local1[0].mailPhone);			local6.mailPhone := local2;			local6.mailPhoneFull := local2;			local6.mailNetwork := local1[0].mailNetwork;			end		else			begin			local1 := GetRoot().cardfile:bcEmailNetwork(local5, 'concert);			if local1 then				begin				local2 := ConvertIntToPhone(local1[0].mailPhone);				local6.mailPhone := local2;				local6.mailPhoneFull := local2;				local6.mailNetwork := local1[0].mailNetwork;				end			else				begin				local6.mailPhone := "";				local6.mailPhoneFull := "";				local6.mailNetwork := nil;				end			end;		if local3 then			begin			SetUserConfig('location, local3);			local7 := GetRoot().worldClock;			if local7 and local7.viewCObject then				begin				local7:UpdateLocationFields();				local7:RedoChildren();				end;			DSTVerify(Time());			vars.setTimeSeed := Random(1, 1000000);			GetRoot():Dirty();			end;		SetUserConfigEnMasse('emporia, local6);		if GetRoot().senderList then			foreach local8 in GetRoot().senderList do				local8:JamIt()		end,	SyncEmporia: func()		begin		call func(arg1, arg2)		begin			local local1, local2, local3, local4, local5, local7;			local3 := GetUserConfig(arg1);			if local3 then			begin				foreach local1, local2 in local3 do					if not ResolveEntryAlias(local2) then				begin					ArrayRemoveCount(local3, local1, 1);					local4 := true;				end;				if local4 then					SetUserConfig(arg1, local3);				local7 := GetUserConfig(arg2);				if not local7 or not ResolveEntryAlias(local7) then					(if arg2 = 'currentPersona then					(if Length(local3) > 0 then				begin					SetUserConfig('currentPersona, local3[0]);					UseCurrentPersona()				end;				else				begin					local5 := {name: Clone(""), address: Clone(""), cityZip: Clone(""), company: Clone(""), signature: nil, mailAccount: Clone(""), mailPassword: nil, homePhone: nil, faxPhone: nil, phone: nil};					local5.(arg2) := nil;					SetUserConfigEnMasse('personae, local5)				end);				else					local7 and SetUserConfig(arg2, nil))			end		end with ('emporia, 'currentEmporium)	end,//	Personae (Owners)	AddPersona: func(arg1)		begin		call func(arg1, arg2, arg3)			begin			local local1, local2, local3, local4;			local1 := nil;			local2 := nil;			local4 := {};			local3 := GetUserConfig(arg1);			if not local3 then				local3 := []			else				foreach local1 in local3 do				if IsSameEntry(local1, arg3) then					begin					local2 := local1;					break;					end;			if not local2 then				begin				local1 := MakeEntryAlias(arg3);				AddArraySlot(local3, local1);				local4.(arg1) := local3;				if arg2 = 'currentPersona and not GetUserConfig('currentPersona) then					begin					SetUserConfig('currentPersona, local3[0]);					UseCurrentPersona();					end;				SetUserConfigEnMasse(arg1, local4);				end;			local1			end with ('personae, 'currentPersona, arg1)		end,	SetPersona: func(arg1, arg2)		begin		local local1, local2, local3, local4;		arg2.name := GetRoot():PrimaryName(arg1);		arg2.address := Clone(arg1.address);		arg2.cityZip := arg1.city && arg1.region && arg1.postal_code;		arg2.company := if arg1.company then			Clone(arg1.company);		if arg1.country then		begin			arg2.country := Clone(arg1.country);			arg2.countrySlot := GetRoot():CountryLookup(arg1.country);		end;		arg2.signature := if arg1.owner.signature then			Clone(arg1.owner.signature);		local3 := GetRoot().cardfile:bcEMailAddress(arg1, [			'|string.email|		]);		if local3 then		begin			arg2.mailAccount := local3[0].email;			arg2.mailPassword := local3[0].emailPassword;		end;		else		begin			arg2.mailAccount := "";			arg2.mailPassword := nil;		end;		local1 := GetRoot().cardfile:bcPhoneNumber(arg1, 'phone);		if local1 then			(local1 := local1[0]);		else			(local1 := nil);		local2 := GetRoot().cardfile:bcPhoneNumber(arg1, 'homePhone);		if local2 then			(arg2.homePhone := local2[0]);		else			(arg2.homePhone := local1);		local2 := GetRoot().cardfile:bcPhoneNumber(arg1, 'faxPhone);		if local2 then			(arg2.faxPhone := local2[0]);		else			(arg2.faxPhone := local1);		local2 := GetRoot().cardfile:bcPhoneNumber(arg1, 'workPhone);		if local2 then			(arg2.phone := local2[0]);		else			(arg2.phone := local1)	end,	UseCurrentPersona: func()		begin		local local1, local2, local3;		local1 := ResolveEntryAlias(GetUserConfig('currentPersona));		if not local1 then			return;		local2 := {};		SetPersona(local1, local2);		SetUserConfigEnMasse('personae, local2);		if GetRoot().senderList then			foreach local3 in GetRoot().senderList do				local3:JamIt()		end,	SyncPersonae: func()		begin		call func(arg1, arg2)			begin			local local1, local2, local3, local4, local5, local7;			local3 := GetUserConfig(arg1);			if local3 then			begin				foreach local1, local2 in local3 do					if not ResolveEntryAlias(local2) then				begin					ArrayRemoveCount(local3, local1, 1);					local4 := true;				end;				if local4 then					SetUserConfig(arg1, local3);				local7 := GetUserConfig(arg2);				if not local7 or not ResolveEntryAlias(local7) then					(if arg2 = 'currentPersona then					(if Length(local3) > 0 then				begin					SetUserConfig('currentPersona, local3[0]);					UseCurrentPersona()				end;				else				begin					local5 := {name: Clone(""), address: Clone(""), cityZip: Clone(""), company: Clone(""), signature: nil, mailAccount: Clone(""), mailPassword: nil, homePhone: nil, faxPhone: nil, phone: nil};					local5.(arg2) := nil;					SetUserConfigEnMasse('personae, local5)				end);				else					local7 and SetUserConfig(arg2, nil))			end		end with ('personae, 'currentPersona)	end,	ValidateConfigGuts: func(arg1, arg2, arg3, arg4)	begin		local local1, local2, local3, local4, local5, local6, local7, local8, local9, local10, local11;		/* closed */ local dataFields, hasText, hasNumber;		dataFields := [];		local9 := func(arg1, arg2, arg3)			begin				AddArraySlot(dataFields, {_proto: arg1.inputProto, path: if arg2 then					arg2;				else					arg3, HasData: arg1.HasData, label: arg1.theText});				hasText := hasText or arg1.type = 'text;				hasNumber := hasNumber or arg1.type = 'number			end;		if arg1 then			(local1 := arg1);		else (if arg2 = 'location then		begin			local10 := GetUserConfig('currentEmporium);			local1 := local10 and ResolveEntryAlias(local10);			if not local1 then			begin				local11 := GetUserConfig('location);				if IsReadOnly(local11) then					SetUserConfig('location, DeepClone(local11));				local1 := GetUserConfig('location);			end;		end;		else (if arg2 = 'owner then		begin			local1 := ResolveEntryAlias(GetUserConfig('currentPersona));			if not local1 then				(local1 := GetRoot().cardfile:addcard('owner, nil));		end));		if not local1 then		begin			GetRoot():Notify(kNotifyAlert, "Addressing", "Addressing error: no address frame found");			return;		end;		local8 := if IsFrame(arg2) then			arg2;		else			@308.(arg2);		ValidityCheck(local1, local8, arg3, local9, arg4.context);		if Length(dataFields) > 0 then			begin			local6 := BuildContext({_proto: @508,											stepChildren: dataFields,											target: local1,											isUserConfig: not arg1,											pathArray: arg3,											context: arg4.context,											compView: arg4.receiver,											compMsg: arg4.message,											titleText: arg4.titleText,											userText: arg4.userText,											kbdType: if hasText then 'alpha else if hasNumber then 'number });			local6:Open();			return { slip: local6, result: nil }			end		else if arg4.message then			begin			Perform(arg4.receiver, arg4.message, [ true ]);			return { result: true }			end	end,	ValidityCheck: func(arg1, arg2, arg3, arg4, arg5)	begin		local local1, local2, local4, local5, local6;		local1 := [];		foreach local2 in arg3 do		begin			local4 := nil;			local5 := arg2.(local2);			dataFunc := local5.getPath;			local4 := if dataFunc then				call dataFunc with (arg1, arg5);			else (if local5.dataPath then				local5.dataPath;			else				local2);			local6 := arg1.(local4);			HasData := if local5.HasData then				call local5.HasData with (arg1);			else (if IsInstance(local6, 'string) then				StrFilled(local6);			else				local6);			if not HasData then				(if arg4 then				call arg4 with (local5, local4, local2);			else				AddArraySlot(local1, local2));		end;		if not arg4 then			local1	end,//	PIN	DESCreatePasswordKey: plainC.FDESCreatePasswordKey /* funcPtr: 7012379, numArgs: 1 */,	ModalChangePIN: func(oldPIN)		begin		if not oldPIN or ModalCheckPIN("Enter old PIN", oldPIN) then			begin			local newPIN := ModalPINPrompt("Enter New PIN");			if newPIN then				begin				if ModalCheckPIN("Confirm New PIN", newPIN) then					newPIN				else					begin					GetRoot():Notify(kNotifyAlert, "PIN Entry",	"Confirmation of the new PIN failed. "																				"Your original PIN remains unchanged.");					nil					end				end			else				begin				GetRoot():Notify(kNotifyAlert, "PIN Entry",	"No new PIN was entered. "																			"Your original PIN remains unchanged.");				nil				end			end		else			begin			GetRoot():Notify(kNotifyAlert, "PIN Entry",	"An incorrect PIN has been entered. "																		"Please try again.");			nil			end		end,	ModalCheckPIN: func(title, oldPIN)		begin		if oldPIN then			begin			local newPIN := ModalPINPrompt(title);			newPIN and BinEqual(newPIN, oldPIN)			end		else			true		end,	ModalPINPrompt: func(title)		begin		local dlog := @558:BuildMeUp(title);		dlog:ModalDialog();		dlog.newPinKey		end,//	protoTXView	GleanIntendedText: func()		begin		local local1, local2, local3, local4, local5, local6, local7, local8;		local2 := GetHilitedTextItems();		if local2 and Length(local2) > 0 then			local1 := local2[0]		else			begin			local3 := GetCaretInfo();			if local3 and local3.view and local3.info then				begin				local6 := local3.view;				local7 := local3.info;				if local7.class = 'paraCaret then					begin					if local6.viewClass = 108 then						begin						local8 := local6:GetLineRange(local7.offset);						local4 := local6:GetRangeData(local8, 'text);						local5 := local6:GetRangeData(local8, 'styles);						end					else						begin						local4 := local6.text;						local5 := local6.styles;						end;					if not local5 then						local5 := {};					if StrFilled(local4) then						local1 := MakeRichString(local4, local5)					end				end			end;		local1		end,	SpellDocBegin: plainC.FSpellDocBegin /* funcPtr: 7046201, numArgs: 0 */,	SpellDocEnd: plainC.FSpellDocEnd /* funcPtr: 7046202, numArgs: 1 */,	SpellSkip: plainC.FSpellSkip /* funcPtr: 7046203, numArgs: 2 */,	SpellCheck: plainC.FSpellCheck /* funcPtr: 7046204, numArgs: 2 */,	SpellCorrect: plainC.FSpellCorrect /* funcPtr: 7046205, numArgs: 2 */,//	Names	dsGetCandidateEMail: func(arg1, arg2)		begin		if arg2 <> nil then			begin			local local1, local2, local4;			local1 := GetRoot().cardfile:bcEMailAddress(arg2, ['|string.email|]);			if local1 and HasSlot(arg1, 'mailTag) then				foreach local2 in arg1.mailTag do					foreach local4 in local1 do						begin						str := local4.email;						if ClassOf(str) = local2 and StrFilled(str) then							return str						end			end;		nil		end,	dsSetCandidatePhone: func(arg1, arg2, arg3)		begin		if HasSlot(arg1, 'dialDirect) then			begin			arg2.phone := arg1.dialdirect;			if not arg2.country then				arg2.country := userConfiguration.location.country			end		else if arg3 then			arg2.phone := arg3[0]		end,//	Dates	InitiatePlan9: func()		begin		local datesApp := GetRoot().calendar;		if IsReadOnly(datesApp.meetingTypeRegistry) then			begin			datesApp.externalTypeRegistry := {};			datesApp.meetingTypeRegistry := {_proto: datesApp.|MeetingTypesROM-51|}			end		else			datesApp.meetingTypeRegistry._proto := datesApp.|MeetingTypesROM-51|		end,	GetAllMeetings: plainC.FGetAllMeetings /* funcPtr: 6966889, numArgs: 4 */,	GetAllMeetingsUnique: plainC.FGetAllMeetingsUnique /* funcPtr: 6995447, numArgs: 4 */,	GetMeetingIcon: plainC.FGetMeetingIcon /* funcPtr: 6995454, numArgs: 1 */,	GetMeetingTypeInfo: plainC.FGetMeetingTypeInfo /* funcPtr: 6995455, numArgs: 1 */,	GetNextMeetingTime: plainC.FGetNextMeetingTime /* funcPtr: 6966893, numArgs: 2 */,	NextMeeting: plainC.FNextMeeting /* funcPtr: 6967959, numArgs: 2 */,	PrevMeeting: plainC.FPrevMeeting /* funcPtr: 7038763, numArgs: 2 */,	LayoutMeeting: plainC.FLayoutMeeting /* funcPtr: 6974298, numArgs: 4 */,	DrawMeetingGrid: plainC.FDrawMeetingGrid /* funcPtr: 7035585, numArgs: 1 */,	WeekNumber: plainC.FWeekNumber /* funcPtr: 7040874, numArgs: 2 */,//	Fax	RegCoverPage: func(arg1, arg2)		begin		coverPageRegistry.(EnsureInternal(arg1)) := arg2;		nil		end,	UnRegCoverPage: func(arg1)		begin		RemoveSlot(coverPageRegistry, arg1);		nil		end,//	Mail	RegisterMailService: func(arg1)		begin		local local1 := vars.EmailSystems;		if Length(local1) = 1 then			begin			local1.emailClasses := Clone(local1._proto.emailClasses);			local1.emailText := Clone(local1._proto.emailText);			local1.emailInternet := Clone(local1._proto.emailInternet);			end;		if not LSearch(local1.emailClasses, arg1.symbol, 0, '|=|, nil) then			AddArraySlot(local1.emailClasses, arg1.symbol);		local1.emailText.(EnsureInternal(arg1.symbol)) := SetClass(EnsureInternal(arg1.name), EnsureInternal(arg1.symbol));		local1.emailInternet.(EnsureInternal(arg1.symbol)) := EnsureInternal(arg1.normalize)		end,//	mailnavigator: nil,	FindMailNetwork: func(arg1, arg2)	begin		local local1, local2, local3;		local1 := nil;		local2 := Length(arg1) - 1;		for local3 := 0 to local2 do			if arg1[local3].id = arg2 then		begin			local1 := Clone(arg1[local3]);			break;		end;		local1	end,	MakeSmartMail: func(arg1, arg2, arg3)	begin		local local1;		local1 := GetRoot().iobox.allDataDefs.smartMail:MakeNewEntry();		local1.options := DeepClone(arg1);		local1.setup := DeepClone(arg2);		local1.arg := arg3;		local1	end,	MailToNote: func(arg1, arg2)	begin		local local1, local2, local3, local4, local5, local6, local7, local8, local10, local11;		local1 := nil;		local2 := nil;		local3 := nil;		local4 := nil;		if IsString(arg2.text) then		begin			local6 := arg2.text;			local7 := arg2.textdata;			RemoveSlot(arg2, 'activeSlot);			RemoveSlot(arg2, 'text);			local3 := DeepClone(arg2);			local3.body := {class: 'text, text: local6, textdata: local7};			if local3.SavedAppSymbol then				RemoveSlot(local3, 'SavedAppSymbol);			if local7 then				RemoveSlot(arg2, 'textdata);		end;		if local3 then			(local5 := [arg2, local3]);		else			(local5 := [arg2]);		foreach local8 in local5 do		begin			if local8.SavedAppSymbol then				(local1 := local8.SavedAppSymbol);			else			begin				local10 := ClassOf(local8.body);				if local10 then					(local11 := ClassAppByClass(local10));				if IsArray(local11) and Length(local11) > 0 and IsSymbol(local11[0]) then					(local1 := local11[0]);			end;			local2 := GetVariable(GetRoot(), local1);			if not local2 then				(local4 := nil);			if hasVariable(local2, 'PutAwayScript) then				(local4 := local2:PutAwayScript(local8));			else (if hasVariable(local2, 'PutAway) then			begin				local4 := true;				local2:PutAway(local8);			end);			if not local4 then				break;		end;		return local4	end,//	Dial-in Networks	RegDialinNetwork: func(arg1, arg2)		begin		dialinNetworkRegistry.(EnsureInternal(arg1)) := arg2;		nil		end,	UnRegDialinNetwork: func(arg1)		begin		RemoveSlot(dialinNetworkRegistry, arg1);		nil		end,	GetDialinNetwork: func(arg1)		begin		dialinNetworkRegsitry.(arg1)		end,	GetAllDialinNetworks: func()		begin		local networks := [];		foreach tag, network deeply in dialinNetworkRegistry do			if dialinNetworkRegistry.(tag) = network and IsFrame(network) then				AddArraySlot(networks, network);		Sort(networks, '|str<|, 'title);		return networks		end,	GetDialinNetworkSlot: func(slotSym)		begin		foreach network in GetAllDialinNetworks() collect			network.(slotSym)		end,//	Data Conversion, OS 1.x -> 2.x	RegDataConversion: func(arg1, arg2)		begin		dataConversionRegistry.(EnsureInternal(arg1)) := arg2;		nil		end,	UnRegDataConversion: func(arg1)		begin		RemoveSlot(dataConversionRegistry, arg1);		nil		end,	ConvertChildTemplates: func(arg1, arg2, arg3)	begin		local local1, local2, local3, local4, local5;		/* closed */ local childWidth, createdChildren, layoutView;		local1 := if arg3 = 'two0 then			'ink2;		else			'ink;		createdChildren := [];		layoutView := func(arg1)			begin				local local1;				if arg1.left + arg1.newWidth > childWidth then				begin					arg1.left := arg1.lMargin;					arg1.top := arg1.top + arg1.curLineHeight;					arg1.curLineHeight := 26;				end;				local1 := arg1.child;				if arg1.newHeight > arg1.curLineHeight then					(arg1.curLineHeight := arg1.newHeight);				local1.viewBounds.left := arg1.left;				local1.viewBounds.top := arg1.top + (arg1.curLineHeight - arg1.newHeight) div 2;				local1.viewBounds.right := arg1.left + arg1.newWidth;				local1.viewBounds.bottom := arg1.top + arg1.newHeight;				arg1.left := arg1.left + arg1.newWidth			end;		local2 := func(arg1)			begin				local local1, local2, local3, local6, local7, local8, local9, local10, local11, local12, local13;				if if arg1 then					arg1.styles then				begin					for local3 := 1 to Length(arg1.styles) - 1 by 2 do						if ClassOf(arg1.styles[local3]) = 'inkWord then					begin						local2 := true;						break local2;					end;					if not local2 then						for local3 := 1 to Length(arg1.styles) - 1 by 2 do					begin						local6 := GetFontFamilyNum(arg1.styles[local3]);						if not local6 or local6 >= 3 then							(arg1.styles[local3] := SetFontFamily(arg1.styles[local3], 1));					end;					else					begin						local7 := 0;						local8 := {left: arg1.viewBounds.left, top: arg1.viewBounds.top, newWidth: 0, newHeight: 0, curLineHeight: 26, child: nil, lMargin: arg1.viewBounds.left};						childWidth := arg1.viewBounds.right;						for local3 := 1 to Length(arg1.styles) - 1 by 2 do						begin							if ClassOf(arg1.styles[local3]) = 'inkWord then							begin								local9 := {_proto: @199, viewBounds: {left: 0, top: 0, right: 0, bottom: 0}, ink: InkConvert(arg1.styles[local3], 'ink)};								local10 := GetInkWordInfo(arg1.styles[local3]);								local8.newWidth := local10.origWidth + 10;								local8.newHeight := local10.origAscent + local10.origDescent + 4;								local8.child := local9;								call layoutView with (local8);								AddArraySlot(createdChildren, local9);								local1 := true;							end;							else							begin								local11 := Substr(arg1.text, local7, arg1.styles[local3 - 1]);								if local11 then								begin									local12 := SplitString(local11);									if local12 and Length(local12) > 0 and local12[0] <> nil then										foreach local13 in local12 do									begin										local9 := {_proto: @193, viewStationery: 'para, viewBounds: {left: 0, top: 0, right: 0, bottom: 0}, text: local13};										local8.newWidth := StrFontWidth(local13, 18433) + 5;										local8.newHeight := 18;										local8.child := local9;										call layoutView with (local8);										AddArraySlot(createdChildren, local9);										local1 := true;									end;								end;							end;							local7 := local7 + arg1.styles[local3 - 1];						end;					end;				end;				local1			end;		local3 := func(arg1)		begin			local local1;			if if arg1 then				arg1.viewFont then			begin				local1 := GetFontFamilyNum(arg1.viewFont);				if not local1 or local1 >= 3 then					(arg1.viewFont := SetFontFamily(arg1.viewFont, 1))			end		end;		if ClassOf(arg1) = 'frame then		begin			local4 := arg1;			if local4.ink then				(local4.ink := InkConvert(local4.ink, local1));			call local3 with (local4);			call local2 with (local4);		end;		else (if ClassOf(arg1) = 'Array then			(if Length(arg1) > 0 then			for local5 := Length(arg1) - 1 to 0 by -1 do		begin			local4 := arg1[local5];			if local4.ink then				(local4.ink := InkConvert(local4.ink, local1));			call local3 with (local4);			if call local2 with (local4) then				ArrayRemoveCount(arg1, local5, 1);		end));		if Length(createdChildren) = 0 then			nil		else			createdChildren	end,	GetConversionFrame: func(arg1)	begin		local local1, local2, local3, local4;		if arg1 = nil then			return;		local1 := {			note: 'paperroll,			outline: 'paperroll,			checkList: 'paperroll,			grid: 'paperroll,			person: 'cardfile,			company: 'cardfile,			place: 'cardfile,			group: 'cardfile,			owner: 'cardfile,			worksite: 'cardfile,			ioItem: 'iobox		}.(arg1);		if local1 then			arg1 := local1;		local2 := dataConversionRegistry.(arg1);		if not local2 then			return;		if IsFrame(local2) then			local3 := local2		else			begin			local3 := GetRoot().(local2);			if not local3 then				begin				local4 := GetDataDefs(arg1);				if local4 then					(local3 := local4.(local2));				end;			end;		local3		end,	ConvertFrame: func(arg1, arg2, arg3, arg4, arg5, arg6)		begin		local local1 := arg5;		if not arg2 then			arg2 := GetConversionFrame(arg1);		if arg2 then			local1 := arg2:?Convert(arg5, arg3, arg4, arg6)		else			begin			end;		local1		end}