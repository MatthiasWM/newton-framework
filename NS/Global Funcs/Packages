{// Store Parts	GetPackageStore: plainC.FGetPackageStore/*name*/,	GetPackageStores: plainC.FGetPackageStores,//	Packages	ActivateStorePackages: func(inStore)		begin		local storeName := inStore:GetName();		local doActivate := true;		local isInternal := inStore = GetStores()[0];		local penLocation := PenPos();		if penLocation		and (penLocation.x < 40		 or  penLocation.y < 40) then			begin			if isInternal then				doActivate := ModalConfirm("Do you want to activate the packages on the internal store?",												[	{ value: true,	text: "Activate" },													{ value: nil,	text: "No" } ])			else				doActivate := ModalCardAlert('|ActivatePackages?|, inStore:CardSlot(), storeName)			end;		if doActivate then			begin			local activationResult := try				if inStore.version >= 4 then					|ActivateStore2.XPackages|(inStore)				else					|ActivateStore1.XPackages|(inStore)				onexception |evt.ex| do					{ errList: "" };			if activationResult.dupList then				GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("Some packages on the store Ò^0Ó conflict with the names of packages already in use: ^1.", [storeName, activationResult.dupList]));			if activationResult.errList then				GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("Errors occurred activating packages on the store Ò^0Ó: ^1.", [storeName, activationResult.errList]));			end		else if isInternal and penLocation.y < 40 then			call @808 with ();	// bless Notes		XmitPackageOp('ActivateStorePackages);		doActivate		end,	|ActivateStore2.XPackages|: func(inStore)		begin		local dupList;		local errList;		local miscErrorCount := 0;		local pkgSoup := inStore:GetSoup("Packages");		if pkgSoup then			begin			local packageList := GetPackages();			local cursor := pkgSoup:Query({ indexPath: 'packageName, tagspec: { none: '_frozen, all: '_package } });			local entry := cursor:Entry();			local local2 := GetRoot().sleepScreen.viewCObject or inStore = GetStores()[0];			if entry then				DoProgress('vBarber,								{	barber: true,									statusText: ParamStr("Activating packages on the store Ò^0Ó.", [(inStore:GetName())]),									icon: {	mask: MakeBinaryFromHex("000000000004010901090174011E018100000000000000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE000003FE0000000000000000000000000000000000000", 'mask),												bits: MakeBinaryFromHex("000000000004010901090174011E01817FF00000FFF80000C0180000C0180000C0180000C0180000C0180000C0180000C0180000C0180000C0180000C0180000DFD80000CF980000C7180000C2180000C0180000FFF800007FF000000000000000000000", 'bits),												bounds: { left: 0, top: 0, right: 13, bottom: 21 } },									primary: nil, closeBox: nil, screenRelativeH: local2 },								func(inDialog)									begin									while entry do										try											local storeName;											local pkgName := entry.packageName;											local pkgItem := LFetch(packageList, pkgName, 0, '|str=|, 'title);											if pkgItem then												begin												storeName := if pkgItem.store then pkgItem.store:GetName() else "Built-In";												dupList := StrConcatDelimited(dupList, ", ", ParamStr("Ò^0Ó on Ò^1Ó", [pkgName, storeName]));												end											else												try													inDialog:?SetStatus('vBarber, {titleText: $Ò & pkgName & $Ó, barber: true});													ActivatePackage(entry.pkgRef)												onexception |evt.ex| do													errList := StrConcatDelimited(errList, ", ", $Ò & pkgName & $Ó);											entry := cursor:Next();										onexception |evt.ex| do											miscErrorCount := miscErrorCount + 1									end )			end;		if miscErrorCount > 0 then			errList := StrConcatDelimited(errList, ", ", ParamStr("^0 unknown package^?1s||", [miscErrorCount, miscErrorCount > 1]));		{ dupList: dupList, errList: errList }		end,	ActivatePackage: plainC.FInstallPackage/*pkg*/,	SafeActivatePackage: func(arg1, arg2, arg3)		begin		local isActivated := SafeActivatePackageQT(arg1, arg2, arg3);		if isActivated then			XmitPackageOp('SafeActivatePackage);		isActivated		end,	SafeActivatePackageQT: func(arg1, inName, inStore)		begin		local storeName;		local pkgItem := LFetch(GetPackages(), inName, 0, '|str=|, 'title);		if pkgItem then			begin			storeName := if pkgItem.store then				pkgItem.store:GetName()			else				"Built-In";			GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("The package Ò^0Ó (on store Ò^1Ó) was not activated because a package by the same name (on store Ò^2Ó) is already in use.", [inName, inStore:GetName(), storeName]));			nil			end		else			begin			ActivatePackage(arg1);			true			end		end,	OKToDeactivatePackage: func(arg1, arg2, arg3)		begin		local local1 := [];		foreach busyItem in busyPackages do			if busyItem.pkgRef = arg1 then				AddArraySlot(local1, {name: busyItem.appName, message: busyItem.reason});		local local4 := GetPkgRefInfo(arg1);		foreach local5 in local4.parts do			if IsFrame(local5) and local5._ExportTable then				foreach local7 in local5._ExportTable do					foreach local9 in GetExportTableClients(local7.objects) do						try							local local11 := local9.client:?RemovalApproval(local9.name, local9.major, local9.minor);							if local11 then								AddArraySlot(local1, {name: arg2, message: local11});						onexception |evt.ex| do							begin							end;		if Length(local1) = 0 and IsProtocolPartInUse(arg1) then			AddArraySlot(local1, {name: arg2, message: "This operation may cause serious problems."});		foreach local12 in local1 do			if not ModalConfirm(ParamStr("Ò^0Ó is currently in use. ^1 ^2", [local12.name, local12.message, arg3]), 'okCancelDefaultCancel) then				return;		true		end,	DeActivateStorePackages: func(inStore)		begin		try			if inStore.version >= 4 then				|DeActivateStore2.XPackages|(inStore)			else				|DeActivateStore1.XPackages|(inStore)		onexception |evt.ex| do			begin			end;		AddDeferredCall(functions.XmitPackageOp, [ 'DeActivateStorePackages ])		end,	|DeActivateStore2.XPackages|: func(inStore)		begin		foreach pkg in ActivePackageList do			try				if GetVBOStore(pkg) = inStore then					DeActivatePackage(pkg)			onexception |evt.ex| do				begin				end		end,	DeActivatePackage: plainC.FDeinstallPackage/*pkg*/,	SafeDeactivatePackage: func(arg1)		begin		local entry := PackageEntryFromThingy(arg1);		if entry		and OKToDeactivatePackage(entry.pkgRef, entry.packageName, "Are you sure you want to deactivate it?") then			begin			DeActivatePackage(entry.pkgRef);			XmitPackageOp('SafeDeactivatePackage);			true			end		end,	IsSirNotAppearingInThisROM: func(inPkgName, arg2, arg3)		begin		local local1;		if vars.SirNotAppearingInThisROM then			local1 := BFetch(SirNotAppearingInThisROM, inPkgName, '|str<|, 'packageName);		if not local1 then			local1 := BFetch(@215, inPkgName, '|str<|, 'packageName);		if local1		and arg2 <= local1.version then			begin			if local1.message then				GetRoot():Notify(kNotifyAlert, "Newton",					ParamStr( {	install: "The package Ò^0Ó was not installed because it does not work with this system. ^1",									activate: "The package Ò^0Ó was not activated because it does not work with this system. ^1",									convert: "The package Ò^0Ó was not converted because it does not work with this system. ^1" }.(arg3), [inPkgName, local1.message]));			true			end		end,	LoadPackage: func(arg1)		begin		if not arg1 or ClassOf(arg1) = 'string then			arg1 := {file: arg1};		call {			class: Ref(0x132),			funcPtr: 7039836,			numArgs: 0x3		} with (arg1.file, if arg1.store then arg1.store else GetDefaultStore(), arg1)		end,	RegisterNewPackage: func(inPkgRef, inStore, arg3)		begin		local pkRef := inPkgRef;		local pkInfo := GetPkgRefInfo(pkRef);		local pkName := pkInfo.title;		if IsSirNotAppearingInThisROM(pkName, pkInfo.version, 'install) then			return;		try			foreach partIndex, part in pkInfo.parts do			if IsFrame(part) and part:?DoNotInstall() then				return		onexception |evt.ex| do			begin			GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("An error occurred installing the package Ò^0Ó. It may not work with this system. Contact the software publisher for further information. (Part ^1, Type ^2)", [pkName, partIndex, pkInfo.parttypes[partIndex]]));			return			end;		if GetPackageEntry(pkName, inStore) then			begin			GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("The package Ò^0Ó was not installed because a package by the same name is already installed on the store Ò^1Ó.", [pkName, inStore:GetName()]));			return			end;		local partTypes := pkInfo.parttypes;		local local6 := if Length(partTypes) > 0 then			{ tsps: true, tspt: true }.(partTypes[0]);		if not(local6 or pkInfo.dispatchonly) then			begin			local soup := GetUnionSoupAlways("Packages"):GetMember(inStore);			inStore:AtomicAction(func()					begin					local pkInfo := soup:Add({pkgRef: pkRef, _tagList: ['_package], packageName: pkName});					pkRef := pkInfo.pkgRef;					UnsafeXmitSoupChangeNow("Packages", '_newt, 'entryAdded, pkInfo)					end);			end;		if arg3 then			SafeActivatePackageQT(pkRef, pkName, inStore);		XmitPackageOp('RegisterNewPackage);		pkRef		end,	PackageEntryFromThingy: func(inPkgRef)		begin		local local1, local2, local3, local4;		if IsPackageEntry(inPkgRef) then			local1 := inPkgRef;		else			begin			if IsFrame(inPkgRef) then				begin				local2 := inPkgRef.title;				local3 := inPkgRef.store;				end			else				begin				if ClassOf(inPkgRef) = 'int then					inPkgRef := PidToPkgRef(inPkgRef);				if IsPackage(inPkgRef) then					begin					local pkInfo := GetPkgRefInfo(inPkgRef);					local2 := pkInfo.title;					local3 := pkInfo.store;					end				end;			if local2 and local3 then				local1 := GetPackageEntry(local2, local3)			end;		local1		end,	InstallPart: func(inPart)		begin		local result;		try			if inPart.partType = 'form then				result := InstallFormPart(inPart)			else if inPart.partType = 'auto then				result := InstallAutoPart(inPart)		onexception |evt.ex| do			GetRoot():Notify(kNotifyAlert, "Newton", ParamStr("An error occurred activating the package Ò^0Ó. It may not work with this system. Contact the software publisher for further information. (Part ^1, Type ^2)", [inPart.packageName, inPart.partIndex, inPart.partType]));		if inPart.packageStyle = 'HighROM then			GetRoot().ExtrasDrawer:HandleNewHighROMPart(inPart)		else if inPart.packageStyle = '|1.X| then			GetRoot().ExtrasDrawer:|HandleNew1.XPart|(inPart);		result		end,	RemovePart: func(inPart, arg2)		begin		try			if inPart.partType = 'form then				RemoveFormPart(inPart, arg2)			else if inPart.partType = 'auto then				RemoveAutoPart(inPart, arg2)		onexception |evt.ex| do			begin			end;		if inPart.packageStyle = 'HighROM then			GetRoot().ExtrasDrawer:HandleRemovedHighROMPart(inPart.packageId)		else if inPart.packageStyle = '|1.X| then			GetRoot().ExtrasDrawer:|HandleRemoved1.XPart|(inPart.packageId)		end,	InstallFormPart: func(arg1)		begin		local partFrame := arg1.partFrame;		local root := GetRoot();		local appSymbol := EnsureInternal(partFrame.app);		if root.(appSymbol) then			begin			root:Notify(kNotifyAlert, "Newton", ParamStr("An application by the name Ò^0Ó ('^1) is already installed.", [GetAppName(appSymbol), appSymbol]));			nil			end		else			begin			local installFrame := {	_proto: partFrame,											app: appSymbol,											InstallScript: EnsureInternal(if partFrame.devInstallScript	then partFrame.devInstallScript																					else if partFrame.InstallScript then partFrame.InstallScript),											RemoveScript:  EnsureInternal(if partFrame.devRemoveScript then partFrame.devRemoveScript																					else if partFrame.removeScript then partFrame.removeScript) };			if installFrame.InstallScript then				installFrame:InstallScript(installFrame);			local local5 := BuildContext(partFrame.theForm);			root.(appSymbol) := local5;			if arg1.deviceKind = 1 then				local5.cardSocket := deviceNumber;			installFrame.InstallScript := nil;			installFrame			end		end,	RemoveFormPart: func(arg1, arg2)		begin		if arg2 then			begin			arg2._proto := nil;			try				if arg2.RemoveScript then					arg2:RemoveScript(arg2)			onexception |evt.ex| do				begin				end;			local root := GetRoot();			local appSymbol := arg2.app;			try				local app := root.(appSymbol);				if app.viewCObject then					app:Close();			onexception |evt.ex| do				begin				end;			RemoveSlot(root, appSymbol)			end		end,	InstallAutoPart: func(arg1)		begin		arg1.partFrame:?InstallScript(arg1.partFrame)		end,	RemoveAutoPart: func(arg1, arg2)		begin		arg2:?RemoveScript(arg2)		end,	RestoreAPackageFromPieces: func(arg1, store)		begin		local local2, local3, local4;		local pieceArray := arg1;		local pkName := pieceArray[0].packageName;		if GetPackageEntry(pkName, store) then			Throw('|evt.ex|, -10402);		local2 := 0;		local3 := 0;		local4 := true;		foreach piece in pieceArray do			if not StrEqual(pkName, piece.packageName) then				begin				local4 := nil;				break;				end;		else if SetContains(piece._tagList, '_package) and IsVBO(piece.pkgRef) then			local2 := local2 + 1;		else if SetContains(piece._tagList, '_scriptIcon) then			local3 := local3 + 1;		if not(if local4 then			local2 = 1 or local3 = Length(pieceArray)) then			Throw('|evt.ex|, -10401);		local destSoup := GetUnionSoupAlways("Packages"):GetMember(store);		store:AtomicAction(func()			begin			foreach piece in pieceArray do				destSoup:AddFlushed(piece)			end)		end,	GetPackages: plainC.FGetPackages,	GetPackageNames: func(store)		begin		local pkgSoup := store:GetSoup("Packages");		if pkgSoup then			begin			local spec := { indexPath: 'packageName, tagspec: { all: '_package } };			local cursor := pkgSoup:Query(spec);			local pkgEntry := cursor:Entry();			local pkgNames := [];			while pkgEntry do				begin				AddArraySlot(pkgNames, cursor:EntryKey());				pkgEntry := cursor:Next()				end;			pkgNames			end		end,	GetPackageEntry: func(pkgName, store)		begin		local pkgSoup := store:GetSoup("Packages");		if pkgSoup then			begin			local spec := {indexPath: 'packageName, beginKey: pkgName, endKey: pkgName, tagspec: { all: '_package }};			pkgSoup:Query(spec):Entry()			end		end,	GetPkgRef: func(name, store)		begin		local pkgEntry := GetPackageEntry(name, store);		if pkgEntry then			pkgEntry.pkgRef		end,	GetPkgRefInfo: plainC.FGetPkgRefInfo/*pkg*/,	IsPackage: plainC.FIsPackage,	IsPackageActive: func(pkg) ObjectPid(pkg) <> nil,	IsPackageEntry: func(pkg) if IsSoupEntry(pkg) and pkg._tagList then LFetch(pkg._tagList, '_package, 0, '|=|, nil),	IsPackageEntryFrozen: func(pkg) LFetch(pkg._tagList, '_frozen, 0, '|=|, nil),	IsValid: plainC.FIsValid/*pkg*/,	ObjectPkgRef: plainC.FObjectPkgRef/*pkg*/,	XmitPackageOp: func(arg1)		begin		XmitSoupChangeNow("Packages", 'XmitPackageOp, 'whatThe, arg1)		end,	MarkPackageBusy: func(pkgRef, appName, reason)		begin		if IsPackage(pkgRef) and IsPackageActive(pkgRef) then			begin			if not reason then				reason := "This operation may cause serious problems.";			if not appName then				appName := GetPkgRefInfo(pkgRef).title;			local pkg := LFetch(busyPackages, pkgRef, 0, '|=|, 'pkgRef);			if pkg then				pkg.appName := appName			else				AddArraySlot(busyPackages, {pkgRef: pkgRef, appName: appName, reason: reason});			GetVBOStore(pkgRef):MarkBusy('_newt, appName);			true			end		end,	MarkPackageNotBusy: func(pkgRef)		begin		local pkg := LSearch(busyPackages, pkgRef, 0, '|=|, 'pkgRef);		if pkg then			begin			RemoveSlot(busyPackages, pkg);			GetVBOStore(pkgRef):MarkNotBusy('_newt);			true			end		end,	SafeMovePackage: func(pkgRef, toStore)		begin		local isMoved := SafeMovePackageQT(pkgRef, toStore);		if isMoved then			XmitPackageOp('SafeMovePackage);		isMoved		end,	SafeMovePackageQT: func(pkgRef, toStore)		begin		local entry := PackageEntryFromThingy(pkgRef);		if entry		and OKToDeactivatePackage(entry.pkgRef, entry.packageName, "Are you sure you want to move it?") then			MovePackage(entry, toStore)		end,	MovePackage: func(pkgRef, toStore)		begin		local destStore := toStore;		local entry := PackageEntryFromThingy(pkgRef);		if not entry then			return;		local oldSoup := EntrySoup(entry);		local store := EntryStore(entry);		local pkRef := entry.pkgRef;		local pkName := entry.packageName;		if GetPackageEntry(pkName, destStore) then			begin			GetRoot():Notify(3, "Newton", ParamStr("The package Ò^0Ó was not moved because a package by the same name is already installed on the store Ò^1Ó.", [pkName, destStore:GetName()]));			return;			end;		pkRef := entry.pkgRef;	// sic -- do we really need to do this again?		local isActive := IsPackageActive(pkRef);		if isActive then			DeActivatePackage(pkRef);		try			store:AtomicAction(func()				begin				destStore:AtomicAction(func()					begin					EntryMove(entry, GetUnionSoupAlways("Packages"):GetMember(destStore));					UnsafeXmitSoupChangeNow("Packages", '_newt, 'entryMoved, {oldSoup: oldSoup, entry: entry})					end)				end)		onexception |evt.ex| do			begin			if isActive then				ActivatePackage(pkRef);			Rethrow()			end;		if isActive then			ActivatePackage(entry.pkgRef);	// sic -- whatÕs wrong with pkRef?		true		end,	SafeRemovePackage: func(pkgRef)		begin		local isRemoved := SafeRemovePackageQT(pkgRef);		if isRemoved then			XmitPackageOp('SafeRemovePackage);		isRemoved		end,	SafeRemovePackageQT: func(pkgRef)		begin		local entry := PackageEntryFromThingy(pkgRef);		if entry		and OKToDeactivatePackage(entry.pkgRef, entry.packageName, "Are you sure you want to remove it?") then			RemovePackage(entry)		end,	RemovePackage: func(pkgRef)		begin		local entry := PackageEntryFromThingy(pkgRef);		if not entry then			return;		local oldSoup := EntrySoup(entry);		local store := EntryStore(entry);		local pkRef := entry.pkgRef;		local pkInfo := GetPkgRefInfo(pkRef);		foreach part in pkInfo.parts do			if IsFrame(part) and part.DeletionScript then				try					part:DeletionScript()				onexception |evt.ex| do					begin					end;		if IsPackageActive(pkRef) then			DeActivatePackage(pkRef);		store:AtomicAction(func()				begin				EntryRemoveFromSoup(entry);				UnsafeXmitSoupChangeNow("Packages", '_newt, 'entryRemoved, {oldSoup: oldSoup, entry: entry})				end);		true		end,	SafeFreezePackage: func(pkgRef)		begin		local isFrozen := SafeFreezePackageQT(pkgRef);		if isFrozen then			XmitPackageOp('SafeFreezePackage);		isFrozen		end,	SafeFreezePackageQT: func(pkgRef)		begin		local entry := PackageEntryFromThingy(pkgRef);		if entry		and OKToDeactivatePackage(entry.pkgRef, entry.packageName, "Are you sure you want to freeze it?") then			FreezePackage(entry)		end,	FreezePackage: func(inPkgRef)		begin		/* closed */ local entry := PackageEntryFromThingy(inPkgRef);		if not entry then			return;		local store := EntryStore(entry);		store:AtomicAction(func()				begin				SetAdd(entry._tagList, '_frozen, true);				EntryChange(entry);				UnsafeXmitSoupChangeNow("Packages", '|Mr.Freeze|, 'entryChanged, entry)				end);		local pkgRef := entry.pkgRef;		if IsPackageActive(pkgRef) then			DeActivatePackage(pkgRef);		true		end,	ThawPackage: func(inPkgRef)		begin		/* closed */ local entry := PackageEntryFromThingy(inPkgRef);		if not entry then			return;		local store := EntryStore(entry);		store:AtomicAction(func()				begin				SetRemove(entry._tagList, '_frozen);				EntryChange(entry);				UnsafeXmitSoupChangeNow("Packages", '|Mr.Freeze|, 'entryChanged, entry)				end);		local pkgRef := entry.pkgRef;		if not IsPackageActive(pkgRef) then			SafeActivatePackageQT(pkgRef, entry.packageName, EntryStore(entry));		XmitPackageOp('ThawPackage);		true		end,}