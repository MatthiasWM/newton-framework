{// Desktop Connection	RegDesktopConnTransport: func(sym, transport)		begin		local desktop := GetDesktopConnTransports();		desktop.transports.(sym) := transport;		EntryChangeXmit(desktop, 'whatThe);		desktop		end,	UnregDesktopConnTransport: func(sym)		begin		local desktop := GetDesktopConnTransports();		RemoveSlot(desktop.transports, sym);		EntryChangeXmit(desktop, 'whatThe);		desktop		end,	GetDesktopConnTransports: func()		GetAppPrefs('connTransports, { tag: "ConnTransports", transports: {} }),	GetOnlineEndpoint: plainC.FGetOnlineEndpoint /* funcPtr: 7035611, numArgs: 0 */,	LoadOnlinePackage: plainC.FLoadOnlinePackage /* funcPtr: 7037696, numArgs: 0 */,	SendOnline: plainC.FSendOnline /* funcPtr: 7038774, numArgs: 1 */,	SendAbort: plainC.FSendAbort /* funcPtr: 6980668, numArgs: 0 */,	CallOnlineService: plainC.FCallOnlineService /* funcPtr: 6958443, numArgs: 1 */,	CancelOnlineService: plainC.FCancelOnlineService /* funcPtr: 6966886, numArgs: 0 */,	SetOnlineDisconnect: plainC.FSetOnlineDisconnect /* funcPtr: 7038780, numArgs: 1 */,	DisconnectOnlineService: plainC.FDisconnectOnlineService /* funcPtr: 6963725, numArgs: 0 */,	ConnectPassthruKeyboard: plainC.FConnectPassthruKeyboard /* funcPtr: 504224, numArgs: 1 */,//	AutoDock	RegAutoDock: func(arg1, arg2)		begin		autoDockRegistry.(EnsureInternal(arg1)) := arg2;		nil		end,	UnRegAutoDock: func(arg1)		begin		RemoveSlot(autoDockRegistry, arg1);		nil		end,	AutoDock: func(arg1, arg2)		begin		if Length(autoDockRegistry) > 0 and GetUserConfig('autoDockOn) then			begin			if arg2 then				begin				if GlobalVarExists('autoDockSlip) then					begin					autoDockSlip:MoveBehind(nil);					autoDockSlip.dockMessage := arg1;					end				else					begin					DefGlobalVar('autoDockSlip, BuildContext(@833));					autoDockSlip.dockMessage := arg1;					autoDockSlip:Open();					end				end			else				begin				if arg1 = 'Disconnect and GlobalVarExists('autoDockSlip) then					autoDockSlip:Close();				CallFrameBasedRegistryFns(autoDockRegistry, [arg1])				end;			true			end		end,//	Backup	RegSoupBackup: func(sym, arg2)		begin		soupBackupRegistry.(EnsureInternal(sym)) := arg2;		nil		end,	UnRegSoupBackup: func(sym)		begin		RemoveSlot(soupBackupRegistry, sym);		nil		end,	RegSoupRestore: func(sym, arg2)		begin		soupRestoreRegistry.(EnsureInternal(sym)) := arg2;		nil		end,	UnRegSoupRestore: func(sym)		begin		RemoveSlot(soupRestoreRegistry, sym);		nil		end,	ConnAddChangedSoup: func(arg1, arg2, arg3, arg4)	begin		local local1, local2, local3;		if not arg1 then			return;		local1 := [pathExpr:'name];		local2 := BFind(arg1, arg2, '|str<|, local1);		if local2 then		begin			local3 := arg1[local2];			if local3.(arg3) then				(local3.(arg3) := local3.(arg3) + arg4);			else				(local3.(arg3) := arg4)		end;		else		begin			local3 := {name: arg2};			local3.(arg3) := arg4;			BInsert(arg1, local3, '|str<|, local1, true)		end	end,//	ConnImportFile: nil,//	ConnOpenFileBrowser: nil,	ConnEntriesEqual: plainC.FConnEntriesEqual /* funcPtr: 7012360, numArgs: 1 */,	ConnBuildStoreFrame: plainC.FConnBuildStoreFrame /* funcPtr: 7034546, numArgs: 2 */,	ConnSendChanges: func(arg1, arg2)		begin		local local1;		if arg1 then			begin			soups := foreach local1 in arg2 collect				local1.name;			Sort(soups, '|str<|, nil);			CallFrameBasedRegistryFns(SoupRestoreRegistry, [soups])			end		else			foreach local1 in arg2 do				XmitSoupChangeNow(local1.name, 'Connection, 'whatThe, nil)		end,	ZapPackagesForFullRestore: func(arg1)	begin		local local1, local2, local3;		local1 := GetBackupAllPackagesCursor(arg1);		if local1 then		begin			local2 := local1:entry();			while local2 do			begin				local3 := IsPackageEntry(local2) and local2.pkgRef;				EntryRemoveFromSoup(local2);				if IsPackageActive(local3) then					try					DeActivatePackage(local3)				onexception |evt.ex| do				begin				end;				local2 := local1:Next();				local2;			end		end	end,	GetBackedUpPackageNames: func(arg1)		begin		local cursor := arg1:Query({ tagspec: { any: [ '_package, '_scriptIcon ], none: '_noBackup } });		local pkg := cursor:Entry();		local pkgNames := [];		while pkg do			begin			if pkg.packageName then				BInsert(pkgNames, pkg.packageName, '|str<|, nil, true);			pkg := cursor:Next();			end;		pkgNames		end,	GetAppDataDefs: func(superSym)		begin		local defs := {};		foreach tag, def deeply in _dataDefs do			if def.superSymbol = superSym then				defs.(tag) := def;		if Length(defs) > 0 then			defs		end,	OverrideBuiltinApp: func(arg1, arg2)		begin		if arg1 = 'backupSlip then			OverrideCardSlipHack(arg2)		else			begin			local local1 := GetRoot().(arg1);			if local1 and local1.OverrideOverrideBuiltinApp then				local1:OverrideOverrideBuiltinApp(arg2);			else				GetRoot().(arg1) := arg2;			local1			end		end,	|Restore2.0SystemEntry|: func(arg1)		begin		if arg1.backupInfo = 'modelSpecific		or arg1.backupInfo = 'dontBackup then			return		else if StrEqual(arg1.tag, "Userconfiguration") then			foreach tag in [ 'lcdContrast, 'screenOrientation ] do				RemoveSlot(arg1, tag);		arg1		end,	CreateMPForBackup: func()		begin		local weights := GetLetterWeights();		if weights then			begin			if IsArray(weights) then				weights := weights[userConfiguration.letterSetSelection];			weights := ConvertForMP(weights, userConfiguration.letterSetSelection);			SaveDataToEntry(weights, "LetterWeights")			end		end,	RestoreAPackageFromBackup: func(pkgName, arg2, arg3)		begin		local cursor := arg2:Query({indexPath: 'packageName, beginKey: pkgName, endKey: pkgName});		RestoreAPackageFromPieces(MapCursor(cursor, nil), arg3)		end,	BackupPatchPackage: plainC.FBackupPatchPackage /* funcPtr: 7017649, numArgs: 0 */,	RestorePatchPackage: plainC.FRestorePatchPackage /* funcPtr: 7018705, numArgs: 1 */,	GetBackupAllPackagesCursor: func(store)		begin		local pkgSoup := store:GetSoup("Packages");		if pkgSoup then			pkgSoup:Query({ tagspec: { none: '_noBackup } })		end,}