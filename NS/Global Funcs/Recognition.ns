// User Configurationconstant kUserOptions := '[	letterSetSelection,	lineAtATime,	letterSpaceCursiveOption,	speedCursiveOption,	timeoutCursiveOption,	wordsCursiveOption,	lettersCursiveOption,	lettersInFieldsOption,	numbersCursiveOption,	punctuationcursiveoption,	remoteWriting,	inkWordScaling,	doAutoAdd,	learningEnabledOption ];{// Dictionary	NewDictionary: func(dictKind)		begin		local dict := { _proto: @171 };		dict:Initialize(15, 1);		dict.status := 0;		dict.custom := dictKind;		dict:Register()		end,	DisposeDictionary: func(dictId)		begin		local dict := GetDictionary(dictId);		dict:Unregister();		dict:Dispose();		nil		end,	AddWordToDictionary: func(dictId, word)		begin		local dict := GetDictionary(dictId);		local result := dict:AddEncodedWord(word, nil);		result = 0		end,	DeleteWordFromDictionary: func(dictId, word)		begin		local dict := GetDictionary(dictId);		local result := dict:DeleteEncodedWord(word);		result = 0		end,	GetRandomWord: plainC.FGetRandomWord /* funcPtr: 7036644, numArgs: 2 */,	GetRandomDictionaryWord: plainC.FGetRandomDictionaryWord /* funcPtr: 7036643, numArgs: 2 */,	LookupWord: plainC.FLookupWord /* funcPtr: 6967955, numArgs: 1 */,	LookupWordInDictionary: func(dictId, word)		begin		if dictId = 7 or dictId = 1 or dictId = 42 then			dictId := 6;		if dictId = 43 or dictId = 44 then			dictId := 26;		if dictId = 2 then			dictId := 3;		if dictId = 41 then			dictId := 24;		local dict := GetDictionary(dictId);		local result := dict:LookupEncodedWord(word);		if not (result = 2 or result = 3) and dictId = 0 then			begin			dict := GetDictionary(6);			result := dict:LookupEncodedWord(word);			if not (result = 2 or result = 3) then				begin				dict := GetDictionary(3);				result := dict:LookupEncodedWord(word)				end			end;		return result = 2 or result = 3		end,	GetDictionaryData: plainC.FGetDictionaryData/*dictId*/,	SetDictionaryData: plainC.FSetDictionaryData/*dictId, data*/,	ConvertDictionaryData: plainC.FConvertDictionaryData/*dictId*/,	LoadDictionary: func(dictId, arg2)		begin		local local1, local2, local3, local4, local5, local6, local7;		/* closed */ local tag;		tag := arg2;		local1 := func(arg1)			begin			StrCompare(arg1.tag, tag) <> 0			end;		local2 := {type: 'index, indexPath: 'tag, startKey: tag, endTest: local1};		local3 := GetStores()[0]:GetSoup(@276);		local4 := Query(local3, local2):entry();		if local4 then			begin			SetDictionaryData(dictId, local4.data);			if local4.custom exists and local4.custom then				begin				local5 := GetDictionary(dictId);				foreach local6, local7 in local4.custom do					local5.(local6) := local4.custom.(local6)				end			end		end,	SaveDictionary: func(dictId, arg2, arg3)		begin		local local1, local2, local3, local4, local5, local6, local8;		/* closed */ local tag;		tag := arg2;		local1 := func(arg1)			begin			StrCompare(arg1.tag, tag) <> 0			end;		local2 := {type: 'index, indexPath: 'tag, startKey: tag, endTest: local1};		local3 := GetStores()[0]:GetSoup(@276);		local4 := Query(local3, local2):entry();		if local4 = nil then			begin			local4 := {tag: tag, data: nil, custom: Clone(arg3)};			AddToSysSoup(local4);			end		else			begin			local4.data := nil;			if local4.custom exists and local4.custom then				foreach local5, local6 in local4.custom do					local4.custom.(local5) := nil;			end;		local4.data := GetDictionaryData(dictId);		if arg3 then			begin			if not local4.custom exists or not local4.custom then				local4.custom := Clone(arg3);			local8 := GetDictionary(dictId);			foreach local5, local6 in arg3 do				local4.custom.(local5) := local8.(local5);			end;		try			EntryChange(local4)		onexception |evt.ex| do			begin			EntryUndoChanges(local4);			local3 := local8 := local4 := local2 := local1 := nil;			GC();			LoadDictionary(dictId, tag);			Rethrow()			end		end,	GetDictionary: plainC.FGetDictionary /* funcPtr: 7017658, numArgs: 1 */,	AddDictionary: plainC.FAddDictionary /* funcPtr: 7325243, numArgs: 2 */,//	GetDictItem: plainC.FGetDictItem /* funcPtr: 6874920, numArgs: 1 */,//	DumpDict: plainC.FDumpDict /* funcPtr: 6873882, numArgs: 0 */,// User Dictionary (reviewDict)	LoadUserDictionary: func()		begin		LoadDictionary(31, "UserDictionary")		end,	SaveUserDictionary: func()		begin		local local1 := { count: 0 };		local dict := GetDictionary(31);		dict.count := dict:Walk("", nil);		SaveDictionary(31, "UserDictionary", local1)		end,	AddToUserDictionary: func(word)		begin		AddWordToDictionary(31, word)		end,	RemoveFromUserDictionary: func(word)		begin		DeleteWordFromDictionary(31, word)		end,	ConvertUserDictionary: func()		begin		ConvertDictionary(31)		end,	LoadExpandDictionary: func()		begin		LoadDictionary(35, "ExpandDictionary")		end,	SaveExpandDictionary: func()		begin		local local1 := { list: [], count: 0 };		local dict := GetDictionary(35);		dict.count := dict:Walk("", nil);		SaveDictionary(35, "ExpandDictionary", local1)		end,// Auto-Add Dictionary	LoadAutoAddDictionary: func()		begin		LoadDictionary(36, "AutoAdd")		end,	SaveAutoAddDictionary: func()		begin		local local1 := { count: 0 };		local dict := GetDictionary(36);		dict.count := dict:Walk("", nil);		SaveDictionary(36, "AutoAdd", local1)		end,	AddAutoAdd: plainC.FAddAutoAdd/*word*/,	RemoveAutoAdd: plainC.FRemoveAutoAdd/*word*/,// User Configuration	SetDefaultUserSettings: func()		begin		userConfiguration.letterSetSelection := 0;		ResetLetterDefaults();		foreach option in kUserOptions do			RemoveSlot(userConfiguration, option);		SetRemoteWriting(GetRemoteWriting());		ReadCursiveOptions()		end,	SetUserSettings: func(settings)		begin		userConfiguration.letterSetSelection := 0;		ReadCursiveOptions();		SetLetterWeights(settings.letterWeights);		foreach option in kUserOptions do			if HasSlot(settings, option) then				userConfiguration.(option) := settings.(option);		ReadCursiveOptions()	end,	GetUserSettings: func()		begin		local settings := {};		local letSetSel := userConfiguration.letterSetSelection;		userConfiguration.letterSetSelection := 0;		loadLetterWeights();		userConfiguration.letterSetSelection := letSetSel;		settings.letterWeights := GetLetterWeights();		foreach option in kUserOptions do			settings.(option) := userConfiguration.(option);		return settings		end,//	protoCharEdit	MapAmbiguousCharacters: func(str)		begin		local last1 := StrLen(str) - 1;		for i := 0 to last1 do			begin			local ch := str[i];			if ch = $0 then				str[i] := $\uF714			else if ch = $I then				str[i] := $\uF715			else if ch = $l then				str[i] := $\uF716			end		end,	UnmapAmbiguousCharacters: func(str)		begin		local last1 := StrLen(str) - 1;		for i := 0 to last1 do			begin			local ch := str[i];			if ch = $\uF714 then				str[i] := $0			else if ch = $\uF715 then				str[i] := $I			else if ch = $\uF716 then				str[i] := $l			end		end,	SpellLearn: func(arg1, arg2)	begin		local local1, local2, local3, local4, local5, local6, local7, local8, local9, local10;		local2 := Clone(arg2);		local3 := StripRecognitionWord(local2);		TrimTruncatedString(local2);		local4 := StrExactCompare(arg2, Upcase(Clone(arg2))) = 0;		local5 := BAnd(local3, 128) <> 0;		if local4 or local5 then			(local2[0] := Upcase(local2[0]));		local6 := SpellCheck(arg1, local2);		if local6 then		begin			if not arg1.dialogInhibit then			begin				if local4 then					(local7 := ParamStr("Should '^0' always be all upper-case?", [local2]));				else (if local5 then					(local7 := ParamStr("Should '^0' always be capitalized?", [local2])));				if local7 then					(if not ModalConfirm(local7, 'yesNo) then					(local2 := Downcase(local2)));			end;			local8 := GetDictionary(31);			local9 := local8.count < local8.limit;			if local9 then			begin				local8:AddEncodedWord(local2, true);				arg1.saveUserDict := true;				local1 := local2;			end;			if local8.count >= local8.limit and not arg1.dialogInhibit then			begin				local10 := "You will need to remove some words before more can be learned.  Would you like to open it now?";				if local9 then					(local7 := "The Personal word list is now full.");				else					(local7 := ParamStr("The word '^0' was not added because the Personal word list is full.", [local2]));				if ModalConfirm(local7 && local10, 'yesNo) then					GetRoot().reviewDict:Open();			end;		end;		local1	end,	SpellUnlearn: func(arg1, arg2)	begin		local local1;		if arg2 then		begin			local1 := GetDictionary(31);			local1:DeleteEncodedWord(arg2);			arg1.saveUserDict := true;		end;		nil	end,//	Recognition	GetPoint: plainC.FGetPoint /* selector, unit */,	GetPointsArray: plainC.FGetPointsArray /* unit */,	GetPointsArrayXY: plainC.FGetPointsArrayXY /* unit */,	GetScoreArray: plainC.FGetScoreArray /* unit */,	CountGesturePoints: plainC.FCountGesturePoints /* unit */,	GesturePoint: plainC.FGesturePoint /* index, unit */,	GestureType: plainC.FGestureType /* unit */,	ModalRecognitionOn: plainC.FModalRecognitionOn /* inArea */,	ModalRecognitionOff: plainC.FModalRecognitionOff,//	Deferred Recognition	Recognize: plainC.FRecognize /* funcPtr: 6996500, numArgs: 3 */,	RecognizeInkWord: plainC.FRecognizeInkWord /* funcPtr: 7051487, numArgs: 1 */,	RecognizePara: plainC.FRecognizePara /* funcPtr: 6996501, numArgs: 5 */,	RecognizePoly: plainC.FRecognizePoly /* funcPtr: 6996502, numArgs: 3 */,//	CorrectInfo	NewCorrectInfo: func()		begin		local correctInfo := Clone(@614);		correctInfo.info := [];		correctInfo		end,	GetCorrectInfo: func() GetGlobalVar('correctInfo),//	GetCorrectionWordInfo: plainC.FGetCorrectionWordInfo,//	Inker	InkOff: plainC.FInkOff,	InkOffUnHobbled: plainC.FInkOffUnHobbled,	InkOn: plainC.FInkOn,	SetInkerPenSize: plainC.FSetInkerPenSize,//	Strokes	BlockStrokes: plainC.FBlockStrokes /* funcPtr: 7017650, numArgs: 0 */,	UnblockStrokes: plainC.FUnblockStrokes /* funcPtr: 7018718, numArgs: 0 */,	CompressStrokes: plainC.FCompressStrokes /* funcPtr: 6995436, numArgs: 1 */,	CompressStrokesToInk: plainC.FCompressStrokesToInk /* funcPtr: 6995437, numArgs: 1 */,	CountPoints: plainC.FCountPoints /* funcPtr: 6995439, numArgs: 1 */,	CountStrokes: plainC.FCountStrokes /* funcPtr: 6995440, numArgs: 1 */,	CountUnitStrokes: plainC.FCountUnitStrokes /* funcPtr: 7012378, numArgs: 1 */,	ExpandInk: plainC.FExpandInk /* funcPtr: 6995442, numArgs: 2 */,	ExpandUnit: plainC.FExpandUnit /* funcPtr: 6995443, numArgs: 1 */,	FlushStrokes: plainC.FFlushStrokes /* funcPtr: 7017661, numArgs: 0 */,	GetStroke: plainC.FGetStroke /* funcPtr: 6996480, numArgs: 2 */,	GetStrokeBounds: plainC.FGetStrokeBounds /* funcPtr: 6996481, numArgs: 1 */,	GetStrokePoint: plainC.FGetStrokePoint /* funcPtr: 6996482, numArgs: 4 */,	GetStrokePointsArray: plainC.FGetStrokePointsArray /* funcPtr: 6996483, numArgs: 2 */,	InkConvert: plainC.FInkConvert /* funcPtr: 6996486, numArgs: 2 */,	MakeStrokeBundle: plainC.FMakeStrokeBundle /* funcPtr: 6996489, numArgs: 2 */,	MergeInk: plainC.FMergeInk /* funcPtr: 6996491, numArgs: 2 */,	MergeStrokes: plainC.FMergeStrokes /* funcPtr: 7018693, numArgs: 2 */,	PointsArrayToStroke: plainC.FPointsArrayToStroke /* funcPtr: 6996496, numArgs: 2 */,	SplitInkAt: plainC.FSplitInkAt /* funcPtr: 6996508, numArgs: 3 */,	StrokeBundleToInkWord: plainC.FStrokeBundleToInkWord /* funcPtr: 6996510, numArgs: 1 */,	StrokesAfterUnit: plainC.FStrokesAfterUnit /* funcPtr: 6996511, numArgs: 2 */,	StrokeBounds: plainC.FStrokeBounds /* funcPtr: 7039832, numArgs: 1 */,	StrokeDone: plainC.FStrokeDone /* funcPtr: 7039833, numArgs: 1 */,	AnimateSimpleStroke: plainC.FAnimateSimpleStroke /* funcPtr: 7041939, numArgs: 3 */,	RosettaExtension: plainC.FRosettaExtension /* funcPtr: 7200485, numArgs: 2 */,	UseWRec: plainC.FUseWRec /* funcPtr: 6997539, numArgs: 1 */,	WRecIsBeingUsed: plainC.FWRecIsBeingUsed /* funcPtr: 6997543, numArgs: 0 */,	ReadCursiveOptions: plainC.FReadCursiveOptions /* funcPtr: 6967963, numArgs: 0 */,	ReadDomainOptions: plainC.FReadDomainOptions /* funcPtr: 6978517, numArgs: 0 */,	GetTrainingData: plainC.FGetTrainingData /* funcPtr: 7036646, numArgs: 1 */,	GetLearningData: plainC.FGetLearningData /* funcPtr: 7042994, numArgs: 0 */,	SetLearningData: plainC.FSetLearningData /* funcPtr: 7042999, numArgs: 1 */,	SetupReplayConfiguration: func(letterSet)		begin		userConfiguration.doShapeRecognition := nil;		userConfiguration.SleepTime := nil;		userConfiguration.letterSetSelection := letterSet;		ReadCursiveOptions();		ReadDomainOptions();		RefreshViews()		end,	ExpandSettings: func(arg1)		begin		if IsFrame(arg1) then			return arg1.settings;		local settings := Clone({	_proto: nil,											doTextRecognition: nil,											doShapeRecognition: nil,											doInkWordRecognition: nil,											wordsCursiveOption: nil,											numbersCursiveOption: nil });		if BAnd(arg1, 32) <> 0 then			settings.doTextRecognition := true;		if BAnd(arg1, 128) <> 0 then			settings.doShapeRecognition := true;		if BAnd(arg1, 64) <> 0 then			settings.doInkWordRecognition := true;		if BAnd(arg1, 256) <> 0 then			settings.wordsCursiveOption := true;		if BAnd(arg1, 512) <> 0 then			settings.numbersCursiveOption := true;		return settings		end,	RecognitionInkWordWarning: func(arg1)		begin		if userConfiguration.letterSetSelection = 2 then			begin			local cbFn := functions.AsyncConfirm;			local args := [	"Words are being left as ink because you are connecting or overlapping letters.  "									"When using the Printing recognition setting, be careful not to connect letters.  "									"The Cursive setting permits joined letters.",									["OK"],									func(arg1) begin nil end ];			if arg1 then				GetRoot().notifyIcon:AddAction("Recognition Warning", cbFn, args);			else				AddDeferredCall(cbFn, args)			end		end,	RecognitionMemoryWarning: func(arg1)		begin		local cbFn := func()			begin			FlushUserConfig();			AsyncConfirm(	"Words are being left as ink due to a shortage of memory.  "								"If you have multiple applications or connections open, closing some of them may help.  "								"If you continue to have problems, you should restart your Newton device.",								["OK", "Restart"],								func(arg1) begin if arg1 = 1 then AddDeferredCall(functions.ReBoot, nil) end )			end;		if arg1 then			GetRoot().notifyIcon:AddAction("Recognition Warning", cbFn, nil);		else			AddDeferredCall(cbFn, nil)	end,	TryLettersNeeded: func(arg1, arg2)		begin		constant kWhatsAllowed := vCustomDictionaries + vNameField + vAddressField + vLettersAllowed + vCharsAllowed;		if arg2.strokes and arg2:TestFlags(2) and StrEqual("XRWR", userConfiguration.currentwordrecognizer) then			begin			if BAnd(arg1.viewFlags, vWordsAllowed) <> 0 then				return BAnd(arg1.viewFlags, kWhatsAllowed) <> 0;			arg1 := arg1:Parent();			if BAnd(arg1.viewFlags, vWordsAllowed) <> 0 then				return BAnd(arg1.viewFlags, kWhatsAllowed) <> 0;			arg1 := arg1:Parent();			if BAnd(arg1.viewFlags, vWordsAllowed) <> 0 then				return BAnd(arg1.viewFlags, kWhatsAllowed) <> 0;			end		end,	CorrectWord: plainC.FCorrectWord /* funcPtr: 6991224, numArgs: 2 */,	PenPos: plainC.FPenPos,	PrepRecConfig: plainC.FPrepRecConfig /* inView */,	BuildRecConfig: plainC.FBuildRecConfig /* inView */,	RecSettingsChanged: plainC.FRecSettingsChanged /* funcPtr: 7018702, numArgs: 0 */,	loadLetterWeights: @119,	saveLetterWeights: @252,	ConvertForMP: plainC.FConvertForMP /* funcPtr: 7042989, numArgs: 2 */,	ConvertFromMP: plainC.FConvertFromMP /* funcPtr: 7042990, numArgs: 2 */,	GetLetterWeights: plainC.FGetLetterWeights /* funcPtr: 7042996, numArgs: 0 */,	ResetLetterDefaults: plainC.FResetLetterDefaults /* funcPtr: 7042998, numArgs: 0 */,	SetLetterWeights: plainC.FSetLetterWeights /* funcPtr: 7043000, numArgs: 1 */,	ConvertLetterWeights: func()	begin		local local1, local2;		local1 := GetTaggedEntry("LetterWeights2.0");		if local1 = nil then			(local2 := ConvertMPLetterWeights());		if local2 then			SetLetterWeights(local2);		DeleteMPLetterWeights()	end,	ConvertMPLetterWeights: func()	begin		local local1, local2;		local1 := GetTaggedEntry("LetterWeights");		if local1 then		begin			local2 := ConvertFromMP(local1.data, userConfiguration.letterSetSelection);			SaveDataToEntry(local2, "LetterWeights2.0");		end;		local2	end,	DeleteMPLetterWeights: func()	begin		local local1 := GetTaggedEntry("LetterWeights");		if local1 then			EntryRemoveFromSoup(local1)	end,	DoCursiveTraining: plainC.FDoCursiveTraining /* funcPtr: 7034554, numArgs: 2 */,	UseLargeLearningData: func(arg1)	begin		local local1 := userConfiguration.letterSetSelection;		if local1 <> 2 then		begin			userConfiguration.letterSetSelection := 2;			ReadCursiveOptions();		end;		userConfiguration.bigLearningEnabled := arg1;		ReadCursiveOptions();		if local1 <> 2 then		begin			userConfiguration.letterSetSelection := local1;			ReadCursiveOptions()		end	end,	UseTrainingDataForRecognition: plainC.FUseTrainingDataForRecognition /* funcPtr: 7044043, numArgs: 1 */,	DisposeTrainingData: plainC.FDisposeTrainingData /* funcPtr: 7034553, numArgs: 1 */,	TriggerWordRecognition: plainC.FTriggerWordRecognition /* funcPtr: 7043001, numArgs: 0 */,	DoCorrection: func(arg1, arg2, arg3, arg4)		begin		local local1, local2, local3, local4, local5, local6;		local1 := GetRoot().currentKeyboard;		local2 := GetRoot().correct;		if local1 and local1 <> local2 then			arg1:SetHiliteNoUpdate(arg2, arg2 + arg3, true);		else (if arg1.text exists then			(if StrLen(GetDynamicValue(arg1, 'text, 'string)) = 0 then				OpenKeypadFor(arg1);			else				begin				local3 := Clone(@167);				local3.form := arg1;				local3.wordOffset := arg2;				local3.wordLength := arg3;				local4 := Clone(@30);				local4.bounds := arg4;				local4.refCon := local3;				local5 := correctInfo:FindNew(arg1, arg2, arg3);				local4.wordInfo := local5;				local6 := local5:GetWords();				local4.pickItems := local6;				if not arg1:?viewCorrectionPopupScript(local4) then					begin					local4 := BuildContext(local4);					local4:Open()					end				end))		end,}