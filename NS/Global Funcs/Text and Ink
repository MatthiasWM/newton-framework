{//	Text and Ink Input and Display	IsInk: func(ch) ch = $\uF701,//	IsInkChar: plainC.FIsInkChar,	NotesText: func(childArray)		begin		local theText := "";		if childArray then			begin			local textChildren := [];		//	Build array of children that contain text			for i := 0 to Length(childArray) - 1 do				begin				local child := childArray[i];				if HasSlot(child, 'text) then					AddArraySlot(textChildren, child)				else if HasSlot(child, 'realData) then					AddArraySlot(textChildren, child.realData)				end;		//	Ensure text children are in top-down left-right order			local tmp;			for i := 0 to Length(textChildren) - 2 do				for j := Length(textChildren) - 1 to i + 1 by -1 do					if textChildren[i].viewBounds.top > textChildren[j].viewBounds.top then						begin						tmp := textChildren[j];						textChildren[j] := textChildren[i];						textChildren[i] := tmp						end					else if textChildren[i].viewBounds.top = textChildren[j].viewBounds.top						 and textChildren[i].viewBounds.left > textChildren[j].viewBounds.left then						begin						tmp := textChildren[j];						textChildren[j] := textChildren[i];						textChildren[i] := tmp;						end;		//	Build text string			for i := 0 to Length(textChildren) - 1 do				begin				local str := MakeRichString(textChildren[i].text, textChildren[i].styles);				if str then					theText := StrConcat(theText, str);				theText := StrConcat(theText, "\n");				end			end;		theText		end,//	Measuring Text Views//	TextBounds: plainC.FTextBounds,	TotalTextBounds: func(paraSpec, editSpec)		begin		DefineGlobalConstant('kRef421835,			{	viewClass: 0x4D,				viewFlags: 0x8000000,				viewFormat: vfNone,				viewBounds: SetBounds(0, 0, 0, 0),				ReOrientToScreen: ROM_DefRotateFunc });			local local1, local4, local5, local6;		local1 := {_proto: {	viewClass: 0x51,									viewFormat: vfNone,									viewFlags: 0x8000008 } };		foreach tag in '[ text, styles, viewBounds, viewFont, textFlags, recConfig, viewLineSpacing ] do			if paraSpec.(tag) then				local1.(tag) := paraSpec.(tag);		if paraSpec.viewFlags then			local1.viewFlags := BOr(BAnd(paraSpec.viewFlags, -2), 134217736);		if paraSpec.textFlags then			local1.textFlags := BAnd(paraSpec.textFlags, 56);		local4 := kRef421835;		if editSpec then			begin			local4 := {_proto: kRef421835};			foreach tag in [ textFlags, recConfig, viewLineSpacing ] do				if editSpec.(tag) then					local4.(tag) := editSpec.(tag);			if editSpec.viewFlags then				local4.viewFlags := BOr(BAnd(editSpec.viewFlags, -2), 134217728);			end;		local view := BuildContext(local4);		view:Open();		local6 := AddView(view, local1);		view:Close();		local6.viewBounds		end,//	Determining View Ink Types//	AddInk: plainC.FAddInk,//	ViewAllowsInk: plainC.FViewAllowsInk,//	ViewAllowsInkWords: plainC.FViewAllowsInkWords,//	Font Attributes//	FontAscent: plainC.FFontAscent,//	FontDescent: plainC.FFontDescent,//	FontHeight: plainC.FFontHeight,//	FontLeading: plainC.FFontLeading,//	GetDefaultFont: plainC.FGetDefaultFont,//	GetFontFace: plainC.FGetFontFace,//	GetFontFamilyNum: plainC.FGetFontFamilyNum,//	GetFontFamilySym: plainC.FGetFontFamilySym,//	GetFontSize: plainC.FGetFontSize,//	MakeCompactFont: plainC.FMakeCompactFont,//	SetFontFace: plainC.FSetFontFace,//	SetFontFamily: plainC.FSetFontFamily,//	SetFontParms: plainC.FSetFontParms,//	SetFontSize: plainC.FSetFontSize,	MakeFontMenu: func(arg1, arg2, arg3, arg4)	begin		local local1, local2, local3, local6, local7, local8, local9, local10, local11;		if IsArray(arg1) then			begin			local2 := GetFontFamilySym(arg1[0]);			foreach local3 in arg1 do				if local2 <> GetFontFamilySym(local3) then					begin					local2 := nil;					break					end			end		else			local2 := GetFontFamilySym(arg1);		local items := [];		if arg2 <> 'none then			begin			local6 := GetFontNameItems(local2, arg2);			ArrayMunger(items, Length(items), 0, local6, 0, nil);			local1 := true			end;		if arg3 <> 'none then			begin			if IsArray(arg1) then				begin				local7 := GetFontSize(arg1[0]);				foreach local3 in arg1 do					if local7 <> GetFontSize(local3) then						begin						local7 := nil;						break						end				end			else if arg1 then				local7 := GetFontSize(arg1);			if IsArray(arg1) then				begin				arg3 := [];				foreach local3 in arg1 do					begin					local8 := GetFontFamilySym(local3);					arg3 := SetUnion(arg3, fonts.(local8).userSizes, true);					end;				Sort(arg3, '|<|, nil);				end			else if local2 and not arg3 then				arg3 := fonts.(local2).userSizes;			local9 := GetFontSizeItems(local7, arg3);			if local1 then				AddArraySlot(items, 'pickseparator)			else				local1 := true;			ArrayMunger(items, Length(items), 0, local9, 0, nil);			end;		if arg4 <> 'none then			begin			if IsArray(arg1) then				begin				local10 := GetFontFace(arg1[0]);				foreach local3 in arg1 do					if local10 <> GetFontFace(local3) then						begin						local10 := nil;						break						end				end			else if arg1 then				local10 := GetFontFace(arg1);			local11 := GetFontStyleItems(local10, arg4);			if local1 then				AddArraySlot(items, 'pickseparator);			ArrayMunger(items, Length(items), 0, local11, 0, nil);			end;		items		end,	GetAllFonts: func()		begin		local fnts := [];		foreach fnt deeply in fonts do			if fnt.usable exists and fnt.usable or not fnt.usable exists then			AddArraySlot(fnts, fnt);		fnts		end,	GetAllFontFamilies: func()		begin		local families := [];		foreach tag, fnt deeply in fonts do			if fnt.usable exists and fnt.usable or not fnt.usable exists then				AddArraySlot(families, tag);		families		end,	GetFontNameItems: func(curFamily, names)	begin		if not names then			names := GetAllFontFamilies();		else if names = 'all then			begin			names := [];			foreach tag, fnt deeply in fonts do				AddArraySlot(names, tag);			end;		if IsInteger(curFamily) then			curFamily := GetFontFamilySym(curFamily);		local items := [];		foreach family in names do			begin			local menuItem := {item: fonts.(family).name, family: family};			if curFamily = family then				menuItem.mark := kCheckMarkChar;			AddArraySlot(items, menuItem);			end;		Sort(items, '|str<|, 'item);		items	end,	GetFontSizeItems: func(curSize, sizes)		begin		if not sizes or Length(sizes) = 0 then			sizes := [ 9, 10, 12, 18 ];		local items := [];		foreach index, size in sizes do			begin			local item;			if index = 0 then				item := ParamStr("^0 point", [size])			else				item := SPrintObject(size);			local menuItem := { item: item, size: size };			if curSize = size then				menuItem.mark := kCheckMarkChar;			AddArraySlot(items, menuItem);		end;		items	end,	GetFontStyleItems: func(arg1, arg2)		begin		local local1, local2, local4, local5;		if not arg2 then			(arg2 := 15);		local1 := [];		foreach local2 in @855 do		begin			local4 := local2.face;			if BAnd(local4, arg2) = local4 then			begin				local5 := local2;				if not arg1 then				begin				end;				else (if arg1 = 0 and local4 = 0 or (arg1 > 0 and local4 > 0 and BAnd(local4, arg1) = local4) then				begin					local5 := Clone(local5);					local5.mark := kCheckMarkChar;				end);				AddArraySlot(local1, local5);			end;		end;		local1		end,//	Rich Strings//	DecodeRichString: plainC.FDecodeRichString,	IsRichString: plainC.FIsRichString,//	MakeRichString: plainC.FMakeRichString,//	StripInk: plainC.FStripInk,//	Accessing Ink in Views//	GetInkAt: plainC.FGetInkAt,//	NextInkIndex: plainC.FNextInkIndex,//	ParaContainsInk: plainC.FParaContainsInk,//	PolyContainsInk: plainC.FPolyContainsInk,//	Keyboard	GetCaretBox: plainC.FGetCaretBox,	KeyIn: plainC.FKeyIn,	PostKeyString: plainC.FPostKeyString,	GetKeyView: plainC.FGetKeyView,	SetKeyView: plainC.FSetKeyView,	NextKeyView: plainC.FNextKeyView,	RestoreKeyView: plainC.FRestoreKeyView,	OpenKeypadFor: func(view)		begin		RefreshViews();		local root := GetRoot();		local keypad := root.alphaKeyboard;		if view then			begin			if view._keyboard then				keypad := view._keyboard			else				begin				local flags := BAnd(view.viewFlags, 33550336);				if flags = 262144 then					keypad := root.phoneKeyboard				else if flags = 524288 or flags = 1048576 then					keypad := root.dateKeyboard				else if flags = 8192 then					keypad := root.numericKeyboard				else if flags = 16777216 then					begin					local dict := view.dictionaries;					if IsArray(dict) and Length(dict) = 1 then						dict := dict[0];					if dict = 117 then						keypad := root.numericKeyboard;					end				end			end;		if keypad.viewCObject then			keypad:MoveBehind(nil)		else			keypad:Open()		end,	KeyboardConnected: plainC.FKeyboardConnected,	CommandKeyboardConnected: plainC.FCommandKeyboardConnected,	PickViewKeyDown: plainC.FPickViewKeyDown /* funcPtr: 7050417, numArgs: 2 */,	IsKeyDown: plainC.FIsKeyDown /* funcPtr: 7052534, numArgs: 2 */,	TranslateKey: plainC.FTranslateKey /* funcPtr: 7052536, numArgs: 3 */,	IsCommandKeystroke: plainC.FIsCommandKeystroke /* funcPtr: 7053584, numArgs: 2 */,	FindKeyCommand: plainC.FFindKeyCommand /* funcPtr: 7053572, numArgs: 3 */,	SendKeyMessage: plainC.FSendKeyMessage /* funcPtr: 7053574, numArgs: 2 */,	MatchKeyMessage: plainC.FMatchKeyMessage /* funcPtr: 7053575, numArgs: 2 */,	GatherKeyCommands: plainC.FGatherKeyCommands /* funcPtr: 7053578, numArgs: 1 */,	CategorizeKeyCommands: plainC.FCategorizeKeyCommands /* funcPtr: 7053581, numArgs: 1 */,	HandleKeyEvents: plainC.FHandleKeyEvents /* funcPtr: 7053590, numArgs: 1 */,	InRepeatedKeyCommand: plainC.FInRepeatedKeyCommand /* funcPtr: 7054645, numArgs: 0 */,	ClearHardKeymap: plainC.FClearHardKeymap /* funcPtr: 7054648, numArgs: 0 */,	GetTrueModifiers: plainC.FGetTrueModifiers /* funcPtr: 7054649, numArgs: 0 */,//	Insertion Caret	GetRemoteWriting: plainC.FGetRemoteWriting /* funcPtr: 505927, numArgs: 0 */,	SetRemoteWriting: plainC.FSetRemoteWriting /* funcPtr: 505914, numArgs: 1 */,	GetCaretInfo: plainC.FGetCaretInfo /* funcPtr: 7027164, numArgs: 0 */,	SetCaretInfo: plainC.FSetCaretInfo /* funcPtr: 7028198, numArgs: 2 */,	ShowCaret: plainC.FShowCaret /* funcPtr: 507098, numArgs: 0 */,	HideCaret: plainC.FHideCaret /* funcPtr: 507107, numArgs: 0 */,	InsertItemsAtCaret: plainC.FInsertItemsAtCaret /* funcPtr: 7028194, numArgs: 1 */,	ViewContainsCaretView: plainC.FViewContainsCaretView /* funcPtr: 7051480, numArgs: 1 */,	GetInkWordInfo: plainC.FGetInkWordInfo /* funcPtr: 6995453, numArgs: 1 */,//	Tablet	IsTabletCalibrationNeeded: plainC.FIsTabletCalibrationNeeded,	CalibrateTablet: plainC.FCalibrateTablet,	GetCalibration: plainC.FGetCalibration,	SetCalibration: plainC.FSetCalibration /* funcPtr: 6968992, numArgs: 1 */,	VerifyCalibration: func()		begin		local calibInfo := call func()			begin			local calibrationEntry;			local internalStore := GetStores()[0];			if internalStore:HasSoup(ROM_systemSoupName) then				begin				local systemSoup := internalStore:GetSoup(ROM_systemSoupName);				calibrationEntry := systemSoup:Query({type: 'index, indexPath: 'tag, beginKey: "Calibration", endKey: "Calibration"}):entry();				if calibrationEntry and IsTabletCalibrationNeeded() then					begin					calibrationEntry.rotated := Array(4, nil);					EntryChange(calibrationEntry);					end				end;			calibrationEntry			end with ();		if calibInfo then			begin			if not calibInfo.rotated then				calibInfo.rotated := Array(4, nil);			local calibData := calibInfo.rotated[userConfiguration.screenOrientation];			if not calibData then				begin				CalibrateTablet();				calibData := GetCalibration();				end;			SetCalibration(calibData)			end		end,	TabletBufferEmpty: plainC.FTabletBufferEmpty,	InsertTabletSample: plainC.FInsertTabletSample/*x,y,type,time*/,	StartBypassTablet: plainC.FStartBypassTablet,	StopBypassTablet: plainC.FStopBypassTablet,	HobbleTablet: plainC.FHobbleTablet,}