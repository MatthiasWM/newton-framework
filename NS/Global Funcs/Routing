{// Routing Interface	Send: func(transportSym, item)		begin		if transportSym = nil then			return;		if item = nil then			return TransportNotify(transportSym, 'CheckOutBox, []);		if item.hidden and not item.completionScript then			item.hidden := nil;		if item.printerFormat then			item.currentFormat := item.printerFormat;		if transportSym = 'mail and item.email and item.toRef = nil then			begin			local nameDef := GetDataDefs('|nameRef.email|);			local addrList := StrParseTrimmed(item.email, ",");			item.toRef := [];			foreach addr in addrList do				AddArraySlot(item.toRef, nameDef:MakeNameRef({name: addr, email: SetClass(addr, '|string.email|)}, '|nameRef.email|))			end		else if transportSym = 'fax then			begin			if item.toRef = nil then				item.toRef := [{name: {last: item.name}, phone: itemitem.phoneNumber, country: "USA", asIsPhone: item.phoneNumber}];			if item.hasCoverPage exists then				item.coverPage := if item.hasCoverPage then 'standard			end;		local groupSym := GetGroupTransport(transportSym);		if groupSym then			transportSym := groupSym;		local transport := GetRoot().(transportSym);		if transport then			begin			item := Clone(item);			local xItem := transport:NewItem(nil);			if xItem then				begin				foreach tag, value in item do					xItem.(tag) := value;				if xItem.state = nil then					xItem.state := 'ready;				if xItem.currentFormat = nil and not TargetIsCursor(xItem) then					begin					local fmt := GetCurrentFormat(xItem);					if fmt then						xItem.currentFormat := fmt.symbol					end;				return GetRoot().(transport.owner):Submit(xItem)				end			end;		nil		end,	GetAppFormats: func(arg1)	begin		local local1, local2, local3, local4, local5, local7, local8, local10;		local1 := [];		local2 := nil;		local3 := if arg1 then			GetRoot().(arg1);		if not local3 then			(local3 := GetRoot());		if if arg1 <> nil then			Routing.(arg1) <> nil then		begin			local2 := [];			local4 := nil;			foreach local5 in Routing.(arg1) do				if local5 then				(if local5.routeform = 'printSlip or local5.routeform = 'faxSlip then			begin				local7 := 'Print;				if local5.routeform = 'faxSlip then					(local7 := 'fax);				foreach local8 in local5.formats do				begin					if ClassOf(local8) = 'symbol then					begin						local4 := local8;						local8 := GetVariable(local3, local8);					end;					if local8 <> nil then					begin						local10 := {_proto: local8, symbol: local4, noDefaults: true, dataTypes: [local7]};						SetAdd(local2, local10, true);					end;				end;			end;			else (if local5.routeform = 'mailSlip then				foreach local8 in local5.formats do			begin				if ClassOf(local8) = 'symbol then				begin					local4 := local8;					local8 := GetVariable(local3, local8);				end;				if local8 <> nil then				begin					local10 := Clone(local8);					local10.type := 'printFormat;					local10.symbol := local4;					local10.noDefaults := true;					local10.dataTypes := ['mail];					SetAdd(local2, local10, true);				end;			end;			else (if local5.routeform = 'zapSlip then			begin				local10 := {_proto: @490, noDefaults: true, dataTypes: ['beam]};				SetAdd(local2, local10, true);			end;			else (if local5.routeform then			begin			end))));		end;		if local2 then			foreach local8 in local2 do			if local8 <> nil then			SetAdd(local1, local8, true);		if Length(local1) > 0 then			local1	end,	GetRouteFormats: func(item)		begin		local formats := [];		if item then			begin			local itemClass := DataClassOf(item);			local defs := GetViewDefs(itemClass);			if defs then				foreach def in defs do					if def.type = 'printFormat or def.type = 'routeFormat then						SetAdd(formats, def, true);			end;		if Length(formats) > 0 then			formats		end,	GetFormatTransports: func(formatArray, target)		begin		local local1, local2, local3, local5, local7, local9, local11, local12;		local transports := [];		local2 := [];		if formatArray = nil then			return transports;		foreach fmt in formatArray do			if fmt.title or fmt:?GetTitle(target) then				foreach local5 in fmt.dataTypes do					SetAdd(local2, local5, true);		foreach local7 in transports do			begin			local9 := GetRoot().(local7);			if local9 = nil then				Throw('|evt.ex.ioBox|, -8301);			if local9.dataTypes exists and IsArray(local9.dataTypes) and local9.SendRequest then				(if SetOverlaps(local2, local9.dataTypes) then				(if local9.group then				begin				local groupSym := GetGroupTransport(local9.group);				local11 := GetRoot().(groupSym);				if local9.appSymbol = groupSym then					AddArraySlot(transports, local9);				else if not SetOverlaps(local2, local11.dataTypes) then					begin					local12 := GetUserConfig('transportGroups);					if local12 = nil then						(local12 := {});					local12.(EnsureInternal(local9.group)) := local9.appSymbol;					SetUserConfig('transportGroups, local12);					AddArraySlot(transports, local9)					end				end			else				AddArraySlot(transports, local9)));			end;		transports		end,	OpenRoutingSlip: func(item, targetInfo)		begin		if item = nil then			return;		if OnlyOneRoutingSlip() and currentRouteSlip then			begin			GetRoot():Notify(kNotifyAlert, "Routing", "Sorry.  Another routing slip is already open.");			return 'skipErrorMessage			end;		local local1, local2, local3, local4, local5, local6, local7, local9;		local1 := GetItemTransport(item);		if local1 = nil or local1.dataTypes = nil then			Throw('|evt.ex.ioBox|, -8301);		if local1.routingSlip = nil then			Throw('|evt.ex.ioBox|, -8302);		local2 := BuildContext(local1.routingSlip);		local2.transport := local1;		local2.activeFormat := nil;		local2.fields := item;		local2.formats := [];		if item.state = nil then		begin			if targetInfo = nil then				return;			local3 := {|beam:newton|: 'zapSlip, |print:newton|: 'printSlip, |faxsend:newton|: 'faxSlip};			local4 := item.appSymbol and GetRoot().(item.appSymbol);			if local4 and not item.assistnoverify and local4.VerifyRoutingInfo then			begin				targetInfo := local4:VerifyRoutingInfo(targetInfo, item);				if targetInfo = nil then					return 'skipErrorMessage;				else (if targetInfo.targetTitle then					(local2.fields.title := targetInfo.targetTitle));			end;			if targetInfo.appSymbol and targetInfo.appSymbol <> item.appSymbol then			begin				item.appSymbol := targetInfo.appSymbol;				local4 := item.appSymbol and GetRoot().(item.appSymbol);				if local4 and not item.assistnoverify and local4.VerifyRoutingInfo then				begin					targetInfo := local4:VerifyRoutingInfo(targetInfo, item);					if targetInfo = nil then						return 'skipErrorMessage;					else (if targetInfo.targetTitle then						(local2.fields.title := targetInfo.targetTitle));				end;			end;			local2.target := targetInfo.target;			local2.targetView := targetInfo.targetView;			local2._nextKeyView := local2.targetView;			if local2.target = nil and local2.targetView then				(if targetInfo.targetView.SetupTarget exists then			begin				local5 := nil;				if local3.(local2.fields.category) then				begin					local5 := local2.fields.category;					local2.fields.category := local3.(local2.fields.category);				end;				targetInfo.targetView:?SetupTarget(local2);				if local5 then					(local2.fields.category := local5);			end);			if local2.target = nil then				return;			if Length(local1.dataTypes) = 0 then				(local2.formats := [{				type: 'routeFormat,				symbol: 'bogus,				title: "bogus",				SetupItem: func(item, targetInfo)				begin					item				end			}]);			else			begin				local6 := GetAppFormats(local2.fields.appSymbol);				if local6 = nil then					(local6 := GetRouteFormats(local2.target));				if local6 then					foreach local7 in local6 do					if SetOverlaps(local1.dataTypes, local7.dataTypes) then					SetAdd(local2.formats, local7, true);			end;			if Length(local2.formats) = 0 then				return 'skipErrorMessage;			if local2.fields.currentFormat = nil and local4 then				(local2.fields.currentFormat := local4:GetDefaultFormat(local2.fields.category, local2.target));			if local2.fields.currentFormat <> nil then				foreach local7 in local2.formats do				if local7.symbol = local2.fields.currentFormat then			begin				local2.activeFormat := local7;				break;			end;			if local2.activeFormat = nil then			begin				local2.activeFormat := local2.formats[0];				local2.fields.currentFormat := local2.activeFormat.symbol;				if local4 then					local4:SetDefaultFormat(local2.fields.category, local2.target, local2.fields.currentFormat);			end;			if local2.target and not local2.fields.alternatives then			begin				local9 := GetHilitedTextItems();				if local9 and Length(local9) > 0 then				begin					local9 := GlueStrings(local9);					if local9 then					begin						local2.fields.alternatives := GuessAddressee(local9);						nameIndex := 0;					end;				end;			end;			if HasSlot(local2.activeFormat, 'SetupSlip) then				local2.activeFormat:SetupSlip(local2, local2.fields);			else (if local2.activeFormat:?SetupItem(local2.fields, targetInfo) = nil then			begin				GetRoot():Notify(3, local1.title, "This item cannot be sent.");				return;			end);			if local2.targetView and local2.target then				(if local2.targetView.SetupRoutingSlip exists then			begin				local5 := nil;				if local3.(local2.fields.category) then				begin					local5 := local2.fields.category;					local2.fields.category := local3.(local2.fields.category);				end;				local2.targetView:?SetupRoutingSlip(local2.fields);				if local5 then					(local2.fields.category := local5);			end);			item.state := 'ready;		end;		else		begin			local2.target := if local2.fields.body then				local2.fields.body;			else				local2.fields;			local2.targetView := self;			local2.activeFormat := GetCurrentFormat(local2.fields);			if local2.activeFormat then			begin				local2.formats := [local2.activeFormat];				local2.target := local2.activeFormat:?ResolveBody(local2.fields);			end;			if not local2.fields.Connect and not local2.fields.state = 'pending then				(local2.Editing := true);		end;		if if item.state = 'ready then			local1:?SkipRoutingSlip(item) then		begin			if local2.activeFormat then				(item := local2.activeFormat:ParseCursor(item, {target: local2.target, targetView: local2.targetView}));			item.Connect := true;			local1:ItemSubmit(item);			return local2;		end;		local2:Open();		OpenedEntryForm(local2, nil);		local2		end,	OnlyOneRoutingSlip: func() nil,	CreateTargetCursor: func(class, dataArray)		begin		local dDef := GetDataDefs(class);		local cursor := if dDef then dDef:?CreateCursor(dataArray);		if not cursor then			cursor := {class: class, _cursor: dataArray};		cursor		end,	GetTargetCursor: func(target, arg2)		begin		if TargetIsCursor(target) then			begin			local dDef := GetDataDefs(ClassOf(target));			cursor := if dDef then dDef:?Query(target, arg2);			if not cursor then				cursor := protoAliasCursor:New(arg2, target);			cursor			end		else			@505:New(arg2, if target then [target] else [])		end,	TargetIsCursor: func(target) if IsFrame(target) then target._cursor <> nil,	GetTargetFromEntry: func(arg1)		begin		if not arg1 then			return;		local local1 := if arg1.body then arg1.body else arg1;		if arg1.needsResolve then			begin			local local2 := GetCurrentFormat(arg1);			if local2 then				local1 := local2:ResolveBody(arg1);			if not local1 then				GetRoot():Notify(kNotifyAlert, "InOut Box", "This item cannot be routed; the original has been removed or deleted.")			end;		local1		end,	AppInstalled: func(appSym) GetRoot().iobox:AppInstalled(appSym),	GetItemTransport: func(item)		begin		local transport := nil;		if IsFrame(item) and item.category then			transport := GetRoot().(item.category);		try			if transport = nil or transport.defaultConfiguration = nil then				transport := GetRoot().|defaultTransport:Newton|		onexception |evt.ex| do			begin			transport := GetRoot().|defaultTransport:Newton|;			return transport			end;		transport		end,	ClassAppByClass: func(dataClass)		begin		local apps := [];		foreach sym, local3 deeply in appClassesRegistry do			foreach local5 in local3 do				if dataClass = local5 then					begin					SetAdd(apps, sym, true);					break;					end;		if Length(apps) > 0 then apps		end,	RegAppClasses: func(appSym, dataClasses)		begin		if not IsArray(dataClasses) then			return;		if appClassesRegistry.(appSym) then			appClassesRegistry.(appSym) := SetUnion(appClassesRegistry.(appSym), dataClasses, nil)		else			appClassesRegistry.(EnsureInternal(appSym)) := dataClasses		end,	UnRegAppClasses: func(appSym)		begin		RemoveSlot(appClassesRegistry, appSym);		nil		end,	UnRegTheseAppClasses: func(appSym, dataClasses)		begin		if IsArray(dataClasses) and appClassesRegistry.(appSym) then			begin			foreach dataClass in dataClasses do				SetRemove(appClassesRegistry.(appSym), dataClass);			if Length(appClassesRegistry.(appSym)) = 0 then				RemoveSlot(appClassesRegistry, appSym)			end		end,	RegInboxApp: func(appSym, test)		begin		inboxApps.(EnsureInternal(appSym)) := test;		nil		end,	UnRegInboxApp: func(appSym)		begin		RemoveSlot(inboxApps, appSym);		nil		end,	TransportNotify: func(transportSym, msg, args)		begin		local result := nil;		if transportSym = '_all then			foreach sym in transports do				begin				local transport := GetRoot().(sym);				if transport and transport.(msg) then					Perform(transport, msg, args);				end		else			begin			local groupSym := GetGroupTransport(transportSym);			if groupSym then				transportSym := groupSym;			transport := GetRoot().(transportSym);			if transport = nil then				result := 'noTransport			else if transport.(msg) exists then				result := Perform(transport, msg, args)			else				result := 'noMethod			end;		result		end,}