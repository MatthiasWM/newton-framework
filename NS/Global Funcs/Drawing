{// Drawing and Graphics	MakeBitmap: plainC.FMakeBitmap /* funcPtr: 7010218, numArgs: 3 */,	DrawIntoBitmap: plainC.FDrawIntoBitmap /* funcPtr: 7010213, numArgs: 3 */,	MungeBitmap: plainC.FMungeBitmap /* funcPtr: 7010222, numArgs: 3 */,	GetBitmapInfo: plainC.FGetBitmapInfo /* funcPtr: 7010214, numArgs: 1 */,	GetBitmapPixel: plainC.FGetBitmapPixel /* funcPtr: 7045108, numArgs: 3 */,//	Hit Testing	HitShape: plainC.FHitShape /* funcPtr: 7036660, numArgs: 3 */,	PtInPicture: plainC.PtInPicture /* funcPtr: 7038764, numArgs: 3, version: 1 */,	StrokeInPicture: plainC.FStrokeInPicture /* funcPtr: 7039834, numArgs: 2 */,//	Shape Creation	MakeInk: plainC.FMakeInk /* funcPtr: 7049346, numArgs: 5 */,	MakeLine: plainC.FMakeLine,	MakeRect: plainC.FMakeRect,	MakeRoundRect: plainC.FMakeRoundRect /* funcPtr: 7037703, numArgs: 5 */,	MakeOval: plainC.FMakeOval /* funcPtr: 7041944, numArgs: 4 */,	MakeWedge: plainC.FMakeWedge /* funcPtr: 7037706, numArgs: 6 */,	MakePolygon: plainC.FMakePolygon /* funcPtr: 7037701, numArgs: 1 */,	MakeShape: plainC.FMakeShape,	MakeRegion: plainC.FMakeRegion /* funcPtr: 7037702, numArgs: 1 */,	MakePict: plainC.FMakePict /* funcPtr: 7037700, numArgs: 2 */,	MakeText: plainC.FMakeText,	MakeTextLines: plainC.FMakeTextLines,	MakeTextBox: plainC.FMakeTextBox,	TextBox: plainC.FTextBox /* funcPtr: 7010227, numArgs: 3 */,//	Shape Operations	FindShape: plainC.FFindShape /* funcPtr: 7049349, numArgs: 4 */,	GetShapeInfo: plainC.FGetShapeInfo /* funcPtr: 7010215, numArgs: 1 */,	DrawStringShapes: plainC.FDrawStringShapes /* funcPtr: 7044055, numArgs: 2 */,	MungeShape: plainC.FMungeShape /* funcPtr: 7049348, numArgs: 3 */,	OffsetShape: plainC.FOffsetShape,	ScaleShape: plainC.FScaleShape /* funcPtr: 7038773, numArgs: 3 */,	ShapeBounds: plainC.FShapeBounds,	InsetRect: plainC.FInsetRect /* funcPtr: 7010216, numArgs: 3 */,	IsPtInRect: plainC.FIsPtInRect /* funcPtr: 7010217, numArgs: 3 */,	FitToBox: func(sourceBox, boundingBox, justify)		begin		constant kRef45D171 := 1.0e-13;		local box := Clone(boundingBox);		local wd := sourceBox.right - sourceBox.left;		local ht := sourceBox.bottom - sourceBox.top;		local scale := max(wd / (boundingBox.right - boundingBox.left), ht / (boundingBox.bottom - boundingBox.top));		if scale > 1 then			begin			wd := ceiling(wd / scale - kRef45D171);			ht := ceiling(ht / scale - kRef45D171);			end;		if justify and (BAnd(justify, 0x01) <> 0 or BAnd(justify, 0x20) <> 0) then			box.left := box.right - wd		else if justify and BAnd(justify, 0x02) <> 0 then			begin			box.left := (box.left + box.right - wd) div 2;			box.right := box.left + wd			end		else			box.right := box.left + wd;		if justify and (BAnd(justify, 0x08) <> 0 or BAnd(justify, 0x80) <> 0) then			box.top := box.bottom - ht		else if justify and BAnd(justify, 0x04) <> 0 then			begin			box.top := (box.top + box.bottom - ht) div 2;			box.bottom := box.top + ht			end		else			box.bottom := box.top + ht;		box		end,	OffsetRect: plainC.FOffsetRect /* funcPtr: 7010223, numArgs: 3 */,	RectsOverlap: plainC.FRectsOverlap /* funcPtr: 7010224, numArgs: 2 */,	SectRect: plainC.FSectRect /* funcPtr: 7010225, numArgs: 2 */,	UnionPoint: plainC.FUnionPoint /* funcPtr: 7010228, numArgs: 3 */,	UnionRect: plainC.FUnionRect /* funcPtr: 7010229, numArgs: 2 */,	PictToShape: plainC.FPictToShape /* funcPtr: 7049347, numArgs: 2 */,	PictureBounds: plainC.FPictureBounds,	GraphicBounds: func(inGraphic)		begin		if IsBinary(inGraphic) and IsInstance(inGraphic, 'picture) then			PictureBounds(inGraphic)		else if IsFrame(inGraphic) and IsFrame(inGraphic.bounds) then			inGraphic.bounds		else			ShapeBounds(inGraphic)		end,	GraphicSize: func(inGraphic)		begin		local box := GraphicBounds(inGraphic);		SetBounds(0, 0, box.right - box.left, box.bottom - box.top)		end,	FullResolutionBounds: func(arg1)		begin		local local1, local2, local3, local4, local5, local6;		local1 := GetShapeInfo(arg1);		if local1.bitsBounds then			begin			local2 := local1.bitsBounds.right - local1.bitsBounds.left;			local3 := local1.bitsBounds.bottom - local1.bitsBounds.top;			end		else			begin			local2 := local1.bounds.right - local1.bounds.left;			local3 := local1.bounds.bottom - local1.bounds.top;			end;		local4 := 1;		local5 := 1;		if local1.resolution then			begin			local4 := local1.resolution[0];			local5 := local1.resolution[1];			end;		local6 := max(local4, local5);		RelBounds(0, 0, local2 * local6 div local4, local3 * local6 div local5)		end,//	Drawing Utilities	DrawXBitmap: plainC.FDrawXBitmap /* funcPtr: 7035587, numArgs: 4 */,	IsPrimShape: plainC.FIsPrimShape /* funcPtr: 226959, numArgs: 1 */,	ArrayToPoints: plainC.FArrayToPoints /* funcPtr: 7034534, numArgs: 1 */,	PointsToArray: plainC.FPointsToArray /* funcPtr: 7038757, numArgs: 1 */,}