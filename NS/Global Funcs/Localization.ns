{// Localizing Newton Applications	GetLocale: plainC.FGetLocale,	SetLocale: plainC.FSetLocale /*localeSym*/,	AddLocale: func(localeBundle)		begin		local allLocales := international.locales;	// an array		if allLocales then			begin			if IsReadOnly(allLocales) then				allLocales := Clone(allLocales);			local localeSym := localeBundle.title;			local existingLocale := FindLocale(localeSym);			if existingLocale then				begin				local localeIndex := ArrayPos(allLocales, localeSym, 0, func(arg1, arg2) StrEqual(arg1, arg2.title) );				if localeIndex then					allLocales[localeIndex] := localeBundle				end			else				AddArraySlot(allLocales, localeBundle);			international.(EnsureInternal('locales)) := allLocales;			end;		allLocales := international.localeTable;	// a frame		if allLocales then			begin			if IsReadOnly(allLocales) then				allLocales := Clone(allLocales);			localeSym := localeBundle.localeSym;			if not localeSym then				localeSym := Intern(localeBundle.title);			allLocales.(localeSym) := localeBundle;			international.(EnsureInternal('localeTable)) := allLocales			end		end,	FindLocale: func(localeSym)		begin		local localeBundle;		if ClassOf(localeSym) = 'symbol then			begin			local table := international.localeTable;			if table then				localeBundle := table.(localeSym);			end		else if IsInstance(localeSym, 'string) then			begin			local localeIndex := ArrayPos(international.locales, localeSym, 0, func(arg1, arg2) StrEqual(arg1, arg2.title) );			if localeIndex then				localeBundle := international.locales[localeIndex];			end;		localeBundle		end,	RemoveLocale: func(localeSym)	begin		local local1, local2, local3, local4, local5, local6, local7, local8, local9;		local1 := FindLocale(localeSym);		if local1 then		begin			if ClassOf(localeSym) = 'symbol then			begin				local2 := localeSym;				local3 := local1.title;			end;			else (if IsInstance(localeSym, 'string) then			begin				local2 := local1.localeSym;				local3 := localeSym;			end);			if StrEqual(GetLocale().title, local3) then			begin				local4 := international._proto.locales[0].title;				SetLocale(local4);				GetGlobals().setTimeSeed := Random(0, 10000000);				call func(arg1, arg2, arg3)				begin					target := arg1;					message := arg2;					params := arg3;					if functions.AddDeferredSend exists then						return AddDeferredSend(target, message, params);					return AddDeferredAction(func()						begin							Perform(target, message, params)						end, [					])				end with (GetRoot(), 'RedoChildren, []);			end;			if international.locales exists and international.locales then			begin				local5 := Clone(international.locales);				local6 := ArrayPos(local5, local3, 0, func(arg1, arg2)				begin					StrEqual(arg1, arg2.title)				end);				RemoveSlot(local5, local6);				local7 := international._proto.locales;				if call func(arg1, arg2)				begin					local local1, local2;					local1 := nil;					if Length(arg1) = Length(arg2) then					begin						local1 := true;						foreach local2 in arg1 do							if not SetContains(arg2, local2) then						begin							local1 := nil;							break;						end;					end;					return local1				end with (local5, local7) then					(if not IsReadOnly(international.locales) then					RemoveSlot(international, 'locales));				else					(international.(EnsureInternal('locales)) := local5);			end;			if international.localeTable exists and international.localeTable then			begin				local8 := Clone(international.localeTable);				RemoveSlot(local8, local2);				local9 := international._proto.localeTable;				if call func(arg1, arg2)				begin					local local1, local2, local3;					local1 := nil;					if Length(arg1) = Length(arg2) then					begin						local1 := true;						foreach local2, local3 in arg1 do							if arg2.(local2) <> local3 then						begin							local1 := nil;							break;						end;					end;					return local1				end with (local8, local9) then					(if not IsReadOnly(international.localeTable) then					RemoveSlot(international, 'localeTable));				else					(international.(EnsureInternal('localeTable)) := local8);			end;		end;		local1	end,	ResetLocales: func()		begin		if international.locales exists		and not IsReadOnly(international.locales) then			RemoveSlot(international, 'locales);		if international.localeTable exists		and not IsReadOnly(international.localeTable) then			RemoveSlot(international, 'localeTable);		return true		end,	UpdateLocaleFromUserConfig: func()		begin		foreach updateFormatFunc in {		//	longDateFormat:		//	shortDateFormat:			timeformat: func()				begin				local userFormat := GetUserConfig('timeformat);				if userFormat then					begin					userFormat := Clone(userFormat);					local localeFormat := GetLocale().timeformat;					foreach sym, val in userFormat do						if localeFormat.(sym) = val then							RemoveSlot(userFormat, sym);					if Length(userFormat) > 0 then						begin						if IsReadOnly(international.currentlocalebundle) then							international.currentlocalebundle := {_proto: international.currentlocalebundle};						if IsReadOnly(international.currentlocalebundle.timeformat) then							international.currentlocalebundle.timeformat := {_proto: international.currentlocalebundle.timeformat};						localeFormat := GetLocale().timeformat;						foreach sym, val in userFormat do							localeFormat.(EnsureInternal(sym)) := EnsureInternal(val);						vars.setTimeSeed := Random(0, 10000000);						local rootView := GetRoot();						if rootView then							rootView:Dirty()						end					end				end		} do			call updateFormatFunc with ()		end,//	Date and Time	SetTime: func(time)		begin		if IsNumber(time) then			time := TimeToTimeInSeconds(time, 0);		SetTimeInSeconds(time)		end,	SetTimeInSeconds: func(time)		begin		local secsSince1993 := if IsFrame(time) then TotalSeconds(time) else time;		local minsSince1904 := TimeInSecondsToTime(secsSince1993);		local dstOffset := DSTVerify(minsSince1904);		SetTimeHardware(secsSince1993);		vars.setTimeSeed := Random(0, 10000000);		CallFrameBasedRegistryFns(SetTimeRegistry, [minsSince1904]);		local rootView := GetRoot();		if rootView and rootView.viewCObject then			rootView:Dirty();		SetNextAlarm();		nil		end,	SetTimeHardware: plainC.FSetTimeInSeconds/*secsSince1993*/,	RegSetTime: func(id, fn)		begin		setTimeRegistry.(EnsureInternal(id)) := fn;		nil		end,	UnRegSetTime: func(id)		begin		RemoveSlot(setTimeRegistry, id);		nil		end,	IncrementMonth: plainC.FIncrementMonth /*minsSince1904, monthsOffset*/,//	Ticks: plainC.FTicks,	Time: plainC.FTime,	TimeInSeconds: plainC.FTimeInSeconds,	TimeInSecondsToTime: func(secsSince1993) 46811520 + secsSince1993 div 60,	TimeToTimeInSeconds: func(minsSince1904, extraSecs) 60 * (minsSince1904 - 46811520) + (if extraSecs then extraSecs else 0),	DateNTime: plainC.FDateNTime /*minsSince1904*/,	HourMinute: plainC.FHourMinute /*minsSince1904*/,	LongDateStr: plainC.FLongDateStr /*minsSince1904, dateStrSpec*/,	ShortDate: plainC.FShortDate /*minsSince1904*/,	ShortDateStr: plainC.FShortDateStr /*minsSince1904, dateStrSpec*/,	StringToDate: plainC.FStringToDate /*str*/,	StringToDateFrame: plainC.FStringToDateFrame /*str*/,	StringToTime: plainC.FStringToTime /*str*/,	TimeStr: plainC.FTimeStr /*minsSince1904, timeStrSpec*/,	TimeFrameStr: plainC.FTimeFrameStr /*dateFrame, timeStrSpec*/,	Date: plainC.FDate /*minsSince1904*/,	DateFromSeconds: plainC.FDateFromSeconds /*secsSince1993*/,	TotalMinutes: plainC.FTotalMinutes /*dateFrame*/,	TotalSeconds: func(dateFrame) TimeToTimeInSeconds(TotalMinutes(dateFrame), dateFrame.second),	IsValidDate: plainC.FIsValidDate /*dateStringOrFrame*/,	SetCountryClass: func(countryName)		begin		local cntry := GetCountryEntry(countryName);		if Length(cntry) > 0 then			begin			local cntrySym := Intern("string.country." & SymbolName(cntry[0].symbol));			SetClass(countryName, cntrySym)			end;		countryName		end,//ее	DurationStr: func(inMinutes)		begin		if inMinutes < 0 then			inMinutes := 0;		local numOfDays := inMinutes div 1440;		if numOfDays = 0 then			begin			local numOfHours := inMinutes div 60;			local numOfMinutes := inMinutes mod 60;			[	if numOfHours > 1 then ParamStr("^0 hours", [numOfHours])				else if numOfHours = 1 then "1 hour"				else "",				if numOfMinutes > 1 then ParamStr("^0 minutes", [numOfMinutes])				else if numOfMinutes = 1 then "1 minute"				else "" ]			end		else			begin			local numOfWeeks := numOfDays div 7;			numOfDays := numOfDays mod 7;			[	if numOfWeeks > 1 then ParamStr("^0 weeks", [numOfWeeks])				else if numOfWeeks = 1 then "1 week"				else "",				if numOfDays > 1 then ParamStr("^0 days", [numOfDays])				else if numOfDays = 1 then "1 day"				else "" ]			end		end,	TimeToString: func(minsSince1904)		begin		local dateFrame := Date(minsSince1904);		ParamStr("^0^1^?20||^3", [	dateFrame.hour,											GetLocale().timeformat.timeSepStr2,											dateFrame.minute < 10,											dateFrame.minute])		end,	DateMunger: func(arg1, arg2, arg3)		begin		if arg2 then			begin			local local1 := SPrintObject(arg2);			local local2 := StrLen(local1);			local local3 := 0;			if local2 > 2 then				begin				local3 := local2 - 2;				local2 := 2				end;			StrMunger(arg1, arg3 + 2 - local2, local2, local1, local3, local2)			end		end,	DSTVerify: func(minsSince1904)		begin		local secsOffset;		local minsOffset := 0;		local location := userConfiguration.location;		if location then			begin			secsOffset := 60 * DSTOffset(minsSince1904, location);			if secsOffset <> userConfiguration.daylightsavings then				begin				minsOffset := (secsOffset - userConfiguration.daylightsavings) div 60;				SetUserConfig('daylightsavings, secsOffset);				end;			end;		minsOffset		end,	DSTOffset: func(minsSince1904, inLocation)		begin		/* closed */ local testYear;		local location := inLocation;		if not HasSlot(location, 'daylight) then			begin			location := GetCountryEntry(location.country);			if not location or Length(location) = 0 then				return 0;			location := location[0];			end;		else if not location.daylight then			return 0;		local secsOffset := 0;		if location and location.daylight then			begin			local saving := GetDSTEntry(location.daylight);			if not saving or Length(saving) = 0 then				return 0;			saving := saving[0];			testYear := Date(minsSince1904).year;			local local4 := func(arg1)				begin				local local1 := Date(TotalMinutes({year: testYear, month: arg1.month, date: 1, hour: 0, minute: 0}));				local local2 := arg1.dayOfWeek - local1.dayOfWeek;				if local2 < 0 then					local2 := local2 + 7;				local local3 := Clone(local1);				local3.date := 1 + local2 + 7 * (arg1.ordinal - 1);				if local3.date > local3.daysInMonth and arg1.ordinal = 5 then					local3.date := local3.date - 7;				TotalMinutes(local3) + arg1.time				end;			local local5 := call local4 with (saving.start);			local local6 := call local4 with (saving.stop);			if saving.start.month < saving.stop.month then				begin				if arg1 >= local5 and arg1 < local6 then					secsOffset := saving.change				end			else				begin				if not(arg1 >= local6 and arg1 < local5) then					secsOffset := saving.change				end			end;		secsOffset		end,	DSTExplain: func(inLocation)		begin		local explanation := "none";		local location := inLocation;		if not HasSlot(location, 'daylight) then			begin			location := GetCountryEntry(location.country);			if not location or Length(location) = 0 then				return "";			location := location[0];			end;		if location and location.daylight then			begin			local saving := GetDSTEntry(location.daylight);			if saving then				begin				saving := saving[0];				explanation := ParamStr("^0 - ^1", [DSTDateExplain(saving.start), DSTDateExplain(saving.stop)]);				end;			end;		explanation		end,	DSTDateExplain: func(dateFrame)		begin		local locale := GetLocale();		if dateFrame.ordinal then			ParamStr("^?0^1|last| ^2 in ^3", [dateFrame.ordinal < 5, locale.shortOrdinals[dateFrame.ordinal], locale.longDateFormat.abbrDofWeek[dateFrame.dayOfWeek], locale.longDateFormat.abbrMonth[dateFrame.month - 1]]);		else			LongDateStr(TotalMinutes(dateFrame), @66.monthDayStrSpec)		end,	GetDSTEntry: func(inLocation)		begin		local locationSoup := GetLocationSoup(@658);		if not locationSoup then			return;		if IsInstance(inLocation, 'string) then			inLocation := Intern(inLocation);		local querySpec := {type: 'index, indexPath: 'symbol, beginKey: inLocation, endKey: inLocation};		local cursor := locationSoup:Query(querySpec);		cursor:map(nil)		end,	PositionToTime: plainC.FPositionToTime /* funcPtr: 7038758, numArgs: 2 */,	TimeToPosition: plainC.FTimeToPosition /* funcPtr: 7040868, numArgs: 2 */,	LocalTime: func(inTime, inLocation)		begin		if not inTime then			inTime := Time();		local theTime := inTime + (inLocation.gmt - userConfiguration.location.gmt - userConfiguration.daylightsavings) div 60;		theTime := theTime + DSTOffset(theTime, inLocation)		end,//ее	GetRealPaperSize: func(sizeSym)		begin		if GetGlobalVar('realPaperSizes) then			realPaperSizes.(sizeSym)		else			{ a4:					{	width:  594,										height: 840 },				eightByEleven: {	width:  612,										height: 792 } }.(sizeSym)		end,}