{// Undo	AddUndoCall: plainC.FAddUndoCall /*fn, args*/,	AddUndoSend: plainC.FAddUndoSend /*rcvr, msg, args*/,	AddUndoAction: plainC.FAddUndoAction /*methodSym, args*/,	ClearUndoStacks: plainC.FClearUndoStacks,	GetUndoState: plainC.FGetUndoState,//	Alerts and Alarms	PeriodicAlarmFunc: func(alarm)		begin		local app := GetRoot().(alarm.owner);		if abs(alarm.time - Time()) < alarm.tolerance and app:?AlarmsEnabled() then			app:PeriodicAlarm(alarm);		AddAlarm(alarm.name & $: & alarm.ownerName, UpdatePeriodicAlarmTime(alarm), nil, functions.PeriodicAlarmFunc, [alarm])		end,	UpdatePeriodicAlarmTime: func(aTime)		begin		constant kDaysOfWeek :=		'[ 0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020,			0x0800, 0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020 ];		local timeNow := Time();		local dayNow := Date(timeNow).dayOfWeek;		local aDayStart := timeNow - timeNow mod 1440;		local aMinutes := aTime.hours * 60 + aTime.minutes;		if BAnd(aTime.days, kDaysOfWeek[dayNow]) <> 0		and aDayStart + aMinutes > timeNow then			nextTime := aDayStart + aMinutes		else			for wkDay := dayNow + 1 to dayNow + 8 do				if BAnd(aTime.days, kDaysOfWeek[wkDay]) <> 0 then					begin					nextTime := aDayStart + 1440 * (wkDay - dayNow) + aMinutes;					break;					end;		aTime.time := nextTime		end,	AddAlarm: func(aKey, timeSpec, args, callbackFn, callbackArgs)		begin		if IsNumber(timeSpec) then			timeSpec := TimeToTimeInSeconds(timeSpec, 0);		AddAlarmInSeconds(aKey, timeSpec, args, callbackFn, callbackArgs)		end,	AddAlarmInSeconds: func(aKey, timeSpec, args, callbackFn, callbackArgs)		begin		RemoveAlarm(aKey);		local aTime := if IsFrame(timeSpec) then TotalSeconds(timeSpec) else timeSpec;		local alarm := {	key: aKey,								time: TimeInSecondsToTime(aTime),								timeInSeconds: aTime,								notifyArgs: args,								callbackFn: callbackFn,								callbackParams: callbackArgs};		GetStores()[0]:GetSoup("SystemAlarmSoup"):AddFlushed(alarm);		SetNextAlarm();		aKey		end,	SetNextAlarm: func()		begin		SetSysAlarm(nil, nil, nil);		local aSoup := GetStores()[0]:GetSoup("SystemAlarmSoup");		local aCursor := aSoup:Query({ indexPath: 'timeInSeconds });		local alarm := aCursor:Entry();		while alarm and aCursor:EntryKey() <= TimeInSeconds() do			begin			EntryRemoveFromSoup(alarm);			XAlarm(alarm);			alarm := aCursor:Next()			end;		if alarm then			SetSysAlarm(alarm.timeInSeconds, functions.SetNextAlarm, nil)		end,	XAlarm: func(alarm)		begin		try			if alarm.callBackFn then				Apply(alarm.callBackFn, alarm.callBackParams);			local args := alarm.notifyArgs;			if args then				begin				if Length(args) = 2 then					Apply(functions.AlarmUser, args);				else					Perform(GetRoot(), 'Notify, args)				end		onexception |evt.ex| do			nil		end,	SetSysAlarm: plainC.FSetSysAlarm /* funcPtr: 7039809, numArgs: 3 */,	AlarmUser: func(title, message)		begin		BHNotify(9, title, message, GetRegisteredSound(GetUserConfig('alarmSound)), GetAlarmVolume());		if GetUserConfig('alarmAnnoyOn) then			AddDeferredCall(functions.AnnoyUserRepeatedly, [0])		end,	BHNotify: func(inLevel, inHeaderStr, inMessageStr, inSound, inVolume)		begin		local notInfo := {_proto: if inLevel = 9 then @86 else @127,								timestamp: Time(),								nfType: inLevel,								nfText: EnsureInternal(inMessageStr),								overview: EnsureInternal(inHeaderStr),								seenByUser: nil,								sound: inSound,								volume: inVolume};		if not inSound and BFind([2,3,5,9], inLevel, '|<|, nil) then			notInfo.sound := GetRegisteredSound(GetUserConfig('beepSound));		local notifyApp := GetRoot().notification;		if inLevel = 5 or inLevel = 6 then			notifyApp:ShowItem(notInfo, nil)		else if inLevel = 2 then			AddDeferredSend(GetRoot().notifyIcon, 'AddMessage, [notInfo])		else if inLevel = 1 then			AddDeferredSend(notifyApp, 'AddItem, [notInfo, true])		else			AddDeferredSend(notifyApp, 'ShowItem, [notInfo, nil]);		notInfo		end,	AnnoyUserRepeatedly: func(rep)		begin		local alarm := LFetch(notifications, 9, 0, '|=|, 'nfType);		if alarm and not alarm.seenByUser then			begin			if rep > 0 then				begin				GetRoot().notification:ShowItem(alarm, nil);				AnnoyUser()				end;			local delays := GetUserConfig('alarmAnnoyDelays);			if rep < Length(delays) then				AddAlarmInSeconds("AnnoyingAlarm", TimeInSeconds() + delays[rep], nil, func(aRep) AnnoyUserRepeatedly(aRep), [rep + 1])		end	end,	AnnoyUser: func()		begin		local vol := GetAlarmVolume();		if GetUserConfig('alarmSoundEffects)		or GetUserConfig('alarmVolumeEqualsSystem) then			begin			local pause := GetUserConfig('alarmAnnoyPause);			local noise := GetRegisteredSound(GetUserConfig('alarmSound));			Sleep(pause);			for i := 1 to GetUserConfig('alarmAnnoyReps) do				begin				PlaySoundSync({ _proto: noise, volume: vol });				Sleep(pause)				end			end		end,	GetAlarm: func(aKey)		begin		GetStores()[0]:GetSoup("SystemAlarmSoup"):Query({indexPath: 'key, beginKey: aKey, endKey: aKey}):Entry()		end,	RemoveAlarm: func(aKey)		begin		local cursor := GetStores()[0]:GetSoup("SystemAlarmSoup"):Query({indexPath: 'key, beginKey: aKey, endKey: aKey});		local alarm := cursor:Entry();		if alarm then			begin			EntryRemoveFromSoup(alarm);			SetNextAlarm()			end;		alarm		end,	GetAppAlarmKeys: func(aKeySuffix)		begin		/* closed */ local alarmKeySuffix := aKeySuffix;		local cursor := GetStores()[0]:GetSoup("SystemAlarmSoup"):Query({indexPath: 'key, IndexValidTest: func(aKey) EndsWith(aKey, alarmKeySuffix)});		local alarms := MapCursor(cursor, nil);		Sort(alarms, '|<|, 'timeInSeconds);		foreach alarm in alarms collect			alarm.key		end,	RemoveAppAlarms: func(aKeySuffix)		begin		/* closed */ local alarmKeySuffix := aKeySuffix;		local numRemoved := 0;		local cursor := GetStores()[0]:GetSoup("SystemAlarmSoup"):Query({indexPath: 'key, IndexValidTest: func(aKey) EndsWith(aKey, alarmKeySuffix)});		local alarm := cursor:Entry();		while alarm do			begin			numRemoved := numRemoved + 1;			EntryRemoveFromSoup(alarm);			alarm := cursor:Next()			end;		if numRemoved > 0 then			SetNextAlarm();		numRemoved		end,	GetAlarmVolume: func()		begin		if GetUserConfig('alarmVolumeEqualsSystem) then			GetUserConfig('soundVolumeDb)		else			GetUserConfig('alarmVolumeDb)		end,//	Progress Reporting	DoProgress: func(kind, options, workFn)		begin		local progress := BuildContext(			{	_proto: protoStatusTemplate,				icon: @14,				runFlag: true,				modalStatus: true,				SetStatus: func(sKind, sOptions)					begin					:ViewSet({name: sKind, values: sOptions});					call plainC.FYieldToFork with ();					if self.runFlag = nil then						Throw('|evt.ex.cancel|, 666)					end,				CancelRequest: func(why)					begin					self.runFlag := nil					end			});		progress.initialSetup := {name: kind, values: options, appSymbol: 'progressSlip};		progress:FilterDialog();		local result;		try			result := call plainC.FForkScript with (workFn, [progress])		onexception |evt.ex.cancel| do			result := 'cancel;		onexception |evt.ex| do			begin			RemoveSlot(GetRoot(), 'progressSlip);			progress:Close();			Rethrow();			end;		RemoveSlot(GetRoot(), 'progressSlip);		progress:Close();		result		end,	ShowBusyBox: func(doShow) BusyBoxControl(if doShow then -2 else 2),//	Power Registry	BatteryCount: plainC.FBatteryCount,	BatteryStatus: plainC.FBatteryStatus /*battery*/,	BatteryRawStatus: plainC.FBatteryRawStatus /*battery*/,	BatteryLevel: plainC.FBatteryLevel /*battery*/,	SetBatteryType: plainC.FSetBatteryType /*battery, type*/,	EnablePowerStats: plainC.FEnablePowerStats /*battery*/,	GetPowerStats: plainC.FGetPowerStats,	ResetPowerStats: plainC.FResetPowerStats,	MainBatteryCheck: func()		begin		if vars.quickLookLives or BatteryCount() < 1 then			return;		local alert, status := BatteryStatus(0);		if status.acPower <> 'yes		and status.batteryCapacity <= status.batteryLow then			begin			local msg;			if GetRoot().GetBatteryMessages then				msg := (GetRoot():GetBatteryMessages()).batteryLowMessage;			if not msg then				msg := "The battery is running low. You need to recharge or change batteries soon.";			alert := GetRoot():Notify(kNotifyQAlert, "Battery", msg);			alert.batteryAlert := true;			end;		CheckCardBattery()		end,	CheckCardBattery: plainC.FCheckCardBattery,	MinimumBatteryCheck: func()		begin		if call plainC.FMinimumBatteryCheck with () then			begin			RefreshViews();			CallPowerOnFns('emergencyPowerOff)			end		end,	BackupBatteryCheck: func()		begin		if vars.quickLookLives or BatteryCount() < 2 then			return;		local alert, status := BatteryStatus(1);		local msg;		if GetRoot().GetBatteryMessages then			local msgs := GetRoot():GetBatteryMessages();		if status.batteryCapacity <= status.batteryDead then			begin			if msgs and msgs.backupBatteryDeadMessage then				msg := msgs.backupBatteryDeadMessage			else				msg := "The backup battery is dead or missing. You need to replace the backup battery immediately or you will lose the information in your Newton.";			alert := GetRoot():Notify(kNotifyQAlert, "Battery", msg);			alert.batteryAlert := true			end		else if status.batteryCapacity <= status.batteryLow then			begin			if msgs and msgs.backupBatteryLowMessage then				msg := msgs.backupBatteryLowMessage			else				msg := "The backup battery is running low. You need to replace the backup battery soon or you may lose the information in your Newton.";			alert := GetRoot():Notify(kNotifyQAlert, "Battery", msg);			alert.batteryAlert := true			end		end,	BadAdapterAlert: func()		begin		local msg, msgs := GetRoot():?GetBatteryMessages();		if msgs and msgs.badAdapter then			msg := msgs.badAdapter		else			msg := "The adapter is providing too much power.  The battery cannot be charged with this adapter.";		local alert := GetRoot():Notify(kNotifyAlert, "Power", msg);		alert.batteryAlert := true		end,	BadBatteryAlert: func()		begin		local msg, msgs := GetRoot():?GetBatteryMessages();		if msgs and msgs.badBattery then			msg := msgs.badBattery		else			msg := "The main battery is unable to maintain a charge. It needs to be replaced.";		local alert := GetRoot():Notify(kNotifyAlert, "Battery", msg);		alert.batteryAlert := true		end,	HideBatteryAlerts: func()		begin		local notifyApp := GetRoot().notification;		foreach index, alert in notifications do			if alert.batteryAltert then				notifyApp:MarkItemSeen(index, true)		end,	RegPowerOff: func(id, fn)		begin		powerOffRegistry.(EnsureInternal(id)) := fn;		nil		end,	AddPowerOffHandler: func(handler)		begin		AddArraySlot(oldPowerOffHandlers, handler)		end,	RemovePowerOffHandler: func(handler)		begin		SetRemove(oldPowerOffHandlers, handler)		end,	UnRegPowerOff: func(id)		begin		if powerOffFenceSitters then			begin			local index := LSearch(powerOffFenceSitters, id, 0, '|=|, nil);			if index then				begin				if index = 0 then					PowerOffResume(id)				else					RemoveSlot(PowerOffFenceSitters, index)				end			end;		RemoveSlot(powerOffRegistry, id);		nil		end,	RegPowerOn: func(handlerSym, fn)		begin		powerOnRegistry.(EnsureInternal(handlerSym)) := fn;		nil		end,	CallPowerOnFns: func(reason)		begin		CallFrameBasedRegistryFns(powerOnRegistry, [reason])		end,	UnRegPowerOn: func(handlerSym)		begin		RemoveSlot(powerOnRegistry, handlerSym);		nil		end,	RegPowerStatusChange: func(handlerSym, fn)		begin		powerStatusChangeRegistry.(EnsureInternal(handlerSym)) := fn;		nil		end,	CallPowerStatusChangeFns: func()		begin		CallFrameBasedRegistryFns(powerStatusChangeRegistry, [BatteryStatus(0)])		end,	UnRegPowerStatusChange: func(handlerSym)		begin		RemoveSlot(powerStatusChangeRegistry, handlerSym);		nil		end,	PowerOnSequence: func(reason)		begin		vars.setTimeSeed := Random(0, 536870911);		local root := GetRoot();		if not root.sleepScreen:PasswordCheck() then			begin			root:Dirty();			RefreshViews();			end;		BackupBatteryCheck();		MainBatteryCheck();		CallPowerOnFns(reason)		end,	CallFrameBasedRegistryFns: func(registry, args)		begin		foreach tag, fn deeply in registry do			if fn = registry.(tag) then				try					Apply(fn, args)				onexception |evt.ex| do					begin					end		end,	ClassInfoByName: plainC.FClassInfoByName /* funcPtr: 7252297, numArgs: 3 */,	ClassInfoRegistrySeed: plainC.FClassInfoRegistrySeed /* funcPtr: 7252298, numArgs: 0 */,	ClassInfoRegistryNext: plainC.FClassInfoRegistryNext /* funcPtr: 7252305, numArgs: 2 */,	NewByName: plainC.FNewByName /* funcPtr: 7252303, numArgs: 3 */,	GetExportTableClients: plainC.FGetExportTableClients /* funcPtr: 213765, numArgs: 1 */,	CurrentExports: plainC.FCurrentExports /* funcPtr: 6901356, numArgs: 0 */,	CurrentImports: plainC.FCurrentImports /* funcPtr: 6901357, numArgs: 0 */,	FlushImports: plainC.FFlushImports /* funcPtr: 6901358, numArgs: 0 */,	FulfillImportTable: plainC.FFulfillImportTable /* funcPtr: 6901359, numArgs: 1 */,	PendingImports: plainC.FPendingImports /* funcPtr: 6901360, numArgs: 0 */,	MissingImports: func(client)		begin		local missing := [];		foreach unit in PendingImports() do			if unit.client = client then				AddArraySlot(missing, unit);		if Length(missing) > 0 then			missing		end,	ReportDeadUnitImports: func(imports)		begin		foreach unit in imports do			try			local status := unit.client:?ImportDisabled(unit.name, unit.major, unit.minor);			if status = 'thrillMeChillMeFulfillMe then				FulfillImportTable(unit.client._ImportTable);			onexception |evt.ex| do			begin			end		end}