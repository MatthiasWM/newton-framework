/* -------------------------------------------------------------------------- */constant kAssistantTitle := "Assist";/* Templates ---------------------------------------------------------------- */DefineGlobalConstant('kTaskTemplate,	{});/* Objects ------------------------------------------------------------------ */DefineGlobalConstant('kObject,			{});DefineGlobalConstant('kParserObject,	{});DefineGlobalConstant('kWhoObject,		{ isa: kObject });DefineGlobalConstant('kPersonObject,	{ isa: kWhoObject,  value: nil });DefineGlobalConstant('kWhatObject,		{ isa: kObject });DefineGlobalConstant('kNumberObject,	{ isa: kObject });DefineGlobalConstant('kWhenObject,		{ isa: kNumberObject });DefineGlobalConstant('kWhereObject,		{ isa: kObject });DefineGlobalConstant('kPlaceObject,		{ isa: kWhereObject });DefineGlobalConstant('kPhoneObject,		{ isa: kWhereObject, lexicon: [ "phone number" ], value: nil });DefineGlobalConstant('kTaggedPhoneObject,	{ isa: kPhoneObject });DefineGlobalConstant('kFormObject,		{ isa: kWhatObject });/* Actions ------------------------------------------------------------------ */DefineGlobalConstant('kAction,			{ value: "action" });// ScheduleDefineGlobalConstant('kScheduleAction,			{ isa:  kAction,  lexicon: [ [ "schedule" ] ],  removeIt: nil});DefineGlobalConstant('kMeetAction,				{ isa: kScheduleAction, lexicon: [ [ "meet", "meet me", "see", "talk to" ] ] });DefineGlobalConstant('kMealAction,				{ isa: kScheduleAction });DefineGlobalConstant('kSpecialEventAction,	{ isa: kScheduleAction });// FindDefineGlobalConstant('kFindAction,		{ isa: kAction,  lexicon: [ [ "find", "locate", "search for", "look for" ] ]});// RemindDefineGlobalConstant('kRemindAction,	{ isa: kAction,  lexicon: [ [ "remember", "remind", "remind me", "to do", "todo", "don't forget to", "don't let me forget to" ] ],  meta_level: true});// MailDefineGlobalConstant('kMailAction,		{ isa: kAction,  lexicon: [ [ "mail", "send", "email", "mail" ] ]});	// sic// FaxDefineGlobalConstant('kFaxAction,		{ isa: kAction,  lexicon: [ [ "fax" ] ]});// PrintDefineGlobalConstant('kPrintAction,		{ isa: kAction,  lexicon: [ [ "print" ] ]});// CallDefineGlobalConstant('kCallAction,		{ isa:  kAction,  lexicon: [ [ "call", "phone", "ring", "dial" ] ]});// TimeDefineGlobalConstant('kTimeAction,		{ isa: kAction,	lexicon: [ [ "time", "time in", "the time in", "what time is it", "what time is it in", "what time", "what is the time", "what is the time in" ] ]});// AboutDefineGlobalConstant('kAboutAction,		{ isa:  kAction,  lexicon: [ [ "about newton" ] ]});// DefaultDefineGlobalConstant('kDefaultAction,	{ isa:  kAction });/* Task Templates ----------------------------------------------------------- */// ScheduleDefineGlobalConstant('kScheduleSignature,			[ kScheduleAction, kWhoObject, kPlaceObject, kWhenObject ]);DefineGlobalConstant('kSchedulePreconditions,	'[ action, who, where, when ]);DefineGlobalConstant('kSchedulingTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kScheduleAction,	signature: kScheduleSignature,	preconditions: kSchedulePreconditions,	taskSlip: 'scheduleSlip,	score: nil,	SetTitle: func()		begin		local str := GlueStrings(self.origPhrase);		local thePhrases := self.phrases;		foreach i, item in self.input do			if isa(item, 'schedule_act) and HasSlot(item, 'removeIt) then				:RemoveFromString(str, thePhrases[i], nil)			else if isa(item, 'when_obj) then				:RemoveFromString(str, thePhrases[i], true);		if str then			str := TrimString(str);		str		end,	SetInvitees: func(arg1)		begin		local nameStr;		local candidates := GetMatchedEntries('person, self.entries);		if candidates then			begin			local count := Length(candidates);			local invitees := Array(count, nil);			for i := 0 to count - 1 do				begin				local local8 := candidates[i];				local nameEntry := ResolveEntryAlias(local8.alias);				invitees[i] := GetDataDefs('|nameRef.people|):MakeNameRef(nameEntry, '|nameRef.people|);				if :SetDisplayName(invitees[i], local8, nameEntry) then					invitees[i]._alias := nil				end;			arg1.nameEntries := invitees			end		else			begin			nameStr := FindPossibleName(self.noisewords, self.origPhrase);			if nameStr then				arg1.nameEntries := [(GetDataDefs('|nameRef.people|):MakeNameRef({name: {last: nameStr}}, '|nameRef.people|))]			end;		nameStr		end,	SetLocation: func(arg1, arg2)		begin		local candidates := GetMatchedEntries('places, self.entries);		if candidates then			begin			local count := Length(candidates);			local locations := Array(count, nil);			for i := 0 to count - 1 do				begin				local local7 := candidates[i];				local nameEntry := ResolveEntryAlias(local7.alias);				locations[i] := GetDataDefs('|nameRef.meetingPlace|):MakeNameRef(nameEntry, '|nameRef.meetingPlace|);				if :SetDisplayName(locations[i], local7, nameEntry) then					locations[i]._alias := nil				end;			arg1.locationEntries := locations			end		else if not arg2 then			begin			arg2 := FindPossibleLocation(self.noisewords, self.origPhrase);			if arg2 then				arg1.locationEntries := [(GetDataDefs('|nameRef.meetingPlace|):MakeNameRef({company: arg2}, '|nameRef.meetingPlace|))]			end		end,	PostParse: func()		begin		local rootView := GetRoot();		local parsedInfo := { givenTime: nil, usualTime: nil, usualValue: nil, currentTime: Time(), hasDate: nil, hasTime: nil };		local _action;		local actionList := GetVariable(self, 'action);		if actionList then			begin			for i := 0 to Length(actionList) - 1 do				begin				_action := actionList[i][0];				if isa(_action, 'schedule_act) and _action.usualTime exists then					begin					parsedInfo.usualValue := GetSlot(_action, 'usualTime);					parsedInfo.usualTime := StringToDate(parsedInfo.usualValue);					break					end				end;			_action := actionList[0][0]			end;		// set values in the schedule slip		local theSlip := rootView.(taskSlip);		local self_when := GetVariable(self, 'when);			// v		theSlip.totMin := :GetTime(self_when, parsedInfo);	// the remind task just uses self.when		theSlip.newTitle := :SetTitle();		local hasNoInvitees := :SetInvitees(theSlip);		if _action and isa(_action, 'special_event_act) then			begin			theSlip.event := true;			theSlip.repeatIt := GetVariable(_action, 'repeatIt);			theSlip.action := _action			end		else			begin			theSlip.event := nil;			theSlip.repeatIt := nil;			:SetLocation(theSlip, hasNoInvitees)			end;		// open the schedule slip and close the assistant		theSlip:Open();		rootView.assistant:Close()		end});// FindDefineGlobalConstant('kFindSignature,				[ kFindAction, kObject ]);DefineGlobalConstant('kFindPreconditions,			'[ action, user_obj ]);DefineGlobalConstant('kFindTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kFindAction,	signature: kFindSignature,	preconditions: kFindPreconditions,	taskSlip: 'findslip,	score: nil,	PostParse: func()		begin		local rootView := GetRoot();		local findApp := rootView.findDrawer;		findApp:Open();		rootView.assistant:Close();		local str := Clone(origPhrase);		str := :FilterAction(input, phrases, str, 'find_act);		if str then			str := GlueStrings(str);		findApp:setFindText(str);		RefreshViews()		end});// RemindDefineGlobalConstant('kRemindSignature,			[ kRemindAction, kWhenObject ]);DefineGlobalConstant('kRemindPreconditions,		'[ action, when ]);DefineGlobalConstant('kRemindTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kRemindAction,	signature: kRemindSignature,	preconditions: kRemindPreconditions,	taskSlip: 'remindSlip,	score: nil,	SetTitle: func()		begin		local str := GlueStrings(self.origPhrase);		foreach i, item in self.input do			if isa(item, 'remind_act) then				:RemoveFromString(str, self.phrases[i], nil)			else if isa(item, 'when_obj) and HasSlot(item, 'date) then				:RemoveFromString(str, self.phrases[i], true);		if str then			str := TrimString(str);		str		end,	PostParse: func()		begin		local rootView := GetRoot();		local theSlip := rootView.(taskSlip);		local parsedInfo := {givenTime: nil, usualTime: nil, usualValue: nil, currentTime: Time(), hasDate: nil, hasTime: nil};		theSlip.totMin := :GetTime(self.when, parsedInfo);		theSlip.title := :SetTitle();		theSlip:Open();		rootView.assistant:Close()		end});// MailDefineGlobalConstant('kMailSignature,				[ kMailAction, kWhoObject ]);DefineGlobalConstant('kMailPreconditions,			'[ action, who ]);DefineGlobalConstant('kMailTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kMailAction,	signature: kMailSignature,	preconditions: kMailPreconditions,	score: nil,	mailTag: nil,	taskType: 'mail,	transportStr: "Mail",	SetEmailTags: func(ioItem)		begin		local tags := :GetTransportTags('iaTags);		if tags then			ioItem.mailTag := tags		else			ioItem.mailTag := emailSystems.emailClasses		end,	PostParse: func()		begin		local rootView := GetRoot();		local txportSym := GetGroupTransport(taskType);		if not txportSym then			begin			rootView:Notify(kNotifyAlert, kAssistantTitle, "No mail transport installed.");			rootView.assistant:Close();			return			end;		local topApp := GetView('viewFrontmostApp);		local targetInfo := :IAGetTargetInfo(topApp, txportSym, transportStr);		if targetInfo = nil then			begin			rootView.assistant:Close();			return			end;		local candidates := GetMatchedEntries('allEntries, self.entries);		if candidates then			:RemoveGroupsExcept(candidates, '|nameRef.email|);		if candidates and Length(candidates) = 0 then			rootView:Notify(kNotifyAlert, kAssistantTitle, "Cannot mail to a group that is not an E-mail type group.")		else			begin			local routingSlip;			local item := rootView.(txportSym):NewItem(topApp);			if item <> nil then				begin				:SetEmailTags(item);				if candidates <> nil then					begin					local index := 0;					local hasRecipient;					foreach entry in candidates do						begin						local nameEntry := ResolveEntryAlias(entry.alias);						local nameRef := GetDataDefs('|nameRef.email|):MakeNameRef(nameEntry, '|nameRef.email|);						if :SetDisplayName(nameRef, entry, nameEntry) then							nameRef._alias := nil;						local primaryEmail := nil;						if ObjEntryClass(nameEntry) <> 'group then							primaryEmail := nameRef.email := DSGetCandidateEMail(item, nameEntry);						if not hasRecipient then							begin							item.toRef := [nameRef];							hasRecipient := true							end						else							begin							if not item.alternatives then								item.alternatives := [];							ArrayInsert(item.alternatives, nameRef, index);							index := index + 1							end;						local cards := GetRoot().cardfile:bcEMailAddress(nameEntry, [ '|string.email| ]);						if cards and Length(cards) > 0 and primaryEmail then							foreach bizCard in cards do							begin							local emailAddr := bizCard.email;							if not StrEqual(emailAddr, primaryEmail) and (item.mailTag and SetContains(item.mailTag, ClassOf(emailAddr))) then								begin								local altRef := Clone(nameRef);								altRef.name := Clone(altRef.name);								altRef.email := emailAddr;				// why Clone the name but not this?								if not item.alternatives then									item.alternatives := [];								ArrayInsert(item.alternatives, altRef, index);								index := index + 1								end							end						end					end				else					begin					local nameStr := FindPossibleName(self.noisewords, self.origPhrase);					if nameStr then						item.toRef := [(GetDataDefs('|nameRef.email|):MakeNameRef({name: {last: nameStr}}, '|nameRef.email|))]					end;				routingSlip := OpenRoutingSlip(item, targetInfo);				rootView.assistant:Close()				end;			if not routingSlip then				rootView:Notify(kNotifyAlert, kAssistantTitle, "There is nothing to mail.")			end		end});// FaxDefineGlobalConstant('kFaxSignature,				[ kFaxAction, kWhoObject, kPlaceObject, kPhoneObject, kFormObject ]);DefineGlobalConstant('kFaxPreconditions,			'[ action, who, places, phone, form ]);DefineGlobalConstant('kFaxTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kFaxAction,	signature: kFaxSignature,	preconditions: kFaxPreconditions,	iaWorkTags:	[	'faxPhone,		'|string.phone.faxPhone|,						'homefaxPhone,	'|string.phone.homefaxPhone|,						'phone ],	iaHomeTags: [	'homefaxPhone,	'|string.phone.homefaxPhone|,						'faxPhone,		'|string.phone.faxPhone|,						'phone ],	score: nil,	taskType: 'fax,	transportStr: "Fax",	GetFaxTags: func(arg1)		begin		if HasSlot(arg1, 'phoneTag) then			begin			if arg1.phoneTag = 'homefaxPhone then self.iaHomeTags else self.iaWorkTags			end		else			begin			local tagsSym := :GetPreferredSymb();			local tags := :GetTransportTags(tagsSym);		// original is not local!			if tags then tags else self.(tagsSym)			end		end,	PostParse: func()		begin		local rootView := GetRoot();		local txportSym := GetGroupTransport(taskType);		if not txportSym then			begin			rootView:Notify(kNotifyAlert, kAssistantTitle, "No fax transport installed.");			return			end;		local topApp := GetView('viewFrontmostApp);		local targetInfo := :iaGetTargetInfo(topApp, txportSym, transportStr);		if targetInfo = nil then			begin			rootView.assistant:Close();			return			end;		local candidates := GetMatchedEntries('allEntries, self.entries);		if candidates then			:RemoveGroupsExcept(candidates, '|nameRef.fax|);		if if candidates then			Length(candidates) = 0 then			rootView:Notify(kNotifyAlert, kAssistantTitle, "Cannot fax a group that is not a Faxes type group.")		else			begin			local routingSlip;			local item := rootView.(txportSym):NewItem(topApp);			if item <> nil then				begin				PhoneUtility(item, self);				if not HasSlot(item, 'dialdirect) then					item.phoneTag := :GetFaxTags(local2);				item.candidates := candidates;				:FillPhoneSlip(item, '|nameRef.fax|);				routingSlip := OpenRoutingSlip(item, targetInfo);				rootView.assistant:Close()				end;			if not routingSlip then				rootView:Notify(kNotifyAlert, kAssistantTitle, "There is nothing to fax.")			end		end});// PrintDefineGlobalConstant('kPrintSignature,				[ kPrintAction ]);DefineGlobalConstant('kPrintPreconditions,		'[ action ]);DefineGlobalConstant('kPrintTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kPrintAction,	signature: kPrintSignature,	preconditions: kPrintPreconditions,	score: nil,	taskType: 'print,	transportStr: "Print",	PostParse: func()		begin		local rootView := GetRoot();		local txportSym := GetGroupTransport(taskType);		if not txportSym then			begin			rootView:Notify(kNotifyAlert, kAssistantTitle, "No print transport installed.");			return			end;		local topApp := GetView('viewFrontmostApp);		local targetInfo := :iaGetTargetInfo(topApp, txportSym, transportStr);		if targetInfo = nil then			begin			rootView.assistant:Close();			return			end;		local routingSlip;		local item := rootView.(txportSym):NewItem(topApp);		if item <> nil then			begin			routingSlip := OpenRoutingSlip(item, targetInfo);			rootView.assistant:Close()			end;		if not routingSlip then			rootView:Notify(kNotifyAlert, kAssistantTitle, "There is nothing to print.")		end});// CallDefineGlobalConstant('kCallSignature,				[ kCallAction, kWhoObject, kPlaceObject, kPhoneObject ]);DefineGlobalConstant('kCallPreconditions,			'[ action, who, places, phone ]);DefineGlobalConstant('kCallTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kCallAction,	signature: kCallSignature,	preconditions: kCallPreconditions,	taskSlip: '|PhoneHome:Newton|,	score: nil,	iaHomeTags:	[	'homePhone,			'|string.phone.homePhone|,						'workPhone,			'|string.phone.workPhone|,						'carPhone,			'|string.phone.carPhone|,						'mobilePhone,		'|string.phone.mobilePhone|,						'|string.pager|,	'phone ],	iaWorkTags:	[	'workPhone,			'|string.phone.workPhone|,						'homePhone,			'|string.phone.homePhone|,						'carPhone,			'|string.phone.carPhone|,						'mobilePhone,		'|string.phone.mobilePhone|,						'|string.pager|,	'phone ],	GetPhoneTags: func(arg1)		begin		if HasSlot(arg1, 'phoneTag) then			[arg1.phoneTag, Intern("string.phone." & arg1.phoneTag), 'phone]		else			begin			local local1 := :GetPreferredSymb();			self.(local1)			end		end,	PostParse: func()		begin		local rootView := GetRoot();		local candidates := GetMatchedEntries('allEntries, self.entries);		if candidates then			:RemoveAllGroups(candidates);		if candidates and Length(candidates) = 0 then			rootView:Notify(kNotifyAlert, kAssistantTitle, "Cannot call a group.")		else			begin			local topApp := GetView('viewFrontmostApp);			local targetInfo := topApp:GetActiveView();			local item := rootView.(taskSlip):NewItem(topApp);			if targetInfo then				begin				targetInfo := targetInfo:GetTargetInfo('Routing);				if not targetInfo.view then					targetInfo.view := {};				if not targetInfo.target then					targetInfo.target := {}				end			else				targetInfo := {view: {}, target: {}};			item.candidates := candidates;			PhoneUtility(item, self);			if not HasSlot(item, 'dialDirect) then				item.phoneTag := :GetPhoneTags(item);			:FillPhoneSlip(item, '|nameRef.phone|);			item.assistNoVerify := true;			OpenRoutingSlip(item, targetInfo)			end;		rootView.assistant:Close()		end});// TimeDefineGlobalConstant('kPseudoTitle,{	_proto: protoTitle,	preallocatedContext: 'title,	title: nil});DefineGlobalConstant('kPseudoOverview,{	_proto: protoOverview,	preallocatedContext: 'overview,	viewFlags: 0x205,	viewBounds: SetBounds(0, 16, 0, -16),	viewJustify: vjParentFullH + vjParentFullV,	autoDeselect: true,	selectIndent: 0,	nothingCheckable: true,	cursor: nil,	viewSetupFormScript: func()		begin		cursor := @505:New({}, items)		end,	viewSetupChildrenScript: func()		begin		:SetupAbstracts(cursor:Clone())		end,	Abstract: func(item, bounds)		begin		local local1 := ResolveEntryAlias(item.entry);		local local2 := LocalTime(nil, local1);		[	MakeText(item.title, bounds.left + 37, bounds.top, bounds.right, bounds.top + 11),			MakeText(HourMinute(local2) & "  " & ShortDate(local2), bounds.left + 37, bounds.top + 11 + 2, bounds.right, bounds.top + 22 + 2),			ScaleShape(MakeShape({				mask: MakeBinaryFromHex("00000000000400970097004B00B40066000000000000000000000000000000000000000000000000180406001E001E000B8474000D002C0007003800041E080000798000007C800000FDC0001475000000BC8A00007DC0000074C00000300000041D0800070038000D002C000B8874001E001E0018080600000000000000000000000000", 'mask),				bits: MakeBinaryFromHex("00000000000400970097004B00B40066000000000000000000000000000C0000000C0000001E0000181A06001E3F1E000BFBF4000DFFEC0006E1D800078C7800070038000F0C3C003E0C1F00EA8C5FC0FE9C55C03E0E1F000F073C000701B800078C780006E1D8000DFFEC000BF7F4001E3F1E0018160600001E0000000C0000000C0000", 'bits),				bounds: SetBounds(0, 0, 27, 29)}), nil, RelBounds(bounds.left + 10, bounds.top + 4, 16, 16)) ]		end,	HitItem: func(index, x, y)		begin		local cursr := cursor:Clone();		cursr:Move(index);		local item := cursr:Entry();		local worldClockApp := GetRoot().worldClock;		worldClockApp:Open();		openChild := worldClockApp:ShowFoundItem(item);		base:Close()		end,	Scroller: func(index)		begin		cursor:Move(index);		:RedoChildren();		:Dirty()		end});DefineGlobalConstant('kTimeSignature,				[ kTimeAction ]);DefineGlobalConstant('kTimePreconditions,			'[ time_act ]);DefineGlobalConstant('kTimeTask,{	_proto: @805,	isa: kTaskTemplate,	primary_act: kTimeAction,	signature: kTimeSignature,	preconditions: kTimePreconditions,	taskSlip: nil,	score: nil,	pseudoOverview:	{		_proto: protoFloatNGo,		viewFlags: 0x204,		viewBounds: SetBounds(0, 0, 224, 210),		viewJustify: 0x50,		declareSelf: 'base,		items: nil,		city: nil,		ReOrientToScreen: ROM_DefRotateFunc,		viewSetupFormScript: func()			begin			inherited:?viewSetupFormScript();			self.overview.items := items;			self.title.title := ParamStr("Time in ^0", [city])			end,		stepChildren: [ stepChildren: 		kPseudoTitle,														kPseudoOverview ],		stepAllocateContext:	[	'title,		kPseudoTitle,										'overview,	kPseudoOverview ],		title: nil,		overview: nil,		debug: 2115625	},	PostParse: func()		begin		local rootView := GetRoot();		local ass := rootView.assistant;		local str := Clone(origPhrase);		str := :FilterAction(input, phrases, str, 'time_act);		if str then			str := :FilterNoise(str, @270);	// stopWordList		if str then			str := GlueStrings(str);		if str then			begin			local worldClockApp := rootView.worldClock;			local result := worldClockApp:Find(str, [], 'localFind, nil);			if result then				begin				local foundItems := result.items;				if Length(foundItems) = 1 then					begin					worldClockApp:Open();					worldClockApp:ShowFoundItem(foundItems[0])					end				else					begin					local theView := BuildContext(pseudoOverview);					theView.items := foundItems;					theView.city := str;					theView:Open()					end;				ass:Close()				end			else				ass:Duh(nil)			end		else			begin			ass:Close();			rootView.worldClock:Open()			end		end});// AboutDefineGlobalConstant('kAboutSignature,				[ kAboutAction ]);DefineGlobalConstant('kAboutPreconditions,		'[ about_act ]);DefineGlobalConstant('kAboutTask,{	value: "About Task",	isa: kTaskTemplate,	primary_act: kAboutAction,	signature: kAboutSignature,	preconditions: kAboutPreconditions,	taskSlip: nil,	choices: nil,	score: nil,	PostParse: func() call @859 with ()});// DefaultDefineGlobalConstant('kDefaultSignature,			[ kObject ]);DefineGlobalConstant('kDefaultPreconditions,		'[ user_obj ]);DefineGlobalConstant('kDefaultTask,{	value: "Default Task",	isa: kTaskTemplate,	primary_act: kDefaultAction,	signature: kDefaultSignature,	preconditions: kDefaultPreconditions,	taskSlip: nil,	choices: nil,	score: nil,	PostParse: func()		begin		choices := GetRelevantTemplates(self.user_obj[0][0]);		if choices <> nil then			begin			local ass := GetRoot().assistant;	// original is not local!			ass.assistLine.defaultChoices := choices;			ass.assistLine:SetLabelCommands(Sort(Clone(choices), '|str<|, nil));			ass:PickOne()			end		end});/* assistFrames ------------------------------------------------------------- */assistFrames := {// object templates -- DS dictionary init	parsed_number: kNumberObject,// object templates -- DS heuristics init	who_obj: kWhoObject,	what_obj: kWhatObject,	when_obj: kWhenObject,	where_obj: kWhereObject,	parser_obj: kParserObject,// task templates -- DS task template init	action: kAction,	user_obj: kObject,	dyna_user_action: { isa: kAction },	dyna_user_obj: { isa: kObject },// for lexical lookup	lexical:	{ isa: nil,	value: nil },// list of all built-in tasks	task_list:	[		kSchedulingTask,		kFindTask,		kRemindTask,		kMailTask,		kFaxTask,		kPrintTask,		kCallTask,		kTimeTask,		kDefaultTask,		kAboutTask	],// for FIAatWork	entries:	{		person: nil,		places: nil,		personadded: nil,		placeadded: nil,		exception: nil	},	matched:	{		person: nil,		places: nil	},//	action templates	find_act: kFindAction,	finding_sig: kFindSignature,	finding_precond: kFindPreconditions,	finding_task: kFindTask,	remind_act: kRemindAction,	remembering_sig: kRemindSignature,	remembering_precond: kRemindPreconditions,	remembering_task: kRemindTask,	mail_act: kMailAction,	mailing_sig: kMailSignature,	mailing_precond: kMailPreconditions,	mailing_task: kMailTask,	fax_act: kFaxAction,	faxing_sig: kFaxSignature,	faxing_precond: kFaxPreconditions,	faxing_task: kFaxTask,	print_act: kPrintAction,	printing_sig: kPrintSignature,	printing_precond: kPrintPreconditions,	printing_task: kPrintTask,	call_act: kCallAction,	calling_sig: kCallSignature,	calling_precond: kCallPreconditions,	calling_task: kCallTask,	time_act: kTimeAction,	time_sig: kTimeSignature,	time_precond: kTimePreconditions,	time_task: kTimeTask,	about_act: kAboutAction,	about_sig: kAboutSignature,	about_precond: kAboutPreconditions,	about_task: kAboutTask,	default_act: kDefaultAction,	default_sig: kDefaultSignature,	default_precond: kDefaultPreconditions,	default_task: kDefaultTask,	schedule_act:  kScheduleAction,	scheduling_sig: kScheduleSignature,	scheduling_precond: kSchedulePreconditions,	scheduling_task: kSchedulingTask,	meet_act:		kMeetAction,	meal_act:		kMealAction,	breakfast_act: {  isa: kMealAction,  usualTime:  "7:00 am",  lexicon: [ [ "breakfast" ] ] },	brunch_act:		{  isa: kMealAction,  usualTime: "10:00 am",  lexicon: [ [ "brunch" ] ] },	lunch_act:		{  isa: kMealAction,  usualTime: "12:00 pm",  lexicon: [ [ "lunch" ] ] },	dinner_act:		{  isa: kMealAction,  usualTime:  "7:00 pm",  lexicon: [ [ "dinner" ] ] },	special_event_act: kSpecialEventAction,	birthday:	{		isa: kSpecialEventAction,	lexicon: [ [ "birthday", "bday", "b-day" ] ],		repeatIt: 'yearly,		GetTitle: func(entry) ParamStr("Bday: ^0", [(GetDataDefs('|nameRef.people|):Get(entry, 'name, 'text))]),		AddToCardfile: func(entry, date, dateEntry)			begin			if GetRoot().cardfile:AddCardData(entry, 'personal, {bday: date}) then				begin				entry.bdayEvent := MakeEntryAlias(dateEntry);				EntryChange(entry)				end			end	},	anniversary:	{		isa: kSpecialEventAction,	lexicon: [ [ "anniversary" ] ],		repeatIt: 'yearly,		GetTitle: func(entry) ParamStr("Anniv.: ^0", [(GetDataDefs('|nameRef.people|):Get(entry, 'name, 'text))]),		AddToCardfile: func(entry, date, dateEntry)			begin			if GetRoot().cardfile:AddCardData(entry, 'personal, {anniversary: date}) then				begin				entry.anniversaryEvent := MakeEntryAlias(dateEntry);				EntryChange(entry)				end			end	},	holiday:	{		isa: kSpecialEventAction,	lexicon: [ [ "holiday" ] ],		repeatIt: nil	},//	target templates -- persons (who_obj)	person: kPersonObject,	title: { isa: kWhoObject },	affiliate: { isa: kPersonObject },	group: { isa: kPersonObject },	custom: { isa: kPersonObject },//	target templates -- fax form (what_obj)	form: kFormObject,//	target templates -- places (user_obj . where_obj)	places: kPlaceObject,	company: { isa: kPlaceObject, value: nil },	address: { isa: kWhereObject },	town: { isa: kPlaceObject },	city: { isa: kPlaceObject },	county: { isa: kPlaceObject },	province: { isa: kPlaceObject },	state: { isa: kPlaceObject },	region: { isa: kWhereObject },	country: { isa: kPlaceObject },	postal_code: { isa: kWhereObject },	phone: kPhoneObject,	parsed_phone:	{ isa: kPhoneObject },	phone_tag: kTaggedPhoneObject,	homePhone:  {  isa: kTaggedPhoneObject,  tagSymbol: 'homePhone,		lexicon: [ [ "home phone", "home" ] ] },	workPhone:  {  isa: kTaggedPhoneObject,  tagSymbol: 'workPhone,		lexicon: [ [ "work", "work phone" ] ] },	faxPhone:	{  isa: kTaggedPhoneObject,  tagSymbol: 'faxPhone,			lexicon: [   "fax number" ] },	mobilePhone:{  isa: kTaggedPhoneObject,  tagSymbol: 'mobilePhone,		lexicon: [ [ "cellular", "cellular phone", "cellular number", "mobile", "mobile phone", "mobile number" ] ] },	carPhone:	{  isa: kTaggedPhoneObject,  tagSymbol: 'carPhone,			lexicon: [ [ "car", "car phone", "car number" ] ] },	beeper:		{  isa: kTaggedPhoneObject,  tagSymbol: '|string.pager|,	lexicon: [ [ "pager", "pager number", "beeper" ] ] },//	target templates -- times (parsed_number . when_obj)	date:	{	isa: kWhenObject,	value: nil },	time:	{ 	isa: kWhenObject, value: nil },// target templates - miscellaneous (parser_obj)	salutationPrefix:	{		isa: kParserObject,		lexicon: [ [ "dear", "to", "attention", "attn", "attn.", "hey" ] ]	},// target templates - task	task_template: kTaskTemplate,	dsQuery:	{		type: 'words,		words: nil,		entirewords: true	},	iacalendar:		{ isa: kWhatObject },	iaref:			{ class: nil,  alias: nil },	debug: 157285};