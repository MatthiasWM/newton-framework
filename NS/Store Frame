storeParent := {	Abort: plainC.StoreAbort,	AtomicAction: func(action)		begin		try 			:Lock();			local result := call action with ();			:Unlock()		onexception |evt.ex| do			begin			:Abort();			Rethrow()			end;		result		end,	Lock: plainC.StoreLock,	Unlock: plainC.StoreUnlock,	BusyAction: func(appSym, appName, action)		begin		try 			:MarkBusy(appSym, appName);			local result := call action with ();			:MarkNotBusy(appSym)		onexception |evt.ex| do begin			:MarkNotBusy(appSym);			Rethrow()			end;		result		end,	MarkBusy: func(appSym, appName)		begin		local slot := :CardSlot();		if slot then MarkSlotBusy(appSym, slot, appName)		end,	MarkNotBusy: func(appSym)		begin		local slot := :CardSlot();		if slot then MarkSlotNotBusy(appSym, slot)		end,	CardSlot: plainC.StoreCardSlot,	CardType: plainC.StoreCardType,	CheckWriteProtect: plainC.StoreCheckWriteProtect,	IsReadOnly: plainC.StoreIsReadOnly,	IsValid: plainC.StoreIsValid,	SetPassword: plainC.StoreSetPassword/*,*/,	HasPassword: plainC.StoreHasPassword,	GetKind: plainC.StoreGetKind,	SetSignature: plainC.StoreSetSignature/*signature*/,	GetSignature: plainC.StoreGetSignature,	SetName: func(newName)		begin		local oldName := :GetName();		local result := :SetNameQT(newName);		CallFrameBasedRegistryFns(storeChangeRegistry, [self, 'storeReNamed, oldName]);		result		end,	SetNameQT: plainC.StoreSetName/*name*/,	GetName: plainC.StoreGetName,	SetInfo: func(tag, value)		begin		local result := :SetInfoQT(tag, value);		CallFrameBasedRegistryFns(storeChangeRegistry, [self, 'storeInfoChanged, tag]);		result		end,	SetInfoQT: plainC.StoreSetInfo/*tag,value*/,	GetInfo: plainC.StoreGetInfo/*tag*/,	SetAllInfo: func(info)		begin		local result := :SetAllInfoQT(info);		CallFrameBasedRegistryFns(storeChangeRegistry, [self, 'storeInfoChanged, nil]);		result		end,	SetAllInfoQT: plainC.StoreSetAllInfo/*info*/,	GetAllInfo: plainC.StoreGetAllInfo,	SetObjectSize: plainC.StoreSetObjectSize/*obj,size*/,	GetObjectSize: plainC.StoreGetObjectSize/*obj*/,	TotalSize: plainC.StoreTotalSize,	UsedSize: plainC.StoreUsedSize,	Erase: func()		begin		local name := :GetName();		local result := :EraseQT();		CallFrameBasedRegistryFns(storeChangeRegistry, [self, 'storeErased, name]);		result		end,	EraseQT: plainC.StoreErase,	CreateSoup: plainC.StoreCreateSoup/*name,indexes*/,	CreateSoupXmit: func(name, indexes, changeSym)		begin		local soup := :CreateSoup(name,indexes);		if changeSym then XmitSoupChange(name, changeSym, 'soupCreated, soup);		soup		end,	ConvertSoupSortTables: plainC.StoreConvert/**/,	CheckUnion: plainC.StoreCheckUnion,	SoupsInUse: func() self.soups,	GetSoupNames: plainC.StoreGetSoupNames,	HasSoup: plainC.StoreHasSoup/*name*/,	GetSoup: plainC.StoreGetSoup/*name*/,	NewObject: plainC.StoreNewObject,	NewVBO: plainC.StoreNewVBO/*class,size*/,	NewCompressedVBO: plainC.StoreNewComprVBO/*class,size,companderName,companderArgs*/,	ReadObject: plainC.StoreReadObject/*,,*/,	WriteObject: plainC.StoreWriteObject/*,,,*/,	WriteWholeObject: plainC.StoreWriteWholeObject/*,,,*/,	DeleteObject: plainC.StoreDeleteObject/*obj*/,	SuckPackageFromBinary: plainC.StoreSuckPkgFromBinary/*binary,parms*/,	SuckPackageFromEndPoint: plainC.StoreSuckPkgFromEndpoint/*endpoint,parms*/,	RestorePackage: plainC.StoreRestorePkg/**/,	RestoreSegmentedPackage: plainC.StoreRestoreSegmentedPkg/*,*/};soupParent := {	Query: plainC.CommonSoupQuery/*querySpec*/,	Collect: plainC.SoupCollect/*querySpec*/,	SetName: plainC.PlainSoupSetName/*name*/,	GetName: plainC.CommonSoupGetName,	GetStore: plainC.PlainSoupGetStore,	GetSize: plainC.PlainSoupGetSize,	SetFlags: plainC.SoupSetFlags/*flags*/,	GetFlags: plainC.SoupGetFlags,	GetNextUId: plainC.PlainSoupGetNextUId,	MakeKey: plainC.PlainSoupMakeKey/*string,indexPath*/,	IsValid: plainC.SoupIsValid,	SetSignature: plainC.PlainSoupSetSignature/*signature*/,	GetSignature: plainC.PlainSoupGetSignature,	SetInfo: plainC.PlainSoupSetInfo/*tag,info*/,	SetInfoXmit: func(tag, info, changeSym)		begin		local result := :SetInfo(tag, info);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupInfoChanged, self);		result		end,	GetInfo: plainC.PlainSoupGetInfo/*tag*/,	GetInfoModTime: plainC.SoupGetInfoModTime,	SetAllInfo: plainC.PlainSoupSetAllInfo/*info*/,	SetAllInfoXmit: func(info, changeSym)		begin		local result := :SetAllInfo(info);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupInfoChanged, self);		result		end,	GetAllInfo: plainC.PlainSoupGetAllInfo,	HasTags: plainC.PlainSoupHasTags,	GetTags: plainC.PlainSoupGetTags,	AddTags: plainC.PlainSoupAddTags/*tags*/,	AddTagsXmit: func(tags, changeSym)		begin		local result := :AddTags(tags);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupTagsChanged, self);		result		end,	ModifyTag: plainC.PlainSoupModifyTag/*oldTag,newTag*/,	ModifyTagXmit: func(oldTag, newTag, changeSym)		begin		local result := :ModifyTag(oldTag, newTag);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupTagsChanged, self);		result		end,	RemoveTags: plainC.PlainSoupRemoveTags/*tags*/,	RemoveTagsXmit: func(tags, changeSym)		begin		local result := :RemoveTags(tags);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupTagsChanged, self);		result		end,	AddIndex: plainC.PlainSoupAddIndex/*index*/,	AddIndexXmit: func(index, changeSym)		begin		local result := :AddIndex(index);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupIndexAdded, {soup: self, indexPath: index.path});		result		end,	RemoveIndex: plainC.PlainSoupRemoveIndex/*indexPath*/,	RemoveIndexXmit:func(indexPath, changeSym)		begin		local result := :RemoveIndex(indexPath);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupIndexRemoved, {soup: self, indexPath: indexPath});		result		end,	IndexSizes: plainC.PlainSoupIndexSizes,	GetIndexes: plainC.PlainSoupGetIndexes,	GetIndexesModTime: plainC.SoupGetIndexesModTime,	Add: plainC.PlainSoupAdd/*entry*/,	AddXmit: func(entry, changeSym)		begin		local result := :Add(entry);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'entryAdded, entry);		result		end,	AddFlushed: plainC.SoupAddFlushed/*entry*/,	AddFlushedXmit: func(entry, changeSym)		begin		result := :AddFlushed(entry);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'entryAdded, entry);		result		end,	AddWithUniqueId: plainC.PlainSoupAddWithUniqueId/*entry*/,	AddWithUniqueIdXmit: func(entry, changeSym)		begin		result := :AddWithUniqueId(entry);		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'entryAdded, entry);		result		end,	CopyEntriesWithCallback: plainC.PlainSoupCopyEntriesWithCallBack/*,,*/,	CopyEntries: plainC.PlainSoupCopyEntries/**/,	CopyEntriesXmit: func(fromSoup, changeSym)		begin		local result := :CopyEntries(fromSoup);		if changeSym then			XmitSoupChange(fromSoup:GetName(), changeSym, 'whatThe, nil);		result		end,	RemoveAllEntries: plainC.PlainSoupRemoveAllEntries,	RemoveAllEntriesXmit: func(changeSym)		begin		local result := :RemoveAllEntries();		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'whatThe, nil);		result		end,	RemoveFromStore: plainC.PlainSoupRemoveFromStore,	RemoveFromStoreXmit: func(changeSym)		begin		local theStore := :GetStore();		local result := :RemoveFromStore();		if changeSym then			XmitSoupChange(:GetName(), changeSym, 'soupDeleted, theStore);		result		end,	Flush: func()		begin		BadWickedNaughtyNoot("soup:Flush(\"" & :GetName() & "\")", 'discontinued);		:NaughtyFlush()		end,	NaughtyFlush: plainC.PlainSoupFlush};cursorParent := {	Move: plainC.CursorMove/*offset*/,	GoTo: plainC.CursorGoTo/*entry*/,	GoToKey: plainC.CursorGoToKey/*key*/,	Next: plainC.CursorNext,	Prev: plainC.CursorPrev,	Reset: plainC.CursorReset,	ResetToEnd: plainC.CursorResetToEnd,	Entry: plainC.CursorEntry,	Clone: plainC.CursorClone,	CountEntries: plainC.CursorCountEntries,	WhichEnd: plainC.CursorWhichEnd,	Soup: plainC.CursorSoup,	IndexPath: plainC.CursorIndexPath,	EntryKey: plainC.CursorEntryKey,	Status: plainC.CursorStatus};