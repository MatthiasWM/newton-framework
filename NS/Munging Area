/* -------------------------------------------------------------------------- */

/* Templates ---------------------------------------------------------------- */

constant kTaskTemplate := '{};


/* Objects ------------------------------------------------------------------ */

constant kObject := '{};

constant kParserObject := '{};

DefineGlobalConstant('kWhoObject,		{ isa: kObject });
DefineGlobalConstant('kPersonObject,	{ isa: kWhoObject,  value: nil });

DefineGlobalConstant('kWhatObject,		{ isa: kObject });

DefineGlobalConstant('kNumberObject,	{ isa: kObject });

DefineGlobalConstant('kWhenObject,		{ isa: kNumberObject });

DefineGlobalConstant('kWhereObject,		{ isa: kObject });

DefineGlobalConstant('kPlaceObject,		{ isa: kWhereObject });

DefineGlobalConstant('kPhoneNumber,		{ isa: kWhereObject, lexicon: [ "phone number" ], value: nil });
DefineGlobalConstant('kTaggedPhoneNumber,	{ isa: kPhoneNumber });

DefineGlobalConstant('kFormObject,		{ isa: kWhatObject });


/* Actions ------------------------------------------------------------------ */

contant kAction := '{ value: "action" };

// Schedule
DefineGlobalConstant('kScheduleAction,			{ isa:  kAction,  lexicon: [ [ "schedule" ] ],  removeIt: nil});

DefineGlobalConstant('kMeetAction,				{ isa: kScheduleAction, lexicon: [ [ "meet", "meet me", "see", "talk to" ] ] });
DefineGlobalConstant('kMealAction,				{ isa: kScheduleAction });
DefineGlobalConstant('kSpecialEventAction,	{ isa: kScheduleAction });

// Find
DefineGlobalConstant('kFindAction,		{ isa: kAction,  lexicon: [ [ "find", "locate", "search for", "look for" ] ]});

// Remind
DefineGlobalConstant('kRemindAction,	{ isa: kAction,  lexicon: [ [ "remember", "remind", "remind me", "to do", "todo", "don't forget to", "don't let me forget to" ] ],  meta_level: true});

// Mail
DefineGlobalConstant('kMailAction,		{ isa: kAction,  lexicon: [ [ "mail", "send", "email", "mail" ] ]});	// sic

// Fax
DefineGlobalConstant('kFaxAction,		{ isa: kAction,  lexicon: [ [ "fax" ] ]});

// Print
DefineGlobalConstant('kPrintAction,		{ isa: kAction,  lexicon: [ [ "print" ] ]});

// Call
DefineGlobalConstant('kCallAction,		{ isa:  kAction,  lexicon: [ [ "call", "phone", "ring", "dial" ] ]});

// Time
DefineGlobalConstant('kTimeAction,		{ isa: kAction,	lexicon: [ [ "time", "time in", "the time in", "what time is it", "what time is it in", "what time", "what is the time", "what is the time in" ] ]});

// About
DefineGlobalConstant('kAboutAction,		{ isa:  kAction,  lexicon: [ [ "about newton" ] ]});

// Default
DefineGlobalConstant('kDefaultAction,	{ isa:  kAction });


/* Task Templates ----------------------------------------------------------- */

// Schedule
DefineGlobalConstant('kScheduleSignature,			[ kScheduleAction, kWhoObject, kPlaceObject, kWhenObject ]);
DefineGlobalConstant('kSchedulePreconditions,	'[ action, who, where, when ]);
DefineGlobalConstant('kSchedulingTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kScheduleAction,
	signature: kScheduleSignature,
	preconditions: kSchedulePreconditions,
	taskSlip: 'scheduleSlip,
	score: nil,

	SetTitle: func()
		begin
		local local1 := self.input;
		local str := GlueStrings(self.origPhrase);
		local local3 := self.phrases;
		foreach local4, local5 in local1 do
			if isa(local5, 'schedule_act) and HasSlot(local5, 'removeIt) then
				:RemoveFromString(str, local3[local4], nil)
			else if isa(local5, 'when_obj) then
				:RemoveFromString(str, local3[local4], true);
		if str then
			str := TrimString(str);
		str
		end,

	SetInvitees: func(arg1)
		begin
		local local1, local2, local3, local4, local5, local8, local9;
		local2 := GetMatchedEntries('person, self.entries);
		if local2 then
			begin
			local3 := Length(local2);
			local4 := Array(local3, nil);
			for local5 := 0 to local3 - 1 do
				begin
				local8 := local2[local5];
				local9 := ResolveEntryAlias(local8.alias);
				local4[local5] := GetDataDefs('|nameRef.people|):MakeNameRef(local9, '|nameRef.people|);
				if :SetDisplayName(local4[local5], local8, local9) then
					(local4[local5]._alias := nil)
				end;
			arg1.nameEntries := local4
			end
		else
			begin
			local1 := FindPossibleName(self.noisewords, self.OrigPhrase);
			if local1 then
				(arg1.nameEntries := [(GetDataDefs('|nameRef.people|):MakeNameRef({name: {last: local1}}, '|nameRef.people|))])
			end;
		return local1
		end,

	SetLocation: func(arg1, arg2)
		begin
		local local1, local2, local3, local4, local7, local8;
		local1 := GetMatchedEntries('places, self.entries);
		if local1 then
			begin
			local2 := Length(local1);
			local3 := Array(local2, nil);
			for local4 := 0 to local2 - 1 do
				begin
				local7 := local1[local4];
				local8 := ResolveEntryAlias(local7.alias);
				local3[local4] := GetDataDefs('|nameRef.meetingPlace|):MakeNameRef(local8, '|nameRef.meetingPlace|);
				if :SetDisplayName(local3[local4], local7, local8) then
					(local3[local4]._alias := nil)
				end;
			arg1.locationEntries := local3
			end
		else (if not arg2 then
			begin
			arg2 := FindPossibleLocation(self.noisewords, self.OrigPhrase);
			if arg2 then
				(arg1.locationEntries := [(GetDataDefs('|nameRef.meetingPlace|):MakeNameRef({company: arg2}, '|nameRef.meetingPlace|))])
		end)
		end,

	PostParse: func()
		begin
		local parsedInfo := { givenTime: nil, usualTime: nil, usualValue: nil, currentTime: Time(), hasDate: nil, hasTime: nil };
		local rootView := GetRoot();
		local _action := GetVariable(self, 'action);
		if _action then
			begin
			for i := 0 to Length(_action) - 1 do
				begin
				local local7 := _action[i][0];
				if isa(local7, 'schedule_act) and local7.usualTime exists then
					begin
					parsedInfo.usualValue := GetSlot(local7, 'usualTime);
					parsedInfo.usualTime := StringToDate(parsedInfo.usualValue);
					break
					end
				end;
			_action := _action[0][0]
			end;
		// set values in the schedule slip
		local theSlip := rootView.(taskSlip);
		local local8 := GetVariable(self, 'when);
		theSlip.totMin := :GetTime(local8, parsedInfo);
		theSlip.newTitle := :SetTitle();
		local local10 := :SetInvitees(theSlip);
		if _action and isa(_action, 'special_event_act) then
			begin
			theSlip.event := true;
			theSlip.repeatIt := GetVariable(_action, 'repeatIt);
			theSlip.action := _action
			end
		else
			begin
			theSlip.event := nil;
			theSlip.repeatIt := nil;
			:SetLocation(theSlip, local10)
			end;
		// open the schedule slip and close the assistant
		theSlip:Open();
		rootView.assistant:Close()
		end
});


// Find
DefineGlobalConstant('kFindSignature,				[ kFindAction, kObject ]);
DefineGlobalConstant('kFindPreconditions,			'[ action, user_obj ]);
DefineGlobalConstant('kFindTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kFindAction,
	signature: kFindSignature,
	preconditions: kFindPreconditions,
	taskSlip: 'findslip,
	score: nil,

	PostParse: func()
		begin
		local rootView := GetRoot();
		local findApp := rootView.findDrawer;
		findApp:Open();
		rootView.assistant:Close();
		local str := Clone(origPhrase);
		str := :FilterAction(input, phrases, str, 'find_act);
		if str then
			str := GlueStrings(str);
		findApp:setFindText(str);
		RefreshViews()
		end
});


// Remind
DefineGlobalConstant('kRemindSignature,			[ kRemindAction, kWhenObject ]);
DefineGlobalConstant('kRemindPreconditions,		'[ action, when ]);
DefineGlobalConstant('kRemindTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kRemindAction,
	signature: kRemindSignature,
	preconditions: kRemindPreconditions,
	taskSlip: 'remindSlip,
	score: nil,

	SetTitle: func()
		begin
		local local1 := self.input;
		local str := GlueStrings(self.origPhrase);
		foreach local3, local4 in local1 do
			if isa(local4, 'remind_act) then
				:RemoveFromString(str, self.phrases[local3], nil)
			else if isa(local4, 'when_obj) and HasSlot(local4, 'date) then
				:RemoveFromString(str, self.phrases[local3], true);
		if str then
			str := TrimString(str);
		str
		end,

	PostParse: func()
		begin
		local parsedInfo := {givenTime: nil, usualTime: nil, usualValue: nil, currentTime: Time(), hasDate: nil, hasTime: nil};
		local rootView := GetRoot();
		local theSlip := rootView.(taskSlip);
		theSlip.totMin := :GetTime(self.when, parsedInfo);
		theSlip.title := :SetTitle();
		theSlip:Open();
		rootView.assistant:Close()
		end
});


// Mail
DefineGlobalConstant('kMailSignature,				[ kMailAction, kWhoObject ]);
DefineGlobalConstant('kMailPreconditions,			'[ action, who ]);
DefineGlobalConstant('kMailTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kMailAction,
	signature: kMailSignature,
	preconditions: kMailPreconditions,
	score: nil,
	mailTag: nil,
	taskType: 'mail,
	transportStr: "Mail",

	SetEmailTags: func(arg1)
		begin
		local local1 := :GetTransportTags('iaTags);
		if local1 then
			arg1.mailTag := local1
		else
			arg1.mailTag := EmailSystems.emailClasses
		end,

	PostParse: func()
		begin
		local local3, local4, local5, local6, local7, local8, local9, local10, local11, local13, local14, local15, local16, local18, local19, local20;
		local rootView := GetRoot();
		local txport := GetGroupTransport(taskType);
		if not txport then
			begin
			rootView:Notify(kNotifyAlert, "Assist", "No mail transport installed.");
			rootView.assistant:Close();
			return
			end;
		local3 := GetView('viewFrontmostApp);
		local4 := :iaGetTargetInfo(local3, txport, transportStr);
		if local4 = nil then
			begin
			rootView.assistant:Close();
			return
			end;
		local5 := GetMatchedEntries('allEntries, self.entries);
		if local5 then
			:RemoveGroupsExcept(local5, '|nameRef.email|);
		if if local5 then
			Length(local5) = 0 then
			rootView:Notify(kNotifyAlert, "Assist", "Cannot mail to a group that is not a E-mail type group.")
		else
			begin
			local2 := rootView.(txport):NewItem(local3);
			if local2 <> nil then
				begin
				:SetEmailTags(local2);
				if local5 <> nil then
					begin
					local8 := 0;
					local9 := true;
					foreach local10, local11 in local5 do
						begin
						local13 := ResolveEntryAlias(local11.alias);
						local7 := GetDataDefs('|nameRef.email|):MakeNameRef(local13, '|nameRef.email|);
						if :SetDisplayName(local7, local11, local13) then
							local7._alias := nil;
						local14 := nil;
						if ObjEntryClass(local13) <> 'group then
							(local14 := local7.email := dsGetCandidateEMail(local2, local13));
						if local9 <> nil then
							begin
							local2.toRef := [local7];
							local9 := nil
							end
						else
							begin
							if not local2.alternatives then
								local2.alternatives := [];
							ArrayInsert(local2.alternatives, local7, local8);
							local8 := local8 + 1
							end;
						local15 := GetRoot().cardfile:bcEMailAddress(local13, [ '|string.email| ]);
						if local15 and Length(local15) > 0 and local14 then
							foreach local16 in local15 do
							begin
							local18 := local16.email;
							if not StrEqual(local18, local14) and (local2.mailTag and SetContains(local2.mailTag, ClassOf(local18))) then
								begin
								local19 := Clone(local7);
								local19.name := Clone(local19.name);
								local19.email := local18;
								if not local2.alternatives then
									(local2.alternatives := []);
								ArrayInsert(local2.alternatives, local19, local8);
								local8 := local8 + 1
								end
							end
						end
					end
				else
					begin
					local20 := FindPossibleName(self.noisewords, self.origPhrase);
					if local20 then
						(local2.toRef := [(GetDataDefs('|nameRef.email|):MakeNameRef({name: {last: local20}}, '|nameRef.email|))])
					end;
				local6 := OpenRoutingSlip(local2, local4);
				rootView.assistant:Close()
				end;
			if not local6 then
				rootView:Notify(kNotifyAlert, "Assist", "There is nothing to mail.")
			end
		end
});


// Fax
DefineGlobalConstant('kFaxSignature,				[ kFaxAction, kWhoObject, kPlaceObject, kPhoneNumber, kFormObject ]);
DefineGlobalConstant('kFaxPreconditions,			'[ action, who, places, phone, form ]);
DefineGlobalConstant('kFaxTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kFaxAction,
	signature: kFaxSignature,
	preconditions: kFaxPreconditions,
	iaWorkTags:	[	'faxPhone,		'|string.phone.faxPhone|,
						'homefaxPhone,	'|string.phone.homefaxPhone|,
						'phone ],
	iaHomeTags: [	'homefaxPhone,	'|string.phone.homefaxPhone|,
						'faxPhone,		'|string.phone.faxPhone|,
						'phone ],
	score: nil,
	taskType: 'fax,
	transportStr: "Fax",

	GetFaxTags: func(arg1)
		begin
		if HasSlot(arg1, 'phoneTag) then
			begin
			if arg1.phoneTag = 'homefaxPhone then self.iaHomeTags else self.iaWorkTags
			end
		else
			begin
			local local1 := :GetPreferredSymb();
			local tags := :GetTransportTags(local1);		// original is not local!
			if tags then tags else self.(local1)
			end
		end,

	PostParse: func()
		begin
		local rootView := GetRoot();
		local txport := GetGroupTransport(taskType);
		if not txport then
			begin
			rootView:Notify(kNotifyAlert, "Assist", "No fax transport installed.");
			return
			end;
		local local3 := GetView('viewFrontmostApp);
		local local4 := :iaGetTargetInfo(local3, txport, transportStr);
		if local4 = nil then
			begin
			rootView.assistant:Close();
			return
			end;
		local local5 := GetMatchedEntries('allEntries, self.entries);
		if local5 then
			:RemoveGroupsExcept(local5, '|nameRef.fax|);
		if if local5 then
			Length(local5) = 0 then
			rootView:Notify(kNotifyAlert, "Assist", "Cannot fax a group that is not a Faxes type group.")
		else
			begin
			local local6;
			local2 := rootView.(txport):NewItem(local3);
			if local2 <> nil then
				begin
				PhoneUtility(local2, self);
				if not HasSlot(local2, 'dialdirect) then
					(local2.phoneTag := :GetFaxTags(local2));
				local2.candidates := local5;
				:FillPhoneSlip(local2, '|nameRef.fax|);
				local6 := OpenRoutingSlip(local2, local4);
				rootView.assistant:Close()
				end;
			if not local6 then
				rootView:Notify(kNotifyAlert, "Assist", "There is nothing to fax.")
			end
		end
});


// Print
DefineGlobalConstant('kPrintSignature,				[ kPrintAction ]);
DefineGlobalConstant('kPrintPreconditions,		'[ action ]);
DefineGlobalConstant('kPrintTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kPrintAction,
	signature: kPrintSignature,
	preconditions: kPrintPreconditions,
	score: nil,
	taskType: 'print,
	transportStr: "Print",

	PostParse: func()
		begin
		local rootView := GetRoot();
		local txport := GetGroupTransport(taskType);
		if not txport then
			begin
			rootView:Notify(kNotifyAlert, "Assist", "No print transport installed.");
			return
			end;
		local local3 := GetView('viewFrontmostApp);
		local local4 := :iaGetTargetInfo(local3, txport, transportStr);
		if local4 = nil then
			begin
			rootView.assistant:Close();
			return
			end;
		local local5;
		local2 := rootView.(txport):NewItem(local3);
		if local2 <> nil then
			begin
			local5 := OpenRoutingSlip(local2, local4);
			rootView.assistant:Close()
			end;
		if not local5 then
			rootView:Notify(kNotifyAlert, "Assist", "There is nothing to print.")
		end
});


// Call
DefineGlobalConstant('kCallSignature,				[ kCallAction, kWhoObject, kPlaceObject, kPhoneNumber ]);
DefineGlobalConstant('kCallPreconditions,			'[ action, who, places, phone ]);
DefineGlobalConstant('kCallTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kCallAction,
	signature: kCallSignature,
	preconditions: kCallPreconditions,
	taskSlip: '|PhoneHome:Newton|,
	score: nil,
	iaHomeTags:	[	'homePhone,			'|string.phone.homePhone|,
						'workPhone,			'|string.phone.workPhone|,
						'carPhone,			'|string.phone.carPhone|,
						'mobilePhone,		'|string.phone.mobilePhone|,
						'|string.pager|,	'phone ],
	iaWorkTags:	[	'workPhone,			'|string.phone.workPhone|,
						'homePhone,			'|string.phone.homePhone|,
						'carPhone,			'|string.phone.carPhone|,
						'mobilePhone,		'|string.phone.mobilePhone|,
						'|string.pager|,	'phone ],

	GetPhoneTags: func(arg1)
		begin
		if HasSlot(arg1, 'phoneTag) then
			[arg1.phoneTag, Intern("string.phone." & arg1.phoneTag), 'phone]
		else
			begin
			local local1 := :GetPreferredSymb();
			self.(local1)
			end
		end,

	PostParse: func()
		begin
		local rootView := GetRoot();
		local local2 := GetMatchedEntries('allEntries, self.entries);
		if local2 then
			:RemoveAllGroups(local2);
		if if local2 then
			Length(local2) = 0 then
			rootView:Notify(kNotifyAlert, "Assist", "Cannot call a group.")
		else
			begin
			local local3 := GetView('viewFrontmostApp);
			local local4 := local3:GetActiveView();
			local local5 := rootView.(taskSlip):NewItem(local3);
			if local4 then
				begin
				local4 := local4:GetTargetInfo('Routing);
				if not local4.view then
					local4.view := {};
				if not local4.target then
					local4.target := {}
				end
			else
				local4 := {view: {}, target: {}};
			local5.candidates := local2;
			PhoneUtility(local5, self);
			if not HasSlot(local5, 'dialdirect) then
				local5.phoneTag := :GetPhoneTags(local5);
			:FillPhoneSlip(local5, '|nameRef.phone|);
			local5.assistnoverify := true;
			OpenRoutingSlip(local5, local4)
			end;
		rootView.assistant:Close()
		end
});


// Time
DefineGlobalConstant('kPseudoTitle,
{
	_proto: protoTitle,
	preallocatedContext: 'title,
	title: nil
});
DefineGlobalConstant('kPseudoOverview,
{
	_proto: protoOverview,
	preallocatedContext: 'overview,
	viewFlags: 0x205,
	viewBounds: SetBounds(0, 16, 0, -16),
	viewJustify: vjParentFullH + vjParentFullV,
	autoDeselect: true,
	selectIndent: 0,
	nothingCheckable: true,
	cursor: nil,

	viewSetupFormScript: func()
		begin
		cursor := @505:New({}, items)
		end,

	viewSetupChildrenScript: func()
		begin
		:SetupAbstracts(cursor:Clone())
		end,

	Abstract: func(arg1, arg2)
		begin
		local local1 := ResolveEntryAlias(arg1.entry);
		local local2 := LocalTime(nil, local1);
		[	MakeText(arg1.title, arg2.left + 37, arg2.top, arg2.right, arg2.top + 11),
			MakeText(HourMinute(local2) & "  " & ShortDate(local2), arg2.left + 37, arg2.top + 11 + 2, arg2.right, arg2.top + 22 + 2),
			ScaleShape(MakeShape({
				mask: MakeBinaryFromHex("00000000000400970097004B00B40066000000000000000000000000000000000000000000000000180406001E001E000B8474000D002C0007003800041E080000798000007C800000FDC0001475000000BC8A00007DC0000074C00000300000041D0800070038000D002C000B8874001E001E0018080600000000000000000000000000", 'mask),
				bits: MakeBinaryFromHex("00000000000400970097004B00B40066000000000000000000000000000C0000000C0000001E0000181A06001E3F1E000BFBF4000DFFEC0006E1D800078C7800070038000F0C3C003E0C1F00EA8C5FC0FE9C55C03E0E1F000F073C000701B800078C780006E1D8000DFFEC000BF7F4001E3F1E0018160600001E0000000C0000000C0000", 'bits),
				bounds: SetBounds(0, 0, 27, 29)}), nil, RelBounds(arg2.left + 10, arg2.top + 4, 16, 16)) ]
		end,

	HitItem: func(arg1, arg2, arg3)
		begin
		local cursr := cursor:Clone();
		cursr:Move(arg1);
		local item := cursr:Entry();
		local worldClockApp := GetRoot().worldClock;
		worldClockApp:Open();
		openChild := worldClockApp:ShowFoundItem(item);
		base:Close()
		end,

	Scroller: func(arg1)
		begin
		cursor:Move(arg1);
		:RedoChildren();
		:Dirty()
		end
});

DefineGlobalConstant('kTimeSignature,				[ kTimeAction ]);
DefineGlobalConstant('kTimePreconditions,			'[ time_act ]);
DefineGlobalConstant('kTimeTask,
{
	_proto: @805,
	isa: kTaskTemplate,
	primary_act: kTimeAction,
	signature: kTimeSignature,
	preconditions: kTimePreconditions,
	taskSlip: nil,
	score: nil,

	pseudoOverview:
	{
		_proto: protoFloatNGo,
		viewFlags: 0x204,
		viewBounds: SetBounds(0, 0, 224, 210),
		viewJustify: 0x50,
		declareSelf: 'base,
		items: nil,
		city: nil,
		ReOrientToScreen: ROM_DefRotateFunc,
		viewSetupFormScript: func()
			begin
			inherited:?viewSetupFormScript();
			self.overview.items := items;
			self.title.title := ParamStr("Time in ^0", [city])
			end,
		stepChildren: [ stepChildren: 		kPseudoTitle,
														kPseudoOverview ],
		stepAllocateContext:	[	'title,		kPseudoTitle,
										'overview,	kPseudoOverview ],
		title: nil,
		overview: nil,
		debug: 2115625
	},

	PostParse: func()
		begin
		local rootView := GetRoot();
		local ass := rootView.assistant;
		local str := Clone(origPhrase);
		str := :FilterAction(input, phrases, str, 'time_act);
		if str then
			str := :FilterNoise(str, @270);	// stopWordList
		if str then
			str := GlueStrings(str);
		if str then
			begin
			local worldClockApp := rootView.worldClock;
			local local5 := [];
			local local6 := worldClockApp:Find(str, local5, 'localFind, nil);
			if local6 then
				begin
				local local7 := local6.items;
				local local8 := Length(local6.items);
				if local8 = 1 then
					begin
					worldClockApp:Open();
					worldClockApp:ShowFoundItem(local7[0])
					end
				else
					begin
					local theView := BuildContext(pseudoOverview);
					theView.items := local7;
					theView.city := str;
					theView:Open()
					end;
				ass:Close()
				end
			else
				ass:Duh(nil)
			end
		else
			begin
			ass:Close();
			rootView.worldClock:Open()
			end
		end
});


// About
DefineGlobalConstant('kAboutSignature,				[ kAboutAction ]);
DefineGlobalConstant('kAboutPreconditions,		'[ about_act ]);
DefineGlobalConstant('kAboutTask,
{
	value: "About Task",
	isa: kTaskTemplate,
	primary_act: kAboutAction,
	signature: kAboutSignature,
	preconditions: kAboutPreconditions,
	taskSlip: nil,
	choices: nil,
	score: nil,

	PostParse: func() call @859 with ()
});


// Default
DefineGlobalConstant('kDefaultSignature,			[ kObject ]);
DefineGlobalConstant('kDefaultPreconditions,		'[ user_obj ]);
DefineGlobalConstant('kDefaultTask,
{
	value: "Default Task",
	isa: kTaskTemplate,
	primary_act: kDefaultAction,
	signature: kDefaultSignature,
	preconditions: kDefaultPreconditions,
	taskSlip: nil,
	choices: nil,
	score: nil,

	PostParse: func()
		begin
		choices := GetRelevantTemplates(self.user_obj[0][0]);
		if choices <> nil then
			begin
			local ass := GetRoot().assistant;	// original is not local!
			ass.assistLine.defaultChoices := choices;
			ass.assistLine:SetLabelCommands(Sort(Clone(choices), '|str<|, nil));
			ass:PickOne()
			end
		end
});



/* assistFrame -------------------------------------------------------------- */

assistFrame := {

// object templates -- DS dictionary init
	parsed_number: kNumberObject,


// object templates -- DS heuristics init

	who_obj: kWhoObject,
	what_obj: kWhatObject,
	when_obj: kWhenObject,
	where_obj: kWhereObject,

	parser_obj: kParserObject,


// task templates -- DS task template init

	action: kAction,
	user_obj: kObject,

	dyna_user_action: { isa: kAction },
	dyna_user_obj: { isa: kObject },

// for lexical lookup

	lexical:	{ isa: nil,	value: nil },

// list of all built-in tasks

	task_list:
	[
		kSchedulingTask,
		kFindTask,
		kRemindTask,
		kMailTask,
		kFaxTask,
		kPrintTask,
		kCallTask,
		kTimeTask,
		kDefaultTask,
		kAboutTask
	],

// for FIAatWork

	entries:
	{
		person: nil,
		places: nil,
		personadded: nil,
		placeadded: nil,
		exception: nil
	},

	matched:
	{
		person: nil,
		places: nil
	},


//	action templates

	find_act: kFindAction,
	finding_sig: kFindSignature,
	finding_precond: kFindPreconditions,
	finding_task: kFindTask,

	remind_act: kRemindAction,
	remembering_sig: kRemindSignature,
	remembering_precond: kRemindPreconditions,
	remembering_task: kRemindTask,

	mail_act: kMailAction,
	mailing_sig: kMailSignature,
	mailing_precond: kMailPreconditions,
	mailing_task: kMailTask,

	fax_act: kFaxAction,
	faxing_sig: kFaxSignature,
	faxing_precond: kFaxPreconditions,
	faxing_task: kFaxTask,

	print_act: kPrintAction,
	printing_sig: kPrintSignature,
	printing_precond: kPrintPreconditions,
	printing_task: kPrintTask,

	call_act: kCallAction,
	calling_sig: kCallSignature,
	calling_precond: kCallPreconditions,
	calling_task: kCallTask,

	time_act: kTimeAction,
	time_sig: kTimeSignature,
	time_precond: kTimePreconditions,
	time_task: kTimeTask,

	about_act: kAboutAction,
	about_sig: kAboutSignature,
	about_precond: kAboutPreconditions,
	about_task: kAboutTask,

	default_act: kDefaultAction,
	default_sig: kDefaultSignature,
	default_precond: kDefaultPreconditions,
	default_task: kDefaultTask,

	schedule_act:  kScheduleAction,
	scheduling_sig: kScheduleSignature,
	scheduling_precond: kSchedulePreconditions,
	scheduling_task: kSchedulingTask,

	meet_act:		kMeetAction,

	meal_act:		kMealAction,
	breakfast_act: {  isa: kMealAction,  usualTime:  "7:00 am",  lexicon: [ [ "breakfast" ] ] },
	brunch_act:		{  isa: kMealAction,  usualTime: "10:00 am",  lexicon: [ [ "brunch" ] ] },
	lunch_act:		{  isa: kMealAction,  usualTime: "12:00 pm",  lexicon: [ [ "lunch" ] ] },
	dinner_act:		{  isa: kMealAction,  usualTime:  "7:00 pm",  lexicon: [ [ "dinner" ] ] },

	special_event_act: kSpecialEventAction,
	birthday:
	{
		isa: kSpecialEventAction,	lexicon: [ [ "birthday", "bday", "b-day" ] ],
		repeatIt: 'yearly,
		GetTitle: func(entry) ParamStr("Bday: ^0", [(GetDataDefs('|nameRef.people|):Get(entry, 'name, 'text))]),
		AddToCardfile: func(entry, date, dateEntry)
			begin
			if GetRoot().cardfile:AddCardData(entry, 'personal, {bday: date}) then
				begin
				entry.bdayEvent := MakeEntryAlias(dateEntry);
				EntryChange(entry)
				end
			end
	},
	anniversary:
	{
		isa: kSpecialEventAction,	lexicon: [ [ "anniversary" ] ],
		repeatIt: 'yearly,
		GetTitle: func(entry) ParamStr("Anniv.: ^0", [(GetDataDefs('|nameRef.people|):Get(entry, 'name, 'text))]),
		AddToCardfile: func(entry, date, dateEntry)
			begin
			if GetRoot().cardfile:AddCardData(entry, 'personal, {anniversary: date}) then
				begin
				entry.anniversaryEvent := MakeEntryAlias(dateEntry);
				EntryChange(entry)
				end
			end
	},

	holiday:
	{
		isa: kSpecialEventAction,	lexicon: [ [ "holiday" ] ],
		repeatIt: nil
	},


//	target templates -- persons (who_obj)

	person: kPersonObject,
	title: { isa: kWhoObject },
	affiliate: { isa: kPersonObject },
	group: { isa: kPersonObject },
	custom: { isa: kPersonObject },


//	target templates -- fax form (what_obj)

	form: kFormObject,


//	target templates -- places (user_obj . where_obj)

	places: kPlaceObject,
	company: { isa: kPlaceObject, value: nil },
	address: { isa: kWhereObject },
	town: { isa: kPlaceObject },
	city: { isa: kPlaceObject },
	county: { isa: kPlaceObject },
	province: { isa: kPlaceObject },
	state: { isa: kPlaceObject },
	region: { isa: kWhereObject },
	country: { isa: kPlaceObject },
	postal_code: { isa: kWhereObject },
	phone: kPhoneNumber,
	parsed_phone:	{ isa: kPhoneNumber },
	phone_tag: kTaggedPhoneNumber,
	homePhone:  {  isa: kTaggedPhoneNumber,  tagSymbol: 'homePhone,		lexicon: [ [ "home phone", "home" ] ] },
	workPhone:  {  isa: kTaggedPhoneNumber,  tagSymbol: 'workPhone,		lexicon: [ [ "work", "work phone" ] ] },
	faxPhone:	{  isa: kTaggedPhoneNumber,  tagSymbol: 'faxPhone,			lexicon: [   "fax number" ] },
	mobilePhone:{  isa: kTaggedPhoneNumber,  tagSymbol: 'mobilePhone,		lexicon: [ [ "cellular", "cellular phone", "cellular number", "mobile", "mobile phone", "mobile number" ] ] },
	carPhone:	{  isa: kTaggedPhoneNumber,  tagSymbol: 'carPhone,			lexicon: [ [ "car", "car phone", "car number" ] ] },
	beeper:		{  isa: kTaggedPhoneNumber,  tagSymbol: '|string.pager|,	lexicon: [ [ "pager", "pager number", "beeper" ] ] },


//	target templates -- times (parsed_number . when_obj)

	date:	{	isa: kWhenObject,	value: nil },
	time:	{ 	isa: kWhenObject, value: nil },


// target templates - miscellaneous (parser_obj)

	salutationPrefix:
	{
		isa: kParserObject,
		lexicon: [ [ "dear", "to", "attention", "attn", "attn.", "hey" ] ]
	},


// target templates - task

	task_template: kTaskTemplate,


	dsQuery:
	{
		type: 'words,
		words: nil,
		entirewords: true
	},

	iacalendar:		{ isa: kWhatObject },
	iaref:			{ class: nil,  alias: nil },

	debug: 157285
};
